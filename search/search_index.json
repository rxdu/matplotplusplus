{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Matplot++ A C++ Graphics Library for Data Visualization Data visualization can help programmers and scientists identify trends in their data and efficiently communicate these results with their peers. Modern C++ is being used for a variety of scientific applications, and this environment can benefit considerably from graphics libraries that attend the typical design goals toward scientific data visualization. Besides the option of exporting results to other environments, the customary alternatives in C++ are either non-dedicated libraries that depend on existing user interfaces or bindings to other languages. Matplot++ is a graphics library for data visualization that provides interactive plotting, means for exporting plots in high-quality formats for scientific publications, a compact syntax consistent with similar libraries, dozens of plot categories with specialized algorithms, multiple coding styles, and supports generic backends.","title":"Home"},{"location":"#matplot","text":"A C++ Graphics Library for Data Visualization Data visualization can help programmers and scientists identify trends in their data and efficiently communicate these results with their peers. Modern C++ is being used for a variety of scientific applications, and this environment can benefit considerably from graphics libraries that attend the typical design goals toward scientific data visualization. Besides the option of exporting results to other environments, the customary alternatives in C++ are either non-dedicated libraries that depend on existing user interfaces or bindings to other languages. Matplot++ is a graphics library for data visualization that provides interactive plotting, means for exporting plots in high-quality formats for scientific publications, a compact syntax consistent with similar libraries, dozens of plot categories with specialized algorithms, multiple coding styles, and supports generic backends.","title":"Matplot++"},{"location":"COMPLETE_GALLERY/","text":"Complete Gallery Line Plots Line Plot examples/line_plot/plot/plot_1.cpp : examples/line_plot/plot/plot_2.cpp : examples/line_plot/plot/plot_3.cpp : examples/line_plot/plot/plot_4.cpp : examples/line_plot/plot/plot_5.cpp : examples/line_plot/plot/plot_6.cpp : examples/line_plot/plot/plot_7.cpp : examples/line_plot/plot/plot_8.cpp : examples/line_plot/plot/plot_9.cpp : examples/line_plot/plot/plot_10.cpp : examples/line_plot/plot/plot_11.cpp : examples/line_plot/plot/plot_12.cpp : Line Plot 3D examples/line_plot/plot3/plot3_1.cpp : examples/line_plot/plot3/plot3_2.cpp : examples/line_plot/plot3/plot3_3.cpp : examples/line_plot/plot3/plot3_4.cpp : examples/line_plot/plot3/plot3_5.cpp : examples/line_plot/plot3/plot3_6.cpp : examples/line_plot/plot3/plot3_7.cpp : examples/line_plot/plot3/plot3_8.cpp : examples/line_plot/plot3/plot3_9.cpp : examples/line_plot/plot3/plot3_10.cpp : Stairs examples/line_plot/stairs/stairs_1.cpp : examples/line_plot/stairs/stairs_2.cpp : examples/line_plot/stairs/stairs_3.cpp : examples/line_plot/stairs/stairs_4.cpp : examples/line_plot/stairs/stairs_5.cpp : examples/line_plot/stairs/stairs_6.cpp : examples/line_plot/stairs/stairs_7.cpp : examples/line_plot/stairs/stairs_8.cpp : examples/line_plot/stairs/stairs_9.cpp : examples/line_plot/stairs/stairs_10.cpp : Error Bars examples/line_plot/errorbar/errorbar_1.cpp : examples/line_plot/errorbar/errorbar_2.cpp : examples/line_plot/errorbar/errorbar_3.cpp : examples/line_plot/errorbar/errorbar_4.cpp : examples/line_plot/errorbar/errorbar_5.cpp : examples/line_plot/errorbar/errorbar_6.cpp : examples/line_plot/errorbar/errorbar_7.cpp : examples/line_plot/errorbar/errorbar_8.cpp : examples/line_plot/errorbar/errorbar_9.cpp : examples/line_plot/errorbar/errorbar_10.cpp : Area examples/line_plot/area/area_1.cpp : examples/line_plot/area/area_2.cpp : examples/line_plot/area/area_3.cpp : examples/line_plot/area/area_4.cpp : Loglog Plot examples/line_plot/loglog/loglog_1.cpp : examples/line_plot/loglog/loglog_2.cpp : examples/line_plot/loglog/loglog_3.cpp : examples/line_plot/loglog/loglog_4.cpp : examples/line_plot/loglog/loglog_5.cpp : examples/line_plot/loglog/loglog_6.cpp : examples/line_plot/loglog/loglog_7.cpp : examples/line_plot/loglog/loglog_8.cpp : examples/line_plot/loglog/loglog_9.cpp : Semilogx Plot examples/line_plot/semilogx/semilogx_1.cpp : Semilogy Plot examples/line_plot/semilogy/semilogy_1.cpp : Function Plot examples/line_plot/fplot/fplot_1.cpp : examples/line_plot/fplot/fplot_2.cpp : examples/line_plot/fplot/fplot_3.cpp : examples/line_plot/fplot/fplot_4.cpp : examples/line_plot/fplot/fplot_5.cpp : examples/line_plot/fplot/fplot_6.cpp : Function Plot 3D examples/line_plot/fplot3/fplot3_1.cpp : examples/line_plot/fplot3/fplot3_2.cpp : examples/line_plot/fplot3/fplot3_3.cpp : examples/line_plot/fplot3/fplot3_4.cpp : examples/line_plot/fplot3/fplot3_5.cpp : Implicit function examples/line_plot/fimplicit/fimplicit_1.cpp : examples/line_plot/fimplicit/fimplicit_2.cpp : examples/line_plot/fimplicit/fimplicit_3.cpp : examples/line_plot/fimplicit/fimplicit_4.cpp : Data Distribution Histogram examples/data_distribution/histogram/histogram_1.cpp : examples/data_distribution/histogram/histogram_2.cpp : examples/data_distribution/histogram/histogram_3.cpp : examples/data_distribution/histogram/histogram_4.cpp : examples/data_distribution/histogram/histogram_5.cpp : examples/data_distribution/histogram/histogram_6.cpp : examples/data_distribution/histogram/histogram_7.cpp : examples/data_distribution/histogram/histogram_8.cpp : examples/data_distribution/histogram/histogram_9.cpp : examples/data_distribution/histogram/histogram_10.cpp : examples/data_distribution/histogram/histogram_11.cpp : examples/data_distribution/histogram/histogram_12.cpp : examples/data_distribution/histogram/histogram_14.cpp : Boxplot examples/data_distribution/boxplot/boxplot_1.cpp : examples/data_distribution/boxplot/boxplot_2.cpp : examples/data_distribution/boxplot/boxplot_3.cpp : Scatter Plot examples/data_distribution/scatter/scatter_1.cpp : examples/data_distribution/scatter/scatter_2.cpp : examples/data_distribution/scatter/scatter_3.cpp : examples/data_distribution/scatter/scatter_4.cpp : examples/data_distribution/scatter/scatter_5.cpp : examples/data_distribution/scatter/scatter_6.cpp : examples/data_distribution/scatter/scatter_7.cpp : examples/data_distribution/scatter/scatter_8.cpp : Scatter Plot 3D examples/data_distribution/scatter3/scatter3_1.cpp : examples/data_distribution/scatter3/scatter3_2.cpp : examples/data_distribution/scatter3/scatter3_3.cpp : examples/data_distribution/scatter3/scatter3_4.cpp : examples/data_distribution/scatter3/scatter3_5.cpp : examples/data_distribution/scatter3/scatter3_6.cpp : Binned Scatter Plots examples/data_distribution/binscatter/binscatter_1.cpp : examples/data_distribution/binscatter/binscatter_2.cpp : examples/data_distribution/binscatter/binscatter_3.cpp : examples/data_distribution/binscatter/binscatter_4.cpp : examples/data_distribution/binscatter/binscatter_5.cpp : examples/data_distribution/binscatter/binscatter_6.cpp : examples/data_distribution/binscatter/binscatter_7.cpp : Plot Matrix examples/data_distribution/plotmatrix/plotmatrix_1.cpp : examples/data_distribution/plotmatrix/plotmatrix_2.cpp : examples/data_distribution/plotmatrix/plotmatrix_3.cpp : examples/data_distribution/plotmatrix/plotmatrix_4.cpp : Parallel Coordinates examples/data_distribution/parallelplot/parallelplot_1.cpp : examples/data_distribution/parallelplot/parallelplot_2.cpp : examples/data_distribution/parallelplot/parallelplot_3.cpp : Pie Chart examples/data_distribution/pie/pie_1.cpp : examples/data_distribution/pie/pie_2.cpp : examples/data_distribution/pie/pie_3.cpp : examples/data_distribution/pie/pie_4.cpp : examples/data_distribution/pie/pie_5.cpp : examples/data_distribution/pie/pie_6.cpp : Heatmap examples/data_distribution/heatmap/heatmap_1.cpp : examples/data_distribution/heatmap/heatmap_2.cpp : examples/data_distribution/heatmap/heatmap_3.cpp : examples/data_distribution/heatmap/heatmap_4.cpp : examples/data_distribution/heatmap/heatmap_5.cpp : examples/data_distribution/heatmap/heatmap_6.cpp : examples/data_distribution/heatmap/heatmap_7.cpp : Word Cloud examples/data_distribution/wordcloud/wordcloud_1.cpp : examples/data_distribution/wordcloud/wordcloud_3.cpp : examples/data_distribution/wordcloud/wordcloud_4.cpp : examples/data_distribution/wordcloud/wordcloud_4.cpp : Discrete Data Bar Plot examples/discrete_data/bar/bar_1.cpp : examples/discrete_data/bar/bar_2.cpp : examples/discrete_data/bar/bar_3.cpp : examples/discrete_data/bar/bar_4.cpp : examples/discrete_data/bar/bar_5.cpp : examples/discrete_data/bar/bar_6.cpp : examples/discrete_data/bar/bar_7.cpp : examples/discrete_data/bar/bar_8.cpp : examples/discrete_data/bar/bar_9.cpp : examples/discrete_data/bar/bar_10.cpp : examples/discrete_data/bar/bar_11.cpp : examples/discrete_data/bar/bar_12.cpp : examples/discrete_data/bar/bar_13.cpp : Pareto Chart examples/discrete_data/pareto/pareto_1.cpp : examples/discrete_data/pareto/pareto_2.cpp : examples/discrete_data/pareto/pareto_3.cpp : examples/discrete_data/pareto/pareto_4.cpp : Stem Plot examples/discrete_data/stem/stem_1.cpp : examples/discrete_data/stem/stem_2.cpp : examples/discrete_data/stem/stem_3.cpp : examples/discrete_data/stem/stem_4.cpp : examples/discrete_data/stem/stem_5.cpp : examples/discrete_data/stem/stem_6.cpp : examples/discrete_data/stem/stem_7.cpp : examples/discrete_data/stem/stem_8.cpp : examples/discrete_data/stem/stem_9.cpp : Stem Plot 3D examples/discrete_data/stem3/stem3_1.cpp : examples/discrete_data/stem3/stem3_2.cpp : examples/discrete_data/stem3/stem3_3.cpp : examples/discrete_data/stem3/stem3_4.cpp : examples/discrete_data/stem3/stem3_5.cpp : examples/discrete_data/stem3/stem3_6.cpp : examples/discrete_data/stem3/stem3_7.cpp : examples/discrete_data/stem3/stem3_8.cpp : examples/discrete_data/stem3/stem3_9.cpp : examples/discrete_data/stem3/stem3_10.cpp : examples/discrete_data/stem3/stem3_11.cpp : Geography Geoplot examples/geography/geoplot/geoplot_1.cpp : examples/geography/geoplot/geoplot_2.cpp : examples/geography/geoplot/geoplot_3.cpp : examples/geography/geoplot/geoplot_4.cpp : examples/geography/geoplot/geoplot_5.cpp : examples/geography/geoplot/geoplot_6.cpp : examples/geography/geoplot/geoplot_7.cpp : Geoscatter Plot examples/geography/geoscatter/geoscatter_1.cpp : examples/geography/geoscatter/geoscatter_2.cpp : Geobubble examples/geography/geobubble/geobubble_1.cpp : examples/geography/geobubble/geobubble_2.cpp : Geodensity Plot examples/geography/geodensityplot/geodensityplot_1.cpp : Polar Plots Polar Line Plot examples/polar_plots/polarplot/polarplot_1.cpp : examples/polar_plots/polarplot/polarplot_2.cpp : examples/polar_plots/polarplot/polarplot_3.cpp : examples/polar_plots/polarplot/polarplot_4.cpp : examples/polar_plots/polarplot/polarplot_5.cpp : examples/polar_plots/polarplot/polarplot_6.cpp : examples/polar_plots/polarplot/polarplot_7.cpp : examples/polar_plots/polarplot/polarplot_8.cpp : Polar Scatter Plot examples/polar_plots/polarscatter/polarscatter_1.cpp : examples/polar_plots/polarscatter/polarscatter_2.cpp : examples/polar_plots/polarscatter/polarscatter_3.cpp : examples/polar_plots/polarscatter/polarscatter_4.cpp : examples/polar_plots/polarscatter/polarscatter_5.cpp : examples/polar_plots/polarscatter/polarscatter_6.cpp : Polar Histogram examples/polar_plots/polarhistogram/polarhistogram_1.cpp : examples/polar_plots/polarhistogram/polarhistogram_2.cpp : examples/polar_plots/polarhistogram/polarhistogram_3.cpp : examples/polar_plots/polarhistogram/polarhistogram_4.cpp : examples/polar_plots/polarhistogram/polarhistogram_5.cpp : Compass examples/polar_plots/compass/compass_1.cpp : examples/polar_plots/compass/compass_2.cpp : Polar Function examples/polar_plots/ezpolar/ezpolar_1.cpp : examples/polar_plots/ezpolar/ezpolar_2.cpp : Contour Plots Contour examples/contour_plots/contour/contour_1.cpp : examples/contour_plots/contour/contour_2.cpp : examples/contour_plots/contour/contour_3.cpp : examples/contour_plots/contour/contour_4.cpp : examples/contour_plots/contour/contour_5.cpp : examples/contour_plots/contour/contour_6.cpp : examples/contour_plots/contour/contour_7.cpp : examples/contour_plots/contour/contour_8.cpp : Filled Contour examples/contour_plots/contourf/contourf_1.cpp : examples/contour_plots/contourf/contourf_2.cpp : examples/contour_plots/contourf/contourf_3.cpp : examples/contour_plots/contourf/contourf_4.cpp : examples/contour_plots/contourf/contourf_5.cpp : examples/contour_plots/contourf/contourf_6.cpp : Function Contour examples/contour_plots/fcontour/fcontour_1.cpp : examples/contour_plots/fcontour/fcontour_2.cpp : examples/contour_plots/fcontour/fcontour_3.cpp : examples/contour_plots/fcontour/fcontour_4.cpp : examples/contour_plots/fcontour/fcontour_5.cpp : examples/contour_plots/fcontour/fcontour_6.cpp : examples/contour_plots/fcontour/fcontour_7.cpp : examples/contour_plots/fcontour/fcontour_8.cpp : examples/contour_plots/fcontour/fcontour_9.cpp : examples/contour_plots/fcontour/fcontour_10.cpp : examples/contour_plots/fcontour/fcontour_11.cpp : Vector Fields Quiver examples/vector_fields/quiver/quiver_1.cpp : examples/vector_fields/quiver/quiver_2.cpp : examples/vector_fields/quiver/quiver_3.cpp : examples/vector_fields/quiver/quiver_4.cpp : examples/vector_fields/quiver/quiver_5.cpp : Quiver 3D examples/vector_fields/quiver3/quiver3_1.cpp : Feather examples/vector_fields/feather/feather_1.cpp : Surfaces Surface examples/surfaces/surf/surf_1.cpp : examples/surfaces/surf/surf_2.cpp : examples/surfaces/surf/surf_3.cpp : examples/surfaces/surf/surf_4.cpp : examples/surfaces/surf/surf_5.cpp : examples/surfaces/surf/surf_6.cpp : Surface with Contour examples/surfaces/surfc/surfc_1.cpp : examples/surfaces/surfc/surfc_2.cpp : examples/surfaces/surfc/surfc_3.cpp : examples/surfaces/surfc/surfc_4.cpp : Mesh examples/surfaces/mesh/mesh_1.cpp : examples/surfaces/mesh/mesh_2.cpp : examples/surfaces/mesh/mesh_3.cpp : examples/surfaces/mesh/mesh_4.cpp : Mesh with Contour examples/surfaces/meshc/meshc_1.cpp : examples/surfaces/meshc/meshc_2.cpp : examples/surfaces/meshc/meshc_3.cpp : Mesh with Curtain examples/surfaces/meshz/meshz_1.cpp : examples/surfaces/meshz/meshz_2.cpp : examples/surfaces/meshz/meshz_3.cpp : Function Surface examples/surfaces/fsurf/fsurf_1.cpp : examples/surfaces/fsurf/fsurf_2.cpp : examples/surfaces/fsurf/fsurf_3.cpp : examples/surfaces/fsurf/fsurf_4.cpp : examples/surfaces/fsurf/fsurf_5.cpp : examples/surfaces/fsurf/fsurf_6.cpp : examples/surfaces/fsurf/fsurf_7.cpp : examples/surfaces/fsurf/fsurf_8.cpp : Function Mesh examples/surfaces/fmesh/fmesh_1.cpp : examples/surfaces/fmesh/fmesh_2.cpp : examples/surfaces/fmesh/fmesh_3.cpp : examples/surfaces/fmesh/fmesh_4.cpp : Waterfall examples/surfaces/waterfall/waterfall_1.cpp : examples/surfaces/waterfall/waterfall_2.cpp : examples/surfaces/waterfall/waterfall_3.cpp : Fence examples/surfaces/fence/fence_1.cpp : examples/surfaces/fence/fence_2.cpp : examples/surfaces/fence/fence_3.cpp : Ribbon examples/surfaces/ribbon/ribbon_1.cpp : examples/surfaces/ribbon/ribbon_2.cpp : examples/surfaces/ribbon/ribbon_3.cpp : examples/surfaces/ribbon/ribbon_4.cpp : Graphs Undirected Graph examples/graphs/graph/graph_1.cpp : examples/graphs/graph/graph_2.cpp : examples/graphs/graph/graph_3.cpp : examples/graphs/graph/graph_4.cpp : examples/graphs/graph/graph_5.cpp : examples/graphs/graph/graph_6.cpp : Directed Graph examples/graphs/digraph/digraph_1.cpp : examples/graphs/digraph/digraph_2.cpp : examples/graphs/digraph/digraph_3.cpp : Images Image Show examples/images/imshow/imshow_1.cpp : examples/images/imshow/imshow_2.cpp : examples/images/imshow/imshow_3.cpp : examples/images/imshow/imshow_4.cpp : examples/images/imshow/imshow_5.cpp : examples/images/imshow/imshow_6.cpp : examples/images/imshow/imshow_7.cpp : examples/images/imshow/imshow_8.cpp : examples/images/imshow/imshow_9.cpp : examples/images/imshow/imshow_10.cpp : examples/images/imshow/imshow_11.cpp : Image Matrix examples/images/image/image_1.cpp : examples/images/image/image_2.cpp : examples/images/image/image_3.cpp : examples/images/image/image_4.cpp : examples/images/image/image_5.cpp : Scaled Image examples/images/imagesc/imagesc_1.cpp : examples/images/imagesc/imagesc_2.cpp : examples/images/imagesc/imagesc_3.cpp : examples/images/imagesc/imagesc_4.cpp : Annotations Text examples/annotations/text/text_1.cpp : examples/annotations/text/text_2.cpp : examples/annotations/text/text_3.cpp : examples/annotations/text/text_4.cpp : examples/annotations/text/text_5.cpp : examples/annotations/text/text_6.cpp : examples/annotations/text/text_7.cpp : examples/annotations/text/text_8.cpp : Text with Arrow examples/annotations/textarrow/textarrow_1.cpp : examples/annotations/textarrow/textarrow_2.cpp : Rectangle examples/annotations/rectangle/rectangle_1.cpp : examples/annotations/rectangle/rectangle_2.cpp : examples/annotations/rectangle/rectangle_3.cpp : examples/annotations/rectangle/rectangle_4.cpp : examples/annotations/rectangle/rectangle_5.cpp : Filled Polygon examples/annotations/fill/fill_1.cpp : Ellipse examples/annotations/ellipse/ellipse_1.cpp : Textbox examples/annotations/textbox/textbox_1.cpp : Arrow examples/annotations/arrow/arrow_1.cpp : examples/annotations/arrow/arrow_2.cpp : Line examples/annotations/line/line_1.cpp : Appearance Labels Title examples/appearance/labels/title/title_1.cpp : examples/appearance/labels/title/title_2.cpp : examples/appearance/labels/title/title_3.cpp : examples/appearance/labels/title/title_4.cpp : examples/appearance/labels/title/title_5.cpp : examples/appearance/labels/title/title_6.cpp : examples/appearance/labels/title/title_7.cpp : examples/appearance/labels/title/title_8.cpp : Subplot Title examples/appearance/labels/sgtitle/sgtitle_1.cpp : examples/appearance/labels/sgtitle/sgtitle_2.cpp : X Label examples/appearance/labels/xlabel/xlabel_1.cpp : examples/appearance/labels/xlabel/xlabel_2.cpp : examples/appearance/labels/xlabel/xlabel_3.cpp : examples/appearance/labels/xlabel/xlabel_4.cpp : examples/appearance/labels/xlabel/xlabel_5.cpp : examples/appearance/labels/xlabel/xlabel_6.cpp : examples/appearance/labels/xlabel/xlabel_7.cpp : examples/appearance/labels/xlabel/xlabel_8.cpp : Y Label examples/appearance/labels/ylabel/ylabel_1.cpp : examples/appearance/labels/ylabel/ylabel_2.cpp : examples/appearance/labels/ylabel/ylabel_3.cpp : examples/appearance/labels/ylabel/ylabel_4.cpp : examples/appearance/labels/ylabel/ylabel_5.cpp : examples/appearance/labels/ylabel/ylabel_6.cpp : examples/appearance/labels/ylabel/ylabel_7.cpp : examples/appearance/labels/ylabel/ylabel_8.cpp : Z Label examples/appearance/labels/zlabel/zlabel_1.cpp : examples/appearance/labels/zlabel/zlabel_2.cpp : examples/appearance/labels/zlabel/zlabel_3.cpp : Legend examples/appearance/labels/legend/legend_1.cpp : examples/appearance/labels/legend/legend_2.cpp : examples/appearance/labels/legend/legend_3.cpp : examples/appearance/labels/legend/legend_4.cpp : examples/appearance/labels/legend/legend_5.cpp : examples/appearance/labels/legend/legend_6.cpp : examples/appearance/labels/legend/legend_7.cpp : examples/appearance/labels/legend/legend_8.cpp : examples/appearance/labels/legend/legend_9.cpp : Axis X Limits examples/appearance/axis/xlim/xlim_1.cpp : examples/appearance/axis/xlim/xlim_2.cpp : examples/appearance/axis/xlim/xlim_3.cpp : examples/appearance/axis/xlim/xlim_4.cpp : examples/appearance/axis/xlim/xlim_5.cpp : examples/appearance/axis/xlim/xlim_6.cpp : Y Limits examples/appearance/axis/ylim/ylim_1.cpp : examples/appearance/axis/ylim/ylim_2.cpp : examples/appearance/axis/ylim/ylim_3.cpp : examples/appearance/axis/ylim/ylim_4.cpp : examples/appearance/axis/ylim/ylim_5.cpp : examples/appearance/axis/ylim/ylim_6.cpp : Z Limits examples/appearance/axis/zlim/zlim_1.cpp : examples/appearance/axis/zlim/zlim_2.cpp : examples/appearance/axis/zlim/zlim_3.cpp : examples/appearance/axis/zlim/zlim_4.cpp : examples/appearance/axis/zlim/zlim_5.cpp : examples/appearance/axis/zlim/zlim_6.cpp : Adjust Axis examples/appearance/axis/axis/axis_1.cpp : examples/appearance/axis/axis/axis_2.cpp : examples/appearance/axis/axis/axis_3.cpp : examples/appearance/axis/axis/axis_4.cpp : examples/appearance/axis/axis/axis_5.cpp : examples/appearance/axis/axis/axis_6.cpp : examples/appearance/axis/axis/axis_7.cpp : examples/appearance/axis/axis/axis_8.cpp : Box examples/appearance/axis/box/box_1.cpp : examples/appearance/axis/box/box_2.cpp : examples/appearance/axis/box/box_3.cpp : Grid Grid examples/appearance/grid/grid/grid_1.cpp : examples/appearance/grid/grid/grid_2.cpp : examples/appearance/grid/grid/grid_3.cpp : examples/appearance/grid/grid/grid_4.cpp : X Ticks examples/appearance/grid/xticks/xticks_1.cpp : examples/appearance/grid/xticks/xticks_2.cpp : examples/appearance/grid/xticks/xticks_3.cpp : examples/appearance/grid/xticks/xticks_4.cpp : examples/appearance/grid/xticks/xticks_5.cpp : examples/appearance/grid/xticks/xticks_6.cpp : examples/appearance/grid/xticks/xticks_7.cpp : examples/appearance/grid/xticks/xticks_8.cpp : Y Ticks examples/appearance/grid/yticks/yticks_1.cpp : examples/appearance/grid/yticks/yticks_2.cpp : examples/appearance/grid/yticks/yticks_3.cpp : examples/appearance/grid/yticks/yticks_4.cpp : examples/appearance/grid/yticks/yticks_5.cpp : examples/appearance/grid/yticks/yticks_6.cpp : examples/appearance/grid/yticks/yticks_7.cpp : examples/appearance/grid/yticks/yticks_8.cpp : Z Ticks examples/appearance/grid/zticks/zticks_1.cpp : examples/appearance/grid/zticks/zticks_2.cpp : examples/appearance/grid/zticks/zticks_3.cpp : examples/appearance/grid/zticks/zticks_4.cpp : examples/appearance/grid/zticks/zticks_5.cpp : examples/appearance/grid/zticks/zticks_6.cpp : X Tick Labels examples/appearance/grid/xticklabels/xticklabels_1.cpp : examples/appearance/grid/xticklabels/xticklabels_2.cpp : examples/appearance/grid/xticklabels/xticklabels_3.cpp : examples/appearance/grid/xticklabels/xticklabels_4.cpp : Y Tick Labels examples/appearance/grid/yticklabels/yticklabels_1.cpp : examples/appearance/grid/yticklabels/yticklabels_2.cpp : examples/appearance/grid/yticklabels/yticklabels_3.cpp : examples/appearance/grid/yticklabels/yticklabels_4.cpp : X Tick Format examples/appearance/grid/xtickformat/xtickformat_1.cpp : examples/appearance/grid/xtickformat/xtickformat_2.cpp : examples/appearance/grid/xtickformat/xtickformat_3.cpp : examples/appearance/grid/xtickformat/xtickformat_4.cpp : examples/appearance/grid/xtickformat/xtickformat_5.cpp : Y Tick Format examples/appearance/grid/ytickformat/ytickformat_1.cpp : examples/appearance/grid/ytickformat/ytickformat_2.cpp : examples/appearance/grid/ytickformat/ytickformat_3.cpp : examples/appearance/grid/ytickformat/ytickformat_4.cpp : examples/appearance/grid/ytickformat/ytickformat_5.cpp : Z Tick Format examples/appearance/grid/ztickformat/ztickformat_1.cpp : examples/appearance/grid/ztickformat/ztickformat_2.cpp : examples/appearance/grid/ztickformat/ztickformat_3.cpp : examples/appearance/grid/ztickformat/ztickformat_4.cpp : examples/appearance/grid/ztickformat/ztickformat_5.cpp : X Tick Angle examples/appearance/grid/xtickangle/xtickangle_1.cpp : examples/appearance/grid/xtickangle/xtickangle_2.cpp : examples/appearance/grid/xtickangle/xtickangle_3.cpp : Y Tick Angle examples/appearance/grid/ytickangle/ytickangle_1.cpp : examples/appearance/grid/ytickangle/ytickangle_2.cpp : examples/appearance/grid/ytickangle/ytickangle_3.cpp : Multiplot Hold examples/appearance/multiplot/hold/hold_1.cpp : examples/appearance/multiplot/hold/hold_2.cpp : examples/appearance/multiplot/hold/hold_3.cpp : examples/appearance/multiplot/hold/hold_4.cpp : YY-axis examples/appearance/multiplot/yyaxis/yyaxis_1.cpp : examples/appearance/multiplot/yyaxis/yyaxis_2.cpp : examples/appearance/multiplot/yyaxis/yyaxis_3.cpp : examples/appearance/multiplot/yyaxis/yyaxis_4.cpp : examples/appearance/multiplot/yyaxis/yyaxis_5.cpp : examples/appearance/multiplot/yyaxis/yyaxis_6.cpp : examples/appearance/multiplot/yyaxis/yyaxis_7.cpp : Color Order examples/appearance/multiplot/colororder/colororder_1.cpp : examples/appearance/multiplot/colororder/colororder_2.cpp : examples/appearance/multiplot/colororder/colororder_3.cpp : examples/appearance/multiplot/colororder/colororder_4.cpp : examples/appearance/multiplot/colororder/colororder_5.cpp : examples/appearance/multiplot/colororder/colororder_6.cpp : examples/appearance/multiplot/colororder/colororder_7.cpp : Subplots examples/appearance/multiplot/subplot/subplot_1.cpp : examples/appearance/multiplot/subplot/subplot_2.cpp : examples/appearance/multiplot/subplot/subplot_3.cpp : examples/appearance/multiplot/subplot/subplot_4.cpp : examples/appearance/multiplot/subplot/subplot_5.cpp : examples/appearance/multiplot/subplot/subplot_6.cpp : examples/appearance/multiplot/subplot/subplot_7.cpp : examples/appearance/multiplot/subplot/subplot_8.cpp : examples/appearance/multiplot/subplot/subplot_9.cpp : examples/appearance/multiplot/subplot/subplot_10.cpp : examples/appearance/multiplot/subplot/subplot_11.cpp : examples/appearance/multiplot/subplot/subplot_12.cpp : examples/appearance/multiplot/subplot/subplot_13.cpp : Tiled Layout examples/appearance/multiplot/tiledlayout/tiledlayout_1.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_2.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_3.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_4.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_5.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_6.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_7.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_8.cpp : Colormaps Colormap examples/appearance/colormaps/colormap/colormap_1.cpp : examples/appearance/colormaps/colormap/colormap_2.cpp : examples/appearance/colormaps/colormap/colormap_3.cpp : examples/appearance/colormaps/colormap/colormap_4.cpp : examples/appearance/colormaps/colormap/colormap_5.cpp : examples/appearance/colormaps/colormap/colormap_6.cpp : examples/appearance/colormaps/colormap/colormap_7.cpp : examples/appearance/colormaps/colormap/colormap_8.cpp : examples/appearance/colormaps/colormap/colormap_9.cpp : Color Bar examples/appearance/colormaps/colorbar/colorbar_1.cpp : examples/appearance/colormaps/colorbar/colorbar_2.cpp : examples/appearance/colormaps/colorbar/colorbar_3.cpp : examples/appearance/colormaps/colorbar/colorbar_4.cpp : examples/appearance/colormaps/colorbar/colorbar_5.cpp : examples/appearance/colormaps/colorbar/colorbar_6.cpp : examples/appearance/colormaps/colorbar/colorbar_7.cpp : RGB Plot examples/appearance/colormaps/rgbplot/rgbplot_1.cpp : examples/appearance/colormaps/rgbplot/rgbplot_2.cpp : Camera View examples/appearance/camera/view/view_1.cpp : examples/appearance/camera/view/view_2.cpp : examples/appearance/camera/view/view_3.cpp : examples/appearance/camera/view/view_4.cpp : examples/appearance/camera/view/view_5.cpp : examples/appearance/camera/view/view_6.cpp : Lighting examples/appearance/camera/lighting/lighting_1.cpp : examples/appearance/camera/lighting/lighting_2.cpp : examples/appearance/camera/lighting/lighting_3.cpp : examples/appearance/camera/lighting/lighting_4.cpp : examples/appearance/camera/lighting/lighting_5.cpp : examples/appearance/camera/lighting/lighting_6.cpp : Figure Object examples/appearance/figure/figure_1.cpp : examples/appearance/figure/figure_2.cpp : examples/appearance/figure/figure_3.cpp : Line Specs examples/appearance/line_spec/line_spec_1.cpp : Axes Object examples/appearance/axes/axes_1.cpp : examples/appearance/axes/axes_2.cpp : examples/appearance/axes/axes_3.cpp : examples/appearance/axes/axes_4.cpp : Clear Axes examples/appearance/cla/cla_1.cpp : examples/appearance/cla/cla_2.cpp : examples/appearance/cla/cla_3.cpp : Exporting Saving examples/exporting/save/save_1.cpp : examples/exporting/save/save_2.cpp : examples/exporting/save/save_3.cpp : examples/exporting/save/save_4.cpp : examples/exporting/save/save_5.cpp : examples/exporting/save/save_6.cpp : examples/exporting/save/save_7.cpp : examples/exporting/save/save_8.cpp :","title":"Complete Gallery"},{"location":"COMPLETE_GALLERY/#complete-gallery","text":"","title":"Complete Gallery"},{"location":"COMPLETE_GALLERY/#line-plots","text":"","title":"Line Plots"},{"location":"COMPLETE_GALLERY/#line-plot","text":"examples/line_plot/plot/plot_1.cpp : examples/line_plot/plot/plot_2.cpp : examples/line_plot/plot/plot_3.cpp : examples/line_plot/plot/plot_4.cpp : examples/line_plot/plot/plot_5.cpp : examples/line_plot/plot/plot_6.cpp : examples/line_plot/plot/plot_7.cpp : examples/line_plot/plot/plot_8.cpp : examples/line_plot/plot/plot_9.cpp : examples/line_plot/plot/plot_10.cpp : examples/line_plot/plot/plot_11.cpp : examples/line_plot/plot/plot_12.cpp :","title":"Line Plot"},{"location":"COMPLETE_GALLERY/#line-plot-3d","text":"examples/line_plot/plot3/plot3_1.cpp : examples/line_plot/plot3/plot3_2.cpp : examples/line_plot/plot3/plot3_3.cpp : examples/line_plot/plot3/plot3_4.cpp : examples/line_plot/plot3/plot3_5.cpp : examples/line_plot/plot3/plot3_6.cpp : examples/line_plot/plot3/plot3_7.cpp : examples/line_plot/plot3/plot3_8.cpp : examples/line_plot/plot3/plot3_9.cpp : examples/line_plot/plot3/plot3_10.cpp :","title":"Line Plot 3D"},{"location":"COMPLETE_GALLERY/#stairs","text":"examples/line_plot/stairs/stairs_1.cpp : examples/line_plot/stairs/stairs_2.cpp : examples/line_plot/stairs/stairs_3.cpp : examples/line_plot/stairs/stairs_4.cpp : examples/line_plot/stairs/stairs_5.cpp : examples/line_plot/stairs/stairs_6.cpp : examples/line_plot/stairs/stairs_7.cpp : examples/line_plot/stairs/stairs_8.cpp : examples/line_plot/stairs/stairs_9.cpp : examples/line_plot/stairs/stairs_10.cpp :","title":"Stairs"},{"location":"COMPLETE_GALLERY/#error-bars","text":"examples/line_plot/errorbar/errorbar_1.cpp : examples/line_plot/errorbar/errorbar_2.cpp : examples/line_plot/errorbar/errorbar_3.cpp : examples/line_plot/errorbar/errorbar_4.cpp : examples/line_plot/errorbar/errorbar_5.cpp : examples/line_plot/errorbar/errorbar_6.cpp : examples/line_plot/errorbar/errorbar_7.cpp : examples/line_plot/errorbar/errorbar_8.cpp : examples/line_plot/errorbar/errorbar_9.cpp : examples/line_plot/errorbar/errorbar_10.cpp :","title":"Error Bars"},{"location":"COMPLETE_GALLERY/#area","text":"examples/line_plot/area/area_1.cpp : examples/line_plot/area/area_2.cpp : examples/line_plot/area/area_3.cpp : examples/line_plot/area/area_4.cpp :","title":"Area"},{"location":"COMPLETE_GALLERY/#loglog-plot","text":"examples/line_plot/loglog/loglog_1.cpp : examples/line_plot/loglog/loglog_2.cpp : examples/line_plot/loglog/loglog_3.cpp : examples/line_plot/loglog/loglog_4.cpp : examples/line_plot/loglog/loglog_5.cpp : examples/line_plot/loglog/loglog_6.cpp : examples/line_plot/loglog/loglog_7.cpp : examples/line_plot/loglog/loglog_8.cpp : examples/line_plot/loglog/loglog_9.cpp :","title":"Loglog Plot"},{"location":"COMPLETE_GALLERY/#semilogx-plot","text":"examples/line_plot/semilogx/semilogx_1.cpp :","title":"Semilogx Plot"},{"location":"COMPLETE_GALLERY/#semilogy-plot","text":"examples/line_plot/semilogy/semilogy_1.cpp :","title":"Semilogy Plot"},{"location":"COMPLETE_GALLERY/#function-plot","text":"examples/line_plot/fplot/fplot_1.cpp : examples/line_plot/fplot/fplot_2.cpp : examples/line_plot/fplot/fplot_3.cpp : examples/line_plot/fplot/fplot_4.cpp : examples/line_plot/fplot/fplot_5.cpp : examples/line_plot/fplot/fplot_6.cpp :","title":"Function Plot"},{"location":"COMPLETE_GALLERY/#function-plot-3d","text":"examples/line_plot/fplot3/fplot3_1.cpp : examples/line_plot/fplot3/fplot3_2.cpp : examples/line_plot/fplot3/fplot3_3.cpp : examples/line_plot/fplot3/fplot3_4.cpp : examples/line_plot/fplot3/fplot3_5.cpp :","title":"Function Plot 3D"},{"location":"COMPLETE_GALLERY/#implicit-function","text":"examples/line_plot/fimplicit/fimplicit_1.cpp : examples/line_plot/fimplicit/fimplicit_2.cpp : examples/line_plot/fimplicit/fimplicit_3.cpp : examples/line_plot/fimplicit/fimplicit_4.cpp :","title":"Implicit function"},{"location":"COMPLETE_GALLERY/#data-distribution","text":"","title":"Data Distribution"},{"location":"COMPLETE_GALLERY/#histogram","text":"examples/data_distribution/histogram/histogram_1.cpp : examples/data_distribution/histogram/histogram_2.cpp : examples/data_distribution/histogram/histogram_3.cpp : examples/data_distribution/histogram/histogram_4.cpp : examples/data_distribution/histogram/histogram_5.cpp : examples/data_distribution/histogram/histogram_6.cpp : examples/data_distribution/histogram/histogram_7.cpp : examples/data_distribution/histogram/histogram_8.cpp : examples/data_distribution/histogram/histogram_9.cpp : examples/data_distribution/histogram/histogram_10.cpp : examples/data_distribution/histogram/histogram_11.cpp : examples/data_distribution/histogram/histogram_12.cpp : examples/data_distribution/histogram/histogram_14.cpp :","title":"Histogram"},{"location":"COMPLETE_GALLERY/#boxplot","text":"examples/data_distribution/boxplot/boxplot_1.cpp : examples/data_distribution/boxplot/boxplot_2.cpp : examples/data_distribution/boxplot/boxplot_3.cpp :","title":"Boxplot"},{"location":"COMPLETE_GALLERY/#scatter-plot","text":"examples/data_distribution/scatter/scatter_1.cpp : examples/data_distribution/scatter/scatter_2.cpp : examples/data_distribution/scatter/scatter_3.cpp : examples/data_distribution/scatter/scatter_4.cpp : examples/data_distribution/scatter/scatter_5.cpp : examples/data_distribution/scatter/scatter_6.cpp : examples/data_distribution/scatter/scatter_7.cpp : examples/data_distribution/scatter/scatter_8.cpp :","title":"Scatter Plot"},{"location":"COMPLETE_GALLERY/#scatter-plot-3d","text":"examples/data_distribution/scatter3/scatter3_1.cpp : examples/data_distribution/scatter3/scatter3_2.cpp : examples/data_distribution/scatter3/scatter3_3.cpp : examples/data_distribution/scatter3/scatter3_4.cpp : examples/data_distribution/scatter3/scatter3_5.cpp : examples/data_distribution/scatter3/scatter3_6.cpp :","title":"Scatter Plot 3D"},{"location":"COMPLETE_GALLERY/#binned-scatter-plots","text":"examples/data_distribution/binscatter/binscatter_1.cpp : examples/data_distribution/binscatter/binscatter_2.cpp : examples/data_distribution/binscatter/binscatter_3.cpp : examples/data_distribution/binscatter/binscatter_4.cpp : examples/data_distribution/binscatter/binscatter_5.cpp : examples/data_distribution/binscatter/binscatter_6.cpp : examples/data_distribution/binscatter/binscatter_7.cpp :","title":"Binned Scatter Plots"},{"location":"COMPLETE_GALLERY/#plot-matrix","text":"examples/data_distribution/plotmatrix/plotmatrix_1.cpp : examples/data_distribution/plotmatrix/plotmatrix_2.cpp : examples/data_distribution/plotmatrix/plotmatrix_3.cpp : examples/data_distribution/plotmatrix/plotmatrix_4.cpp :","title":"Plot Matrix"},{"location":"COMPLETE_GALLERY/#parallel-coordinates","text":"examples/data_distribution/parallelplot/parallelplot_1.cpp : examples/data_distribution/parallelplot/parallelplot_2.cpp : examples/data_distribution/parallelplot/parallelplot_3.cpp :","title":"Parallel Coordinates"},{"location":"COMPLETE_GALLERY/#pie-chart","text":"examples/data_distribution/pie/pie_1.cpp : examples/data_distribution/pie/pie_2.cpp : examples/data_distribution/pie/pie_3.cpp : examples/data_distribution/pie/pie_4.cpp : examples/data_distribution/pie/pie_5.cpp : examples/data_distribution/pie/pie_6.cpp :","title":"Pie Chart"},{"location":"COMPLETE_GALLERY/#heatmap","text":"examples/data_distribution/heatmap/heatmap_1.cpp : examples/data_distribution/heatmap/heatmap_2.cpp : examples/data_distribution/heatmap/heatmap_3.cpp : examples/data_distribution/heatmap/heatmap_4.cpp : examples/data_distribution/heatmap/heatmap_5.cpp : examples/data_distribution/heatmap/heatmap_6.cpp : examples/data_distribution/heatmap/heatmap_7.cpp :","title":"Heatmap"},{"location":"COMPLETE_GALLERY/#word-cloud","text":"examples/data_distribution/wordcloud/wordcloud_1.cpp : examples/data_distribution/wordcloud/wordcloud_3.cpp : examples/data_distribution/wordcloud/wordcloud_4.cpp : examples/data_distribution/wordcloud/wordcloud_4.cpp :","title":"Word Cloud"},{"location":"COMPLETE_GALLERY/#discrete-data","text":"","title":"Discrete Data"},{"location":"COMPLETE_GALLERY/#bar-plot","text":"examples/discrete_data/bar/bar_1.cpp : examples/discrete_data/bar/bar_2.cpp : examples/discrete_data/bar/bar_3.cpp : examples/discrete_data/bar/bar_4.cpp : examples/discrete_data/bar/bar_5.cpp : examples/discrete_data/bar/bar_6.cpp : examples/discrete_data/bar/bar_7.cpp : examples/discrete_data/bar/bar_8.cpp : examples/discrete_data/bar/bar_9.cpp : examples/discrete_data/bar/bar_10.cpp : examples/discrete_data/bar/bar_11.cpp : examples/discrete_data/bar/bar_12.cpp : examples/discrete_data/bar/bar_13.cpp :","title":"Bar Plot"},{"location":"COMPLETE_GALLERY/#pareto-chart","text":"examples/discrete_data/pareto/pareto_1.cpp : examples/discrete_data/pareto/pareto_2.cpp : examples/discrete_data/pareto/pareto_3.cpp : examples/discrete_data/pareto/pareto_4.cpp :","title":"Pareto Chart"},{"location":"COMPLETE_GALLERY/#stem-plot","text":"examples/discrete_data/stem/stem_1.cpp : examples/discrete_data/stem/stem_2.cpp : examples/discrete_data/stem/stem_3.cpp : examples/discrete_data/stem/stem_4.cpp : examples/discrete_data/stem/stem_5.cpp : examples/discrete_data/stem/stem_6.cpp : examples/discrete_data/stem/stem_7.cpp : examples/discrete_data/stem/stem_8.cpp : examples/discrete_data/stem/stem_9.cpp :","title":"Stem Plot"},{"location":"COMPLETE_GALLERY/#stem-plot-3d","text":"examples/discrete_data/stem3/stem3_1.cpp : examples/discrete_data/stem3/stem3_2.cpp : examples/discrete_data/stem3/stem3_3.cpp : examples/discrete_data/stem3/stem3_4.cpp : examples/discrete_data/stem3/stem3_5.cpp : examples/discrete_data/stem3/stem3_6.cpp : examples/discrete_data/stem3/stem3_7.cpp : examples/discrete_data/stem3/stem3_8.cpp : examples/discrete_data/stem3/stem3_9.cpp : examples/discrete_data/stem3/stem3_10.cpp : examples/discrete_data/stem3/stem3_11.cpp :","title":"Stem Plot 3D"},{"location":"COMPLETE_GALLERY/#geography","text":"","title":"Geography"},{"location":"COMPLETE_GALLERY/#geoplot","text":"examples/geography/geoplot/geoplot_1.cpp : examples/geography/geoplot/geoplot_2.cpp : examples/geography/geoplot/geoplot_3.cpp : examples/geography/geoplot/geoplot_4.cpp : examples/geography/geoplot/geoplot_5.cpp : examples/geography/geoplot/geoplot_6.cpp : examples/geography/geoplot/geoplot_7.cpp :","title":"Geoplot"},{"location":"COMPLETE_GALLERY/#geoscatter-plot","text":"examples/geography/geoscatter/geoscatter_1.cpp : examples/geography/geoscatter/geoscatter_2.cpp :","title":"Geoscatter Plot"},{"location":"COMPLETE_GALLERY/#geobubble","text":"examples/geography/geobubble/geobubble_1.cpp : examples/geography/geobubble/geobubble_2.cpp :","title":"Geobubble"},{"location":"COMPLETE_GALLERY/#geodensity-plot","text":"examples/geography/geodensityplot/geodensityplot_1.cpp :","title":"Geodensity Plot"},{"location":"COMPLETE_GALLERY/#polar-plots","text":"","title":"Polar Plots"},{"location":"COMPLETE_GALLERY/#polar-line-plot","text":"examples/polar_plots/polarplot/polarplot_1.cpp : examples/polar_plots/polarplot/polarplot_2.cpp : examples/polar_plots/polarplot/polarplot_3.cpp : examples/polar_plots/polarplot/polarplot_4.cpp : examples/polar_plots/polarplot/polarplot_5.cpp : examples/polar_plots/polarplot/polarplot_6.cpp : examples/polar_plots/polarplot/polarplot_7.cpp : examples/polar_plots/polarplot/polarplot_8.cpp :","title":"Polar Line Plot"},{"location":"COMPLETE_GALLERY/#polar-scatter-plot","text":"examples/polar_plots/polarscatter/polarscatter_1.cpp : examples/polar_plots/polarscatter/polarscatter_2.cpp : examples/polar_plots/polarscatter/polarscatter_3.cpp : examples/polar_plots/polarscatter/polarscatter_4.cpp : examples/polar_plots/polarscatter/polarscatter_5.cpp : examples/polar_plots/polarscatter/polarscatter_6.cpp :","title":"Polar Scatter Plot"},{"location":"COMPLETE_GALLERY/#polar-histogram","text":"examples/polar_plots/polarhistogram/polarhistogram_1.cpp : examples/polar_plots/polarhistogram/polarhistogram_2.cpp : examples/polar_plots/polarhistogram/polarhistogram_3.cpp : examples/polar_plots/polarhistogram/polarhistogram_4.cpp : examples/polar_plots/polarhistogram/polarhistogram_5.cpp :","title":"Polar Histogram"},{"location":"COMPLETE_GALLERY/#compass","text":"examples/polar_plots/compass/compass_1.cpp : examples/polar_plots/compass/compass_2.cpp :","title":"Compass"},{"location":"COMPLETE_GALLERY/#polar-function","text":"examples/polar_plots/ezpolar/ezpolar_1.cpp : examples/polar_plots/ezpolar/ezpolar_2.cpp :","title":"Polar Function"},{"location":"COMPLETE_GALLERY/#contour-plots","text":"","title":"Contour Plots"},{"location":"COMPLETE_GALLERY/#contour","text":"examples/contour_plots/contour/contour_1.cpp : examples/contour_plots/contour/contour_2.cpp : examples/contour_plots/contour/contour_3.cpp : examples/contour_plots/contour/contour_4.cpp : examples/contour_plots/contour/contour_5.cpp : examples/contour_plots/contour/contour_6.cpp : examples/contour_plots/contour/contour_7.cpp : examples/contour_plots/contour/contour_8.cpp :","title":"Contour"},{"location":"COMPLETE_GALLERY/#filled-contour","text":"examples/contour_plots/contourf/contourf_1.cpp : examples/contour_plots/contourf/contourf_2.cpp : examples/contour_plots/contourf/contourf_3.cpp : examples/contour_plots/contourf/contourf_4.cpp : examples/contour_plots/contourf/contourf_5.cpp : examples/contour_plots/contourf/contourf_6.cpp :","title":"Filled Contour"},{"location":"COMPLETE_GALLERY/#function-contour","text":"examples/contour_plots/fcontour/fcontour_1.cpp : examples/contour_plots/fcontour/fcontour_2.cpp : examples/contour_plots/fcontour/fcontour_3.cpp : examples/contour_plots/fcontour/fcontour_4.cpp : examples/contour_plots/fcontour/fcontour_5.cpp : examples/contour_plots/fcontour/fcontour_6.cpp : examples/contour_plots/fcontour/fcontour_7.cpp : examples/contour_plots/fcontour/fcontour_8.cpp : examples/contour_plots/fcontour/fcontour_9.cpp : examples/contour_plots/fcontour/fcontour_10.cpp : examples/contour_plots/fcontour/fcontour_11.cpp :","title":"Function Contour"},{"location":"COMPLETE_GALLERY/#vector-fields","text":"","title":"Vector Fields"},{"location":"COMPLETE_GALLERY/#quiver","text":"examples/vector_fields/quiver/quiver_1.cpp : examples/vector_fields/quiver/quiver_2.cpp : examples/vector_fields/quiver/quiver_3.cpp : examples/vector_fields/quiver/quiver_4.cpp : examples/vector_fields/quiver/quiver_5.cpp :","title":"Quiver"},{"location":"COMPLETE_GALLERY/#quiver-3d","text":"examples/vector_fields/quiver3/quiver3_1.cpp :","title":"Quiver 3D"},{"location":"COMPLETE_GALLERY/#feather","text":"examples/vector_fields/feather/feather_1.cpp :","title":"Feather"},{"location":"COMPLETE_GALLERY/#surfaces","text":"","title":"Surfaces"},{"location":"COMPLETE_GALLERY/#surface","text":"examples/surfaces/surf/surf_1.cpp : examples/surfaces/surf/surf_2.cpp : examples/surfaces/surf/surf_3.cpp : examples/surfaces/surf/surf_4.cpp : examples/surfaces/surf/surf_5.cpp : examples/surfaces/surf/surf_6.cpp :","title":"Surface"},{"location":"COMPLETE_GALLERY/#surface-with-contour","text":"examples/surfaces/surfc/surfc_1.cpp : examples/surfaces/surfc/surfc_2.cpp : examples/surfaces/surfc/surfc_3.cpp : examples/surfaces/surfc/surfc_4.cpp :","title":"Surface with Contour"},{"location":"COMPLETE_GALLERY/#mesh","text":"examples/surfaces/mesh/mesh_1.cpp : examples/surfaces/mesh/mesh_2.cpp : examples/surfaces/mesh/mesh_3.cpp : examples/surfaces/mesh/mesh_4.cpp :","title":"Mesh"},{"location":"COMPLETE_GALLERY/#mesh-with-contour","text":"examples/surfaces/meshc/meshc_1.cpp : examples/surfaces/meshc/meshc_2.cpp : examples/surfaces/meshc/meshc_3.cpp :","title":"Mesh with Contour"},{"location":"COMPLETE_GALLERY/#mesh-with-curtain","text":"examples/surfaces/meshz/meshz_1.cpp : examples/surfaces/meshz/meshz_2.cpp : examples/surfaces/meshz/meshz_3.cpp :","title":"Mesh with Curtain"},{"location":"COMPLETE_GALLERY/#function-surface","text":"examples/surfaces/fsurf/fsurf_1.cpp : examples/surfaces/fsurf/fsurf_2.cpp : examples/surfaces/fsurf/fsurf_3.cpp : examples/surfaces/fsurf/fsurf_4.cpp : examples/surfaces/fsurf/fsurf_5.cpp : examples/surfaces/fsurf/fsurf_6.cpp : examples/surfaces/fsurf/fsurf_7.cpp : examples/surfaces/fsurf/fsurf_8.cpp :","title":"Function Surface"},{"location":"COMPLETE_GALLERY/#function-mesh","text":"examples/surfaces/fmesh/fmesh_1.cpp : examples/surfaces/fmesh/fmesh_2.cpp : examples/surfaces/fmesh/fmesh_3.cpp : examples/surfaces/fmesh/fmesh_4.cpp :","title":"Function Mesh"},{"location":"COMPLETE_GALLERY/#waterfall","text":"examples/surfaces/waterfall/waterfall_1.cpp : examples/surfaces/waterfall/waterfall_2.cpp : examples/surfaces/waterfall/waterfall_3.cpp :","title":"Waterfall"},{"location":"COMPLETE_GALLERY/#fence","text":"examples/surfaces/fence/fence_1.cpp : examples/surfaces/fence/fence_2.cpp : examples/surfaces/fence/fence_3.cpp :","title":"Fence"},{"location":"COMPLETE_GALLERY/#ribbon","text":"examples/surfaces/ribbon/ribbon_1.cpp : examples/surfaces/ribbon/ribbon_2.cpp : examples/surfaces/ribbon/ribbon_3.cpp : examples/surfaces/ribbon/ribbon_4.cpp :","title":"Ribbon"},{"location":"COMPLETE_GALLERY/#graphs","text":"","title":"Graphs"},{"location":"COMPLETE_GALLERY/#undirected-graph","text":"examples/graphs/graph/graph_1.cpp : examples/graphs/graph/graph_2.cpp : examples/graphs/graph/graph_3.cpp : examples/graphs/graph/graph_4.cpp : examples/graphs/graph/graph_5.cpp : examples/graphs/graph/graph_6.cpp :","title":"Undirected Graph"},{"location":"COMPLETE_GALLERY/#directed-graph","text":"examples/graphs/digraph/digraph_1.cpp : examples/graphs/digraph/digraph_2.cpp : examples/graphs/digraph/digraph_3.cpp :","title":"Directed Graph"},{"location":"COMPLETE_GALLERY/#images","text":"","title":"Images"},{"location":"COMPLETE_GALLERY/#image-show","text":"examples/images/imshow/imshow_1.cpp : examples/images/imshow/imshow_2.cpp : examples/images/imshow/imshow_3.cpp : examples/images/imshow/imshow_4.cpp : examples/images/imshow/imshow_5.cpp : examples/images/imshow/imshow_6.cpp : examples/images/imshow/imshow_7.cpp : examples/images/imshow/imshow_8.cpp : examples/images/imshow/imshow_9.cpp : examples/images/imshow/imshow_10.cpp : examples/images/imshow/imshow_11.cpp :","title":"Image Show"},{"location":"COMPLETE_GALLERY/#image-matrix","text":"examples/images/image/image_1.cpp : examples/images/image/image_2.cpp : examples/images/image/image_3.cpp : examples/images/image/image_4.cpp : examples/images/image/image_5.cpp :","title":"Image Matrix"},{"location":"COMPLETE_GALLERY/#scaled-image","text":"examples/images/imagesc/imagesc_1.cpp : examples/images/imagesc/imagesc_2.cpp : examples/images/imagesc/imagesc_3.cpp : examples/images/imagesc/imagesc_4.cpp :","title":"Scaled Image"},{"location":"COMPLETE_GALLERY/#annotations","text":"","title":"Annotations"},{"location":"COMPLETE_GALLERY/#text","text":"examples/annotations/text/text_1.cpp : examples/annotations/text/text_2.cpp : examples/annotations/text/text_3.cpp : examples/annotations/text/text_4.cpp : examples/annotations/text/text_5.cpp : examples/annotations/text/text_6.cpp : examples/annotations/text/text_7.cpp : examples/annotations/text/text_8.cpp :","title":"Text"},{"location":"COMPLETE_GALLERY/#text-with-arrow","text":"examples/annotations/textarrow/textarrow_1.cpp : examples/annotations/textarrow/textarrow_2.cpp :","title":"Text with Arrow"},{"location":"COMPLETE_GALLERY/#rectangle","text":"examples/annotations/rectangle/rectangle_1.cpp : examples/annotations/rectangle/rectangle_2.cpp : examples/annotations/rectangle/rectangle_3.cpp : examples/annotations/rectangle/rectangle_4.cpp : examples/annotations/rectangle/rectangle_5.cpp :","title":"Rectangle"},{"location":"COMPLETE_GALLERY/#filled-polygon","text":"examples/annotations/fill/fill_1.cpp :","title":"Filled Polygon"},{"location":"COMPLETE_GALLERY/#ellipse","text":"examples/annotations/ellipse/ellipse_1.cpp :","title":"Ellipse"},{"location":"COMPLETE_GALLERY/#textbox","text":"examples/annotations/textbox/textbox_1.cpp :","title":"Textbox"},{"location":"COMPLETE_GALLERY/#arrow","text":"examples/annotations/arrow/arrow_1.cpp : examples/annotations/arrow/arrow_2.cpp :","title":"Arrow"},{"location":"COMPLETE_GALLERY/#line","text":"examples/annotations/line/line_1.cpp :","title":"Line"},{"location":"COMPLETE_GALLERY/#appearance","text":"","title":"Appearance"},{"location":"COMPLETE_GALLERY/#labels","text":"","title":"Labels"},{"location":"COMPLETE_GALLERY/#title","text":"examples/appearance/labels/title/title_1.cpp : examples/appearance/labels/title/title_2.cpp : examples/appearance/labels/title/title_3.cpp : examples/appearance/labels/title/title_4.cpp : examples/appearance/labels/title/title_5.cpp : examples/appearance/labels/title/title_6.cpp : examples/appearance/labels/title/title_7.cpp : examples/appearance/labels/title/title_8.cpp :","title":"Title"},{"location":"COMPLETE_GALLERY/#subplot-title","text":"examples/appearance/labels/sgtitle/sgtitle_1.cpp : examples/appearance/labels/sgtitle/sgtitle_2.cpp :","title":"Subplot Title"},{"location":"COMPLETE_GALLERY/#x-label","text":"examples/appearance/labels/xlabel/xlabel_1.cpp : examples/appearance/labels/xlabel/xlabel_2.cpp : examples/appearance/labels/xlabel/xlabel_3.cpp : examples/appearance/labels/xlabel/xlabel_4.cpp : examples/appearance/labels/xlabel/xlabel_5.cpp : examples/appearance/labels/xlabel/xlabel_6.cpp : examples/appearance/labels/xlabel/xlabel_7.cpp : examples/appearance/labels/xlabel/xlabel_8.cpp :","title":"X Label"},{"location":"COMPLETE_GALLERY/#y-label","text":"examples/appearance/labels/ylabel/ylabel_1.cpp : examples/appearance/labels/ylabel/ylabel_2.cpp : examples/appearance/labels/ylabel/ylabel_3.cpp : examples/appearance/labels/ylabel/ylabel_4.cpp : examples/appearance/labels/ylabel/ylabel_5.cpp : examples/appearance/labels/ylabel/ylabel_6.cpp : examples/appearance/labels/ylabel/ylabel_7.cpp : examples/appearance/labels/ylabel/ylabel_8.cpp :","title":"Y Label"},{"location":"COMPLETE_GALLERY/#z-label","text":"examples/appearance/labels/zlabel/zlabel_1.cpp : examples/appearance/labels/zlabel/zlabel_2.cpp : examples/appearance/labels/zlabel/zlabel_3.cpp :","title":"Z Label"},{"location":"COMPLETE_GALLERY/#legend","text":"examples/appearance/labels/legend/legend_1.cpp : examples/appearance/labels/legend/legend_2.cpp : examples/appearance/labels/legend/legend_3.cpp : examples/appearance/labels/legend/legend_4.cpp : examples/appearance/labels/legend/legend_5.cpp : examples/appearance/labels/legend/legend_6.cpp : examples/appearance/labels/legend/legend_7.cpp : examples/appearance/labels/legend/legend_8.cpp : examples/appearance/labels/legend/legend_9.cpp :","title":"Legend"},{"location":"COMPLETE_GALLERY/#axis","text":"","title":"Axis"},{"location":"COMPLETE_GALLERY/#x-limits","text":"examples/appearance/axis/xlim/xlim_1.cpp : examples/appearance/axis/xlim/xlim_2.cpp : examples/appearance/axis/xlim/xlim_3.cpp : examples/appearance/axis/xlim/xlim_4.cpp : examples/appearance/axis/xlim/xlim_5.cpp : examples/appearance/axis/xlim/xlim_6.cpp :","title":"X Limits"},{"location":"COMPLETE_GALLERY/#y-limits","text":"examples/appearance/axis/ylim/ylim_1.cpp : examples/appearance/axis/ylim/ylim_2.cpp : examples/appearance/axis/ylim/ylim_3.cpp : examples/appearance/axis/ylim/ylim_4.cpp : examples/appearance/axis/ylim/ylim_5.cpp : examples/appearance/axis/ylim/ylim_6.cpp :","title":"Y Limits"},{"location":"COMPLETE_GALLERY/#z-limits","text":"examples/appearance/axis/zlim/zlim_1.cpp : examples/appearance/axis/zlim/zlim_2.cpp : examples/appearance/axis/zlim/zlim_3.cpp : examples/appearance/axis/zlim/zlim_4.cpp : examples/appearance/axis/zlim/zlim_5.cpp : examples/appearance/axis/zlim/zlim_6.cpp :","title":"Z Limits"},{"location":"COMPLETE_GALLERY/#adjust-axis","text":"examples/appearance/axis/axis/axis_1.cpp : examples/appearance/axis/axis/axis_2.cpp : examples/appearance/axis/axis/axis_3.cpp : examples/appearance/axis/axis/axis_4.cpp : examples/appearance/axis/axis/axis_5.cpp : examples/appearance/axis/axis/axis_6.cpp : examples/appearance/axis/axis/axis_7.cpp : examples/appearance/axis/axis/axis_8.cpp :","title":"Adjust Axis"},{"location":"COMPLETE_GALLERY/#box","text":"examples/appearance/axis/box/box_1.cpp : examples/appearance/axis/box/box_2.cpp : examples/appearance/axis/box/box_3.cpp :","title":"Box"},{"location":"COMPLETE_GALLERY/#grid","text":"","title":"Grid"},{"location":"COMPLETE_GALLERY/#grid_1","text":"examples/appearance/grid/grid/grid_1.cpp : examples/appearance/grid/grid/grid_2.cpp : examples/appearance/grid/grid/grid_3.cpp : examples/appearance/grid/grid/grid_4.cpp :","title":"Grid"},{"location":"COMPLETE_GALLERY/#x-ticks","text":"examples/appearance/grid/xticks/xticks_1.cpp : examples/appearance/grid/xticks/xticks_2.cpp : examples/appearance/grid/xticks/xticks_3.cpp : examples/appearance/grid/xticks/xticks_4.cpp : examples/appearance/grid/xticks/xticks_5.cpp : examples/appearance/grid/xticks/xticks_6.cpp : examples/appearance/grid/xticks/xticks_7.cpp : examples/appearance/grid/xticks/xticks_8.cpp :","title":"X Ticks"},{"location":"COMPLETE_GALLERY/#y-ticks","text":"examples/appearance/grid/yticks/yticks_1.cpp : examples/appearance/grid/yticks/yticks_2.cpp : examples/appearance/grid/yticks/yticks_3.cpp : examples/appearance/grid/yticks/yticks_4.cpp : examples/appearance/grid/yticks/yticks_5.cpp : examples/appearance/grid/yticks/yticks_6.cpp : examples/appearance/grid/yticks/yticks_7.cpp : examples/appearance/grid/yticks/yticks_8.cpp :","title":"Y Ticks"},{"location":"COMPLETE_GALLERY/#z-ticks","text":"examples/appearance/grid/zticks/zticks_1.cpp : examples/appearance/grid/zticks/zticks_2.cpp : examples/appearance/grid/zticks/zticks_3.cpp : examples/appearance/grid/zticks/zticks_4.cpp : examples/appearance/grid/zticks/zticks_5.cpp : examples/appearance/grid/zticks/zticks_6.cpp :","title":"Z Ticks"},{"location":"COMPLETE_GALLERY/#x-tick-labels","text":"examples/appearance/grid/xticklabels/xticklabels_1.cpp : examples/appearance/grid/xticklabels/xticklabels_2.cpp : examples/appearance/grid/xticklabels/xticklabels_3.cpp : examples/appearance/grid/xticklabels/xticklabels_4.cpp :","title":"X Tick Labels"},{"location":"COMPLETE_GALLERY/#y-tick-labels","text":"examples/appearance/grid/yticklabels/yticklabels_1.cpp : examples/appearance/grid/yticklabels/yticklabels_2.cpp : examples/appearance/grid/yticklabels/yticklabels_3.cpp : examples/appearance/grid/yticklabels/yticklabels_4.cpp :","title":"Y Tick Labels"},{"location":"COMPLETE_GALLERY/#x-tick-format","text":"examples/appearance/grid/xtickformat/xtickformat_1.cpp : examples/appearance/grid/xtickformat/xtickformat_2.cpp : examples/appearance/grid/xtickformat/xtickformat_3.cpp : examples/appearance/grid/xtickformat/xtickformat_4.cpp : examples/appearance/grid/xtickformat/xtickformat_5.cpp :","title":"X Tick Format"},{"location":"COMPLETE_GALLERY/#y-tick-format","text":"examples/appearance/grid/ytickformat/ytickformat_1.cpp : examples/appearance/grid/ytickformat/ytickformat_2.cpp : examples/appearance/grid/ytickformat/ytickformat_3.cpp : examples/appearance/grid/ytickformat/ytickformat_4.cpp : examples/appearance/grid/ytickformat/ytickformat_5.cpp :","title":"Y Tick Format"},{"location":"COMPLETE_GALLERY/#z-tick-format","text":"examples/appearance/grid/ztickformat/ztickformat_1.cpp : examples/appearance/grid/ztickformat/ztickformat_2.cpp : examples/appearance/grid/ztickformat/ztickformat_3.cpp : examples/appearance/grid/ztickformat/ztickformat_4.cpp : examples/appearance/grid/ztickformat/ztickformat_5.cpp :","title":"Z Tick Format"},{"location":"COMPLETE_GALLERY/#x-tick-angle","text":"examples/appearance/grid/xtickangle/xtickangle_1.cpp : examples/appearance/grid/xtickangle/xtickangle_2.cpp : examples/appearance/grid/xtickangle/xtickangle_3.cpp :","title":"X Tick Angle"},{"location":"COMPLETE_GALLERY/#y-tick-angle","text":"examples/appearance/grid/ytickangle/ytickangle_1.cpp : examples/appearance/grid/ytickangle/ytickangle_2.cpp : examples/appearance/grid/ytickangle/ytickangle_3.cpp :","title":"Y Tick Angle"},{"location":"COMPLETE_GALLERY/#multiplot","text":"","title":"Multiplot"},{"location":"COMPLETE_GALLERY/#hold","text":"examples/appearance/multiplot/hold/hold_1.cpp : examples/appearance/multiplot/hold/hold_2.cpp : examples/appearance/multiplot/hold/hold_3.cpp : examples/appearance/multiplot/hold/hold_4.cpp :","title":"Hold"},{"location":"COMPLETE_GALLERY/#yy-axis","text":"examples/appearance/multiplot/yyaxis/yyaxis_1.cpp : examples/appearance/multiplot/yyaxis/yyaxis_2.cpp : examples/appearance/multiplot/yyaxis/yyaxis_3.cpp : examples/appearance/multiplot/yyaxis/yyaxis_4.cpp : examples/appearance/multiplot/yyaxis/yyaxis_5.cpp : examples/appearance/multiplot/yyaxis/yyaxis_6.cpp : examples/appearance/multiplot/yyaxis/yyaxis_7.cpp :","title":"YY-axis"},{"location":"COMPLETE_GALLERY/#color-order","text":"examples/appearance/multiplot/colororder/colororder_1.cpp : examples/appearance/multiplot/colororder/colororder_2.cpp : examples/appearance/multiplot/colororder/colororder_3.cpp : examples/appearance/multiplot/colororder/colororder_4.cpp : examples/appearance/multiplot/colororder/colororder_5.cpp : examples/appearance/multiplot/colororder/colororder_6.cpp : examples/appearance/multiplot/colororder/colororder_7.cpp :","title":"Color Order"},{"location":"COMPLETE_GALLERY/#subplots","text":"examples/appearance/multiplot/subplot/subplot_1.cpp : examples/appearance/multiplot/subplot/subplot_2.cpp : examples/appearance/multiplot/subplot/subplot_3.cpp : examples/appearance/multiplot/subplot/subplot_4.cpp : examples/appearance/multiplot/subplot/subplot_5.cpp : examples/appearance/multiplot/subplot/subplot_6.cpp : examples/appearance/multiplot/subplot/subplot_7.cpp : examples/appearance/multiplot/subplot/subplot_8.cpp : examples/appearance/multiplot/subplot/subplot_9.cpp : examples/appearance/multiplot/subplot/subplot_10.cpp : examples/appearance/multiplot/subplot/subplot_11.cpp : examples/appearance/multiplot/subplot/subplot_12.cpp : examples/appearance/multiplot/subplot/subplot_13.cpp :","title":"Subplots"},{"location":"COMPLETE_GALLERY/#tiled-layout","text":"examples/appearance/multiplot/tiledlayout/tiledlayout_1.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_2.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_3.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_4.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_5.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_6.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_7.cpp : examples/appearance/multiplot/tiledlayout/tiledlayout_8.cpp :","title":"Tiled Layout"},{"location":"COMPLETE_GALLERY/#colormaps","text":"","title":"Colormaps"},{"location":"COMPLETE_GALLERY/#colormap","text":"examples/appearance/colormaps/colormap/colormap_1.cpp : examples/appearance/colormaps/colormap/colormap_2.cpp : examples/appearance/colormaps/colormap/colormap_3.cpp : examples/appearance/colormaps/colormap/colormap_4.cpp : examples/appearance/colormaps/colormap/colormap_5.cpp : examples/appearance/colormaps/colormap/colormap_6.cpp : examples/appearance/colormaps/colormap/colormap_7.cpp : examples/appearance/colormaps/colormap/colormap_8.cpp : examples/appearance/colormaps/colormap/colormap_9.cpp :","title":"Colormap"},{"location":"COMPLETE_GALLERY/#color-bar","text":"examples/appearance/colormaps/colorbar/colorbar_1.cpp : examples/appearance/colormaps/colorbar/colorbar_2.cpp : examples/appearance/colormaps/colorbar/colorbar_3.cpp : examples/appearance/colormaps/colorbar/colorbar_4.cpp : examples/appearance/colormaps/colorbar/colorbar_5.cpp : examples/appearance/colormaps/colorbar/colorbar_6.cpp : examples/appearance/colormaps/colorbar/colorbar_7.cpp :","title":"Color Bar"},{"location":"COMPLETE_GALLERY/#rgb-plot","text":"examples/appearance/colormaps/rgbplot/rgbplot_1.cpp : examples/appearance/colormaps/rgbplot/rgbplot_2.cpp :","title":"RGB Plot"},{"location":"COMPLETE_GALLERY/#camera","text":"","title":"Camera"},{"location":"COMPLETE_GALLERY/#view","text":"examples/appearance/camera/view/view_1.cpp : examples/appearance/camera/view/view_2.cpp : examples/appearance/camera/view/view_3.cpp : examples/appearance/camera/view/view_4.cpp : examples/appearance/camera/view/view_5.cpp : examples/appearance/camera/view/view_6.cpp :","title":"View"},{"location":"COMPLETE_GALLERY/#lighting","text":"examples/appearance/camera/lighting/lighting_1.cpp : examples/appearance/camera/lighting/lighting_2.cpp : examples/appearance/camera/lighting/lighting_3.cpp : examples/appearance/camera/lighting/lighting_4.cpp : examples/appearance/camera/lighting/lighting_5.cpp : examples/appearance/camera/lighting/lighting_6.cpp :","title":"Lighting"},{"location":"COMPLETE_GALLERY/#figure-object","text":"examples/appearance/figure/figure_1.cpp : examples/appearance/figure/figure_2.cpp : examples/appearance/figure/figure_3.cpp :","title":"Figure Object"},{"location":"COMPLETE_GALLERY/#line-specs","text":"examples/appearance/line_spec/line_spec_1.cpp :","title":"Line Specs"},{"location":"COMPLETE_GALLERY/#axes-object","text":"examples/appearance/axes/axes_1.cpp : examples/appearance/axes/axes_2.cpp : examples/appearance/axes/axes_3.cpp : examples/appearance/axes/axes_4.cpp :","title":"Axes Object"},{"location":"COMPLETE_GALLERY/#clear-axes","text":"examples/appearance/cla/cla_1.cpp : examples/appearance/cla/cla_2.cpp : examples/appearance/cla/cla_3.cpp :","title":"Clear Axes"},{"location":"COMPLETE_GALLERY/#exporting","text":"","title":"Exporting"},{"location":"COMPLETE_GALLERY/#saving","text":"examples/exporting/save/save_1.cpp : examples/exporting/save/save_2.cpp : examples/exporting/save/save_3.cpp : examples/exporting/save/save_4.cpp : examples/exporting/save/save_5.cpp : examples/exporting/save/save_6.cpp : examples/exporting/save/save_7.cpp : examples/exporting/save/save_8.cpp :","title":"Saving"},{"location":"references/","text":"References These are some references we used for this work: Abadi M, Barham P, Chen J, Chen Z, Davis A, Dean J, Devin M, Ghemawat S, Irving G,Isard M,et al.(2016). \"Tensorflow: A system for large-scale machine learning.\" In 12th USENIX symposium on operating systems design and implementation (OSDI 16), pp.265-283. Angerson E, Bai Z, Dongarra J, Greenbaum A, McKenney A, Du Croz J, Hammarling S,Demmel J, Bischof C, Sorensen D (1990). \"LAPACK: A portable linear algebra library for high-performance computers.\" In Supercomputing'90: Proceedings of the 1990 ACM/IEEE Conference on Supercomputing, pp. 2-11. IEEE. Antcheva I, Ballintijn M, Bellenot B, Biskup M, Brun R, Buncic N, Canal P, Casadei D, CouetO, Fine V, et al.(2011). \"ROOT-A C++ framework for petabyte data storage, statistical analysis and visualization.\"Computer Physics Communications,182(6), 1384-1385. Baratov R (2019). Hunter. URL: https://hunter.readthedocs.io . Barrett P, Hunter J, Miller JT, Hsu JC, Greenfield P (2005). \"matplotlib-A Portable Python Plotting Package.\" In Astronomical data analysis software and systems XIV, volume 347,p. 91. Bezanson J, Edelman A, Karpinski S, Shah VB (2017). \"Julia: A fresh approach to numerical computing. \"SIAM review,59(1), 65-98. CEGUI Team (2020). CEGUI. URL: http://cegui.org.uk . Cornut O (2020). Dear ImGui: Bloat-free Immediate Mode Graphical User Interface for C++ with minimal dependencies. URL: https://github.com/ocornut/imgui . de Guzman J (2020). Elements. URL: http://cycfi.github.io/elements/ . Eichhammer E (2020). QCustomPlot. URL: https://www.qcustomplot.com . Evers B (2019). Matplotlib-cpp. URL: https://github.com/lava/matplotlib-cpp . Freitas A (2020). Pareto Front Library. URL: https://github.com/alandefreitas/pareto-front . Frigo M, Johnson SG (1998). \"FFTW: An adaptive software architecture for the FFT.\" In Proceedings of the 1998 IEEE International Conference on Acoustics, Speech and Signal Processing, ICASSP'98 (Cat. No. 98CH36181), volume 3, pp. 1381-1384. IEEE. Fruchterman TM, Reingold EM (1991). \"Graph drawing by force-directed placement. \"Software: Practice and experience, 21(11), 1129-1164. GNU Project (2020). GNU Octave: Introduction to Plotting. URL: https://octave.org/doc/v4.2.2/Introduction-to-Plotting.html . Guy Eric Schalnat Andreas Dilger GRP (2020). Libpng. URL: https://sourceforge.net/p/libpng/ . Hao J (2020). Nana. URL: http://nanapro.org/ . Hunter JD (2007). \"Matplotlib: A 2D graphics environment. \"Computing in Science & Engineering, 9(3), 90-95. doi:10.1109/MCSE.2007.55. Idea4good (2020). GuiLite. URL: https://github.com/idea4good/GuiLite . ImageMagick Studio LLC (2020). Magick++. URL: https://imagemagick.org/Magick++/ . Independent JPEG Group (2020). Libjpeg. URL: http://libjpeg.sourceforge.net . Intel Corporation, Willow Garage I (2020). Open Source Computer Vision Library (OpenCV). URL: https://opencv.org/ . Jakob W (2017). PyBind11. URL: https://pybind11.readthedocs.io/en/stable/ . Kagstrom B LP, C VL (2020). Basic Linear Algebra Subprograms (BLAS). URL: http://www.netlib.org/blas/ . Kainz F, Bogart R, Hess D (2003). \"The OpenEXR image file format.\"SIGGRAPH TechnicalSketches. Kamada T, Kawai S,et al.(1989). \"An algorithm for drawing general undirected graphs.\"Information processing letters,31(1), 7-15. Loup Gailly J, Adler M (2020). Zlib. URL: https://github.com/madler/zlib . Martin K, Hoffman B (2010). Mastering CMake: a cross-platform build system. Kitware. McKinney W,et al.(2011). \"Pandas: a foundational Python library for data analysis and statistics. \"Python for High Performance and Scientific Computing, 14(9). Conan.io (2020). Conan. URL: https://conan.io . Melchior L (2020). CPM.cmake. URL: https://github.com/TheLartians/CPM.cmake . Murray Cumming DE (2020). Gtkmm. URL: https://www.gtkmm.org/ . Natural Earth (2018). \"Natural earth. Free vector and raster map data.\" URL: http://www.naturalearthdata.com/downloads/ . NetworkX developers (2020). NetworkX. URL: https://networkx.github.io . Olivier Birot (2020). nodesoup. URL: https://github.com/olvb/nodesoup . Pezent E (2020). ImPlot. URL: https://github.com/epezent/implot . Sam Leffler SG (2020). Libtiff. URL: https://gitlab.com/libtiff/libtiff . Schaling B (2011). The boost C++ libraries. Boris Schaling. Spitzak B, et al.(2004). \"Fast Light Toolkit (FLTK).\" FTLK: Fast light toolkit. Available: http://www.fltk.org/ Stahlke D (2020). Gnuplot-Iostream. URL: http://stahlke.org/dan/gnuplot-iostream/ . Storer J (2020). JUCE. URL: https://juce.com . Terra Informatica Software, Inc (2020). Sciter. URL: https://sciter.com . The FLTK Team (2020). FLTK. URL: https://www.fltk.org . The MathWorks, Inc (2020). MatlabGraphics. URL: https://www.mathworks.com/help/matlab/graphics.html . The Qt Company (2020). Qt. URL: https://www.qt.io . Tschumperle D (2020). CImg. URL: http://cimg.eu . van der Zijp J (2020). Fox toolkit. URL: http://fox-toolkit.org . Vasilev V, Canal P, Naumann A, Russo P (2012). \"Cling-the new interactive interpreter for root 6.\" In Journal of Physics: Conference Series, volume 396, p. 052071. Walt Svd, Colbert SC, Varoquaux G (2011). \"The NumPy array: a structure for efficient numerical computation.\" Computing in science & engineering,13(2), 22-30. Wei V (2020). MiniGUI. URL: http://www.minigui.com . Williams T, Kelley C, Bersch C, Broker HB, Campbell J, Cunningham R, Denholm D, Elber G, Fearick R, Grammes C,et al.(2017). \"gnuplot 5.2.\" wxWidgets (2020). WxWidgets. URL: https://wxwidgets.org . XOrg Foundation (2020). X11. URL: https://www.x.org/ . Zaitsev S (2020). Webview. URL: https://github.com/zserge/webview . Zakai A (2011). \"Emscripten: an LLVM-to-JavaScript compiler.\" In Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion, pp. 301-312.","title":"References"},{"location":"references/#references","text":"These are some references we used for this work: Abadi M, Barham P, Chen J, Chen Z, Davis A, Dean J, Devin M, Ghemawat S, Irving G,Isard M,et al.(2016). \"Tensorflow: A system for large-scale machine learning.\" In 12th USENIX symposium on operating systems design and implementation (OSDI 16), pp.265-283. Angerson E, Bai Z, Dongarra J, Greenbaum A, McKenney A, Du Croz J, Hammarling S,Demmel J, Bischof C, Sorensen D (1990). \"LAPACK: A portable linear algebra library for high-performance computers.\" In Supercomputing'90: Proceedings of the 1990 ACM/IEEE Conference on Supercomputing, pp. 2-11. IEEE. Antcheva I, Ballintijn M, Bellenot B, Biskup M, Brun R, Buncic N, Canal P, Casadei D, CouetO, Fine V, et al.(2011). \"ROOT-A C++ framework for petabyte data storage, statistical analysis and visualization.\"Computer Physics Communications,182(6), 1384-1385. Baratov R (2019). Hunter. URL: https://hunter.readthedocs.io . Barrett P, Hunter J, Miller JT, Hsu JC, Greenfield P (2005). \"matplotlib-A Portable Python Plotting Package.\" In Astronomical data analysis software and systems XIV, volume 347,p. 91. Bezanson J, Edelman A, Karpinski S, Shah VB (2017). \"Julia: A fresh approach to numerical computing. \"SIAM review,59(1), 65-98. CEGUI Team (2020). CEGUI. URL: http://cegui.org.uk . Cornut O (2020). Dear ImGui: Bloat-free Immediate Mode Graphical User Interface for C++ with minimal dependencies. URL: https://github.com/ocornut/imgui . de Guzman J (2020). Elements. URL: http://cycfi.github.io/elements/ . Eichhammer E (2020). QCustomPlot. URL: https://www.qcustomplot.com . Evers B (2019). Matplotlib-cpp. URL: https://github.com/lava/matplotlib-cpp . Freitas A (2020). Pareto Front Library. URL: https://github.com/alandefreitas/pareto-front . Frigo M, Johnson SG (1998). \"FFTW: An adaptive software architecture for the FFT.\" In Proceedings of the 1998 IEEE International Conference on Acoustics, Speech and Signal Processing, ICASSP'98 (Cat. No. 98CH36181), volume 3, pp. 1381-1384. IEEE. Fruchterman TM, Reingold EM (1991). \"Graph drawing by force-directed placement. \"Software: Practice and experience, 21(11), 1129-1164. GNU Project (2020). GNU Octave: Introduction to Plotting. URL: https://octave.org/doc/v4.2.2/Introduction-to-Plotting.html . Guy Eric Schalnat Andreas Dilger GRP (2020). Libpng. URL: https://sourceforge.net/p/libpng/ . Hao J (2020). Nana. URL: http://nanapro.org/ . Hunter JD (2007). \"Matplotlib: A 2D graphics environment. \"Computing in Science & Engineering, 9(3), 90-95. doi:10.1109/MCSE.2007.55. Idea4good (2020). GuiLite. URL: https://github.com/idea4good/GuiLite . ImageMagick Studio LLC (2020). Magick++. URL: https://imagemagick.org/Magick++/ . Independent JPEG Group (2020). Libjpeg. URL: http://libjpeg.sourceforge.net . Intel Corporation, Willow Garage I (2020). Open Source Computer Vision Library (OpenCV). URL: https://opencv.org/ . Jakob W (2017). PyBind11. URL: https://pybind11.readthedocs.io/en/stable/ . Kagstrom B LP, C VL (2020). Basic Linear Algebra Subprograms (BLAS). URL: http://www.netlib.org/blas/ . Kainz F, Bogart R, Hess D (2003). \"The OpenEXR image file format.\"SIGGRAPH TechnicalSketches. Kamada T, Kawai S,et al.(1989). \"An algorithm for drawing general undirected graphs.\"Information processing letters,31(1), 7-15. Loup Gailly J, Adler M (2020). Zlib. URL: https://github.com/madler/zlib . Martin K, Hoffman B (2010). Mastering CMake: a cross-platform build system. Kitware. McKinney W,et al.(2011). \"Pandas: a foundational Python library for data analysis and statistics. \"Python for High Performance and Scientific Computing, 14(9). Conan.io (2020). Conan. URL: https://conan.io . Melchior L (2020). CPM.cmake. URL: https://github.com/TheLartians/CPM.cmake . Murray Cumming DE (2020). Gtkmm. URL: https://www.gtkmm.org/ . Natural Earth (2018). \"Natural earth. Free vector and raster map data.\" URL: http://www.naturalearthdata.com/downloads/ . NetworkX developers (2020). NetworkX. URL: https://networkx.github.io . Olivier Birot (2020). nodesoup. URL: https://github.com/olvb/nodesoup . Pezent E (2020). ImPlot. URL: https://github.com/epezent/implot . Sam Leffler SG (2020). Libtiff. URL: https://gitlab.com/libtiff/libtiff . Schaling B (2011). The boost C++ libraries. Boris Schaling. Spitzak B, et al.(2004). \"Fast Light Toolkit (FLTK).\" FTLK: Fast light toolkit. Available: http://www.fltk.org/ Stahlke D (2020). Gnuplot-Iostream. URL: http://stahlke.org/dan/gnuplot-iostream/ . Storer J (2020). JUCE. URL: https://juce.com . Terra Informatica Software, Inc (2020). Sciter. URL: https://sciter.com . The FLTK Team (2020). FLTK. URL: https://www.fltk.org . The MathWorks, Inc (2020). MatlabGraphics. URL: https://www.mathworks.com/help/matlab/graphics.html . The Qt Company (2020). Qt. URL: https://www.qt.io . Tschumperle D (2020). CImg. URL: http://cimg.eu . van der Zijp J (2020). Fox toolkit. URL: http://fox-toolkit.org . Vasilev V, Canal P, Naumann A, Russo P (2012). \"Cling-the new interactive interpreter for root 6.\" In Journal of Physics: Conference Series, volume 396, p. 052071. Walt Svd, Colbert SC, Varoquaux G (2011). \"The NumPy array: a structure for efficient numerical computation.\" Computing in science & engineering,13(2), 22-30. Wei V (2020). MiniGUI. URL: http://www.minigui.com . Williams T, Kelley C, Bersch C, Broker HB, Campbell J, Cunningham R, Denholm D, Elber G, Fearick R, Grammes C,et al.(2017). \"gnuplot 5.2.\" wxWidgets (2020). WxWidgets. URL: https://wxwidgets.org . XOrg Foundation (2020). X11. URL: https://www.x.org/ . Zaitsev S (2020). Webview. URL: https://github.com/zserge/webview . Zakai A (2011). \"Emscripten: an LLVM-to-JavaScript compiler.\" In Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion, pp. 301-312.","title":"References"},{"location":"white-paper/","text":"Matplot++: A C++ Graphics Library for Data Visualization Data visualization can help programmers and scientists identify trends in their data and efficiently communicate these results with their peers. Modern C++ is being used for a variety of scientific applications, and this environment can benefit considerably from graphics libraries that attend the typical design goals toward scientific data visualization. Besides the option of exporting results to other environments, the customary alternatives in C++ are either non-dedicated libraries that depend on existing user interfaces or bindings to other languages. Matplot++ is a graphics library for data visualization that provides interactive plotting, means for exporting plots in high-quality formats for scientific publications, a compact syntax consistent with similar libraries, dozens of plot categories with specialized algorithms, multiple coding styles, and supports generic backends. Table of Contents Introduction Data Visualization in C++ Data Visualization Scientific Computing in C++ Alternatives for Data Visualization in C++ Bindings Exporting Data Plotting widgets Gnuplot Pipes The Matplot library Figures and Axes Plot Categories Line Plots Data Distribution Discrete Data Geography Polar Plots Contour Plots Vector Fields Surfaces Graphs Images Annotations Appearance Coding Styles Member vs. Free-standing Functions Reactive figures Method Chaining Ranges Utilities Backend Interface Examples Interface A Minimal Application Applications Managing Plot Handles Exporting Figures Creating new plot types Backends Performance Conclusion References Introduction Data visualization is fundamental to scientific computing and metrics-driven development. Programmers can use interactive plotting to monitor their quality metrics more efficiently. Scientists rely on these tools to export their graphics in high-quality formats for scientific writings. The process of generating these graphics cannot be more expensive in terms of development time than the resources spent on the main problem at hand (Section Data Visualization ). While C++ has been valuable for a variety of scientific problems (Section Scientific Computing in C++ ), there is currently no alternative for data visualization that attends the design goals we habitually expect from scientific libraries (Section Alternatives for Data Visualization in C++ ). For this reason, this article presents Matplot++ (Section The Matplot++ Library ), a graphics library for data visualization in C++. The library maintains a high-level hierarchical structure to manage plots the user can create transparently with single function calls. The main library objects represent figures and axes that can hierarchically store child objects that can collectively represent plots in many categories (Section Figures and Axes ). Each plot category includes algorithms to solve numerous hurdles demanded in data visualization (Section Plot Categories ). For instance, producing plots might involve calculating multi-dimensional histogram bins, generating word clouds, efficiently cropping maps, converting data between coordinate systems, identifying contour lines, producing network layouts, and applying filters to images. Like present libraries for different programming languages, Matplot++ allows flexible coding styles (Section Coding Styles ). The user can choose between object-oriented programming or free-standing functions (Section Member vs. Free-Standing Functions ), reactive or quiet figures (Section Reactive Figures ), method chaining or smart pointers to adjust plot properties (Section Method Chaining ), and use any convertible range data type as input for the algorithms (Section Ranges ). Matplot++ also includes simple convenience functions to manipulate data (Section Utilities ) and the backend interface makes it viable to use Matplot++ in countless contexts (Section Backend Interface ). In Section Examples , we examine how Matplot++ relates to other comparable libraries and environments by addressing its interface (Section Interface ), provide extra examples of intricate integration into existent applications (Sections Minimal Application and Applications Managing Plot Handles ), illustrate the results for varying image formats (Sections Exporting Data ), and consider more high-level practices, like conceiving novel plot categories (Section Creating New Plot Categories ) and backends for unique environments (Section Backends ). Data Visualization in C++ Data Visualization Data visualization can help us promptly recognize trends in data. It is an indispensable means to interpret large volumes of data and to watch high-performance applications. Besides tests and benchmarks, data visualization also enables programmers to benefit more effectively from metrics-driven development. These metrics are particularly critical for high-performance computing, where unit tests can only identify bugs in scenarios we know about. Also, benchmarks cannot ordinarily identify bottlenecks for code optimization that replicate the production environment and its edge cases. It is ineffective to work to improve systems without proper instruments to measure their performance. For these purposes, tools for data experts usually incorporate functions for graphics. The design goals of these libraries tend to revolve around three aims: Interactive plotting: plots usually comprise reactive objects that get refreshed as soon as the figure attributes change. These reactive objects are valuable for monitoring systems in real-time. Exporting tools: libraries should have the means to export images in high-quality formats to communicate results in scientific writings. Productivity: the interface should incorporate commands to instantly produce the most well-known varieties of plots with a single function call. Additional commands should be required solely to attach supplementary plots to a figure or to customize plot features. Programmers should not spend substantial development time to produce plots. The development cost of including plots should be near zero. Matplotlib had the philosophy that it should take as few commands as possible to generate a plot. If feasible, that would be only one command. For instance, one should be able to create a line plot from x and y by 1 plt . plot ( x , y ) The Matlab environment embeds one of these graphic libraries. It incorporates a comfortable interface to interactively update plots and generate high-quality graphics for publications. Since then, this is one of the peculiarities that made Matlab a highly valuable environment for data analysis. Many scientists and programmers export their data to Matlab to adopt it as a mechanism for generating publication-quality images. Likewise, Octave incorporates a similar syntax for the equivalent kinds of graphics. The earliest versions of Octave used Gnuplot as a backend for its graphics. Since then, it has transitioned to a backend based on FLTK. Julia is yet another programming language that combines data visualization as part of its standard libraries. Meanwhile, Python has increasingly matured as a powerful means for data analysis, with libraries such as Pandas and Numpy. Python provides a compromise between abstraction and performance by transparently integrating high-performance compiled code. In this context, Matplotlib became a dominant tool that satisfied the demand for a Python graphics library. Matplotlib has a syntax comparable to the Matlab graphics library, which simplifies the transition from Matlab to Python for data scientists. Matplotlib incorporates functions to plot anything directly on an Axes object. Differently from Matlab, though, Matplotlib supports two coding styles. The first coding style uses the object-oriented class methods while the second is a wrapper around these objects to make the plots available as free-standing functions. The object-oriented style is more natural to Python programmers. Given an Axes object ax , one can create a line plot from x and y by 1 ax -> plot ( x , y ) The second coding style is designed to emulate the Matlab environment for transitioning users. In the first versions of Matplotlib, barrett2005matplotlib had a major express plan to conceive an interface as similar as possible to Matlab. Scientific Computing in C++ Since C++11, often referred to as Modern C++, C++ has become a very useful language for scientific computing. Features such as functional programming, type inference, constant expressions, structured binding declarations, ranges, concepts, smart pointers, variant types, and move semantics enabled C++ to catch up with most high-level programming languages. At the same time, C++ was capable of implementing these innovations without dropping its zero-overhead principle, which makes high-performance code expedient. There are several compelling reasons to use C++ in scientific computing: Performance: scientific applications that rely on approximations through iterative heuristics tend to benefit the greatest from C++. Numeric libraries: there are many reliable numeric libraries available for C++. Integration: it is accessible to integrate C++ libraries into other languages and tools. Licenses: there is no necessity of special licenses, like in Matlab Bindings: one can always call their C++ code from Python, Matlab, or R, for instance. Distribution: if you intend to distribute your compiled code, high-performance machine code circumvents the necessity of creating prototypes in one programming language and then repeating all the work once your experiments are successful. In parallel with the rising notoriety of Python, it has also become very prevalent the address the most computationally expensive pieces of a Python project in C++. A representative illustration of this strategy is the TensorFlow library. Modern libraries, such as PyBind11, expedite the generation of bindings connecting the two languages, making it easy for C++ programmers to provide performance to libraries in other programming languages. Although the C++ compilation process is how it accomplishes its performance, it might be oftentimes inconvenient to data scientists, who want to smoothly experiment with data more dynamically. An intermediary solution in this regard is CERN's ROOT data analysis framework, which provides Cling, a C++ interpreter. Another option to alleviate this obstacle is to maintain smaller shared libraries with a build tool, which makes the compilation process greatly faster. The absence of a cross-platform building system used to be a limitation of C++ over other languages for scientific computing. However, various recent C++ projects are based on CMake, which is a set of tools for building platform and compiler independent software. With the broad adoption of CMake, projects can be easily rebuilt on different platforms. By combining CMake and Emscripten, zakai2011emscripten makes it possible to even run high-performance C++ on the web with near-native speed. Some popular IDEs, such as CLion and Cevelop, use CMake as a standard format for its C++ projects. Package-management systems are likewise a relevant component of scientific programming, as it allows programmers to quickly experiment with combinations of algorithms. The typical solution to share libraries in C++ used to be header-only libraries, which do not need to be separately compiled. Most packages in the Boost libraries are header-only and work well with the C++ standard library. However, header-only libraries lead to longer compilation times and large libraries, such as Boost, might include too many unnecessary dependencies in our projects. An alternative to header-only libraries has been incorporated into CMake. CMake introduces commands such as ExternalProject and FetchContent to add custom targets to a project. These commands can download subprojects from usual URLs or Git repositories. If the external project is header-only or also based on CMake, the integration is particularly straightforward. Some packages, such as CPM.cmake, extend these features to provide light dependency management to C++ projects. Other packages, such as Conan and Hunter, provide more elaborate package managers. Finally, C++20 offers a feature for modules, which overcome the constraints of header files and make it more accessible to provide packages to existing projects. The standard library in Modern C++ offers many data structures based on templates with minimal computational overhead. This is an extra opportunity for data scientists to optimize their code in styles that are impractical in more simplistic high-level languages. For instance, while Matlab is extremely comfortable for matrix operations, it might become quite inconvenient for projects whose performance depends profoundly on more distinct data structures. There are innumerable C++ libraries for Graphical User Interfaces (GUIs) and low-level High-Performance Graphics. However, in a context where C++ is becoming increasingly more suitable to scientific applications, programmers must have access to libraries for accessible data visualization, for the very same purposes discussed in Section Data Visualization . Alternatives for Data Visualization in C++ Bindings One possibility is to use bindings to libraries meant for other high-level languages, such as Matplotlib. One such solution is matplotlib-cpp. These bindings create a convenient environment without too much effort on the user side. For instance, one can produce a line plot in matplotlib-cpp by 1 plt :: plot ( x , y ); However, these bindings (i) might create the necessity of large extra dependencies in our project, (ii) could partially eliminate the performance advantages for which developers are likely to have transitioned to C++, (iii) has an integration cost that affects the productivity design goal discussed in Section Data Visualization , (iv) would make integration with native GUIs tough or even impracticable in some circumstances, (v) rely on the maintainers to catch up with the primary package, and (vi) are invariably restricted by the features of the original library. In these situations, depending on the complexity of the project and how much the programmers need data visualization, a more suitable possibility might be to leave the C++ environment entirely, which might be proper to some projects but, as argued in Section Scientific Computing in C++ , could deny programmers of gains C++ can offer to many high-performance projects. Exporting Data A customary solution among C++ programmers is to export the data from a C++ application in a common format to other environments. The most informal format for exporting data is probably files with Comma-Separated Values (CSV). Excel, Gnuplot, Matlab, or Python can effortlessly import these files. The benefit of this strategy is that programmers can use other mechanisms to produce high-quality plots that are suitable for scientific publications while bypassing the nuisance of learning, integrating, or even implementing a native library. However, this hand-operated method is very unproductive in terms of development cost. Data visualization cannot occur interactively, so the user cannot watch the relevant metrics in real-time. This makes the development cycle longer since various failures cannot be recognized until all experiments are finished. If we avoid this manual process by programmatically exporting and importing the data in real-time to the secondary environment, we can get quasi-interactive plots. However, this requires a significantly higher development cost that could be better employed on the main project. Besides, if plots are refreshed very frequently, this would be comparable to a cumbersome and wasteful implementation of bindings, inheriting all their difficulties discussed in Section Bindings . Plotting widgets There are innumerable libraries for GUIs in C++. Some representative examples are Qt, wxWidgets, Dear ImGui, Webview, Nana, gtkmm, FLTK, JUCE, Fox toolkit, CEGUI, Sciter, MiniGUI, GuiLite, and Elements. GUI libraries in other programming languages are often bindings to these libraries. There are usually plotting widgets for these libraries. For instance, Qt has its objects for Charts. Libraries such as QCustomPlot can further extend these functionalities. Dear ImGui also incorporates objects for simplistic line plots and histograms. ImPlot provides additional objects for shaded plots, scatter plots, bar graphs, error bars, pie charts, and heatmaps. Some different libraries, like Webview, can take full advantage of any other plotting libraries for HTML. Despite being normally quite restricted in their functionalities, plotting widgets for GUI libraries have many advantages. Once a project has settled on a GUI library for the application, these plotting widgets are appropriate for incorporating supplemental plots into graphical interfaces. They enable interactive plots that communicate excellently with the main application and the final user. However, these are not suited for prototyping or scientific computing. If the programmer has not already engaged to a given GUI library for the project, including these libraries merely for producing plots to observe data might be more costly in terms of development time than the main application. This is particularly true for the initial stages of scientific applications where there is regularly no need for a user interface at all. However, in high-performance computing, these early stages of prototypes might be when we demand data visualization the most. This defeats the productivity criterion discussed in Section Data Visualization . A second obstacle with these widgets is that are usually not meant to produce high-quality graphics for scientific publications. This makes it more troublesome to communicate results. Gnuplot Pipes A popular solution for plots in C++ is to create a pipe to a process running Gnuplot through direct commands. Gnuplot-Iostream implements an istream object that can communicate programmatically with Gnuplot. The chief benefit of this procedure is that we can interactively manage Gnuplot without multiple dependencies. Besides the general weaknesses of bindings (Section Bindings ), process pipes to Gnuplot require programmers to compose functions that form strings with the source code to create a given plot in Gnuplot. The user needs to study a different language for plots and this might involve an extensive number of commands even for uncomplicated line plots, which does not make plotting as smooth as expected from data visualization libraries. The Matplot++ library This article presents the Matplot++ library, a native object-oriented library for data visualization in C++. Objects are organized in a hierarchical structure where parent objects recursively render themselves and their child objects. Meanwhile, users can stream data to these objects with short commands that update these elements to create plots in many representative categories. The follow diagram summarizes the main classes in Matplot++ . The figure object is the object the ultimately connects to a backend. This might be a backend to render interactive plots or to export graphics to a file. A figure object might have multiple plots represented by axes objects. Each axes object has eight axis objects. For inexperienced users, the most critical of these axis objects are the ones for the coordinates \\(x\\) , \\(y\\) , and \\(z\\) . We discuss these objects in more detail in Section Figures and Axes . An axes object is an abstract class that can hold a collection of primitives representing plots. These are the objects that ultimately embody the plot categories. We list these categories in Section Plot Categories . Lastly, a legend object is responsible for storing a list of labels we can associate to each axes object , and the appearance of the box where we present these labels. For convenience, the library interface has a syntax similar to Matplotlib and Matlab. This is helpful to accommodate users transitioning from these environments. Like Matplotlib, we support two coding styles, based on object-oriented programming and free-standing functions. We address these coding styles in Section Coding Styles . Our interface also employs templates to enable the functions to operate on a range of data types and data structures. We further use method chaining to allow for a more compact syntax. In Section Examples we examine the interface, provide some more high-level usage examples, illustrate the data formats for images, enumerate some limitations of our current implementation, and contrast our library with similar solutions. We supply numerous emblematic samples for all plot categories in this paper. Besides these instances, the library repository further includes a gallery with hundreds of examples that cover all plot categories and subcategories. Figures and Axes The central object in Matplot++ is a figure , which describes a window or image on which we can plot one or more axes objects. The following Figure depict these main classes in more detail. Note that, unless the user needs to control these objects directly, this entire procedure of generating and maintaining the relevant figure for a plot is transparent to the user. The data scientist running a short experiment would probably just call a single command to stream their data to whatever plot category seems more suitable to visualize the data. A simple figure will usually have one axes object that stores the plots. A figure in quiet mode (non-reactive mode), will only be updated when the user calls the draw function, which recursively calls the draw function on all its child objects. This is the function we call to send the appropriate commands or vertices to the backend. If a figure is not in quiet mode, updating a property in any child object will automatically call the draw function. By default, figures are not in quiet mode. The show function is a variant of draw that blocks the execution until the user closes the figure or interacts with the console. This is useful to ensure one can visualize the results before the execution terminates. While this function is helpful for experiments, it should not be employed inside a library that will be used non-interactively. The touch function is intended to be used internally by child objects. The function calls draw only if the figure is in reactive mode. The commands add_axes , add_subplot , and nexttile create and properly position new axes in the figure. add_axes adds a new axes object in any absolute position on the figure, and we can choose to replace an existent axes object if it overlaps with the new axes. add_subplot will construct a new axes object in a position consistent with a layout of rows rows and cols columns. nexttile adds a subplot coherent with the rows, columns, and id defined by tiledlayout and currenttile . All these functions return an axes_handle object, which is a shared pointer to an axes object. The user can use this handle to update axes properties. When the last shared pointer to an axes objects ceases to exist, the axes object is deallocated from memory. The figure also holds a handle current_axes , which points to the last axes we added to the figure unless the user modifies it. The user can create multiple figures in the same process. If they are all interactive figures, this will open multiple windows in the same process. All new figures go to a global figure registry of figure handles. If the user calls a plotting command, it will use the current figure in the registry. The free-standing function gcf() returns a handle to the current figure in the registry. If there is no figure in the registry, gcf() adds a new figure to the registry and returns its handle. Because free-standing functions to create plots rely on gcf() , if there is no current figure in the registry, the registry creates a new figure for any initial plot the command. This allows users to use the library as a resource to stream their data transparently. The axes object is the object responsible for maintaining the plots. The following Figure presents more details. A new axes object will have no child objects and no legend. It has only its original collection of axis objects with default attributes for each coordinate. If we draw this new axes object, we get a figure like: In this Section, we export the figures with a gray background to help the reader differentiate the figure and axes objects. Analogous to gcf() , the method gca() returns a handle to the current axes in the current figure. If there is no current axes object in the figure, gca() will create a new axes . The method emplace_object pushes a new axes object to the axes . However, this method is not expected to be used directly. A variety of auxiliary methods create the appropriate axes object for a given plot category and make necessary calls to emplace_object . For instance, 1 2 vector < int > y = { 2 , 4 , 7 , 7 , 6 , 3 , 9 , 7 , 3 , 5 }; plot ( y ); is internally equivalent to 1 2 3 vector < int > y = { 2 , 4 , 7 , 7 , 6 , 3 , 9 , 7 , 3 , 5 }; line_handle l = make_shared < class line > ( gca (), y ); gca () -> emplace_object ( l ); Both would generate this line plot: For convenience, we assume throughout this paper we are operating in the matplot and std namespaces. This practice, nevertheless, is probably not recommendable in large projects and surely not advisable in header files. Besides the functions presented in last diagram, the axes object has dozens of methods to control its appearance. The methods can determine the axes location, camera positioning (for 3D plots), shortcuts to define the appearance of axis objects, its title, font properties, colors, grids behind the data, and boxes around the axes. These methods are described in detail in the documentation. There are also dozens of shortcuts to construct and emplace objects representing diverse plot categories. We discuss these categories in Section Plot Categories . The axis objects depict a specific coordinate. The \\(x\\) and \\(y\\) coordinates are used in two-dimensional plots. Two-dimensional plots can also use the extra coordinates \\(x_2\\) and \\(y_2\\) . The \\(x\\) , \\(y\\) , \\(z\\) coordinates are used in three-dimensional plots. The \\(r\\) and \\(t\\) coordinates are used in polar plots. Finally, the \\(cb\\) coordinate is used to determine the range of colorbars. Colorbars are useful to provide a third dimension to two-dimensional plots. For instance, we can use the \\(y_2\\) axis by 1 2 3 4 5 vector < int > y1 = { 1 , 10 , 7 , 6 , 7 , 7 , 4 , 6 , 1 , 6 }; vector < int > y2 = { 7 , 2 , 9 , 1 , 9 , 7 , 2 , 1 , 10 , 5 }; plot ( y1 ); hold ( on ); plot ( y2 ) -> use_y2 ( true ); The hold function determines the next_plot_replace property of the current axes . This property decides whether the next object we emplace in the axes should replace the current objects. The hold function expects a bool as a parameter. As a convenience for users transitioning from Matlab, we use constexpr to define on and off as aliases for true and false . As an extra convenience, note how we call use_y2 through method chaining, which can directly alter properties on the handle. The following Figure shows the resulting plot. Lastly, if the axes object has a legend object, it will store labels for the data in the axes and manage the presentation of the box with these labels. The legend function can be used to create such an object in the current axes. The function returns a legend_handle we can use to set its appearance. The axes objects can get their labels from the legend object or their display_name . For instance, given a set of line plots, we can combine both strategies by 1 2 3 vector < line_handle > ls = plot ( random_lines ); legend ( \"Line 1\" , \"Line 2\" ); ls [ 2 ] -> display_name ( \"Line 3\" ); This would create the plot presented in the following Figure: In this example, the plot receives four lines as input and returns a list of line handles. We use legend function to attribute a label to the first two line handles that have no display name. The third line has its label directly defined with display_name . The fourth line has no legend. Plot Categories An axes object can hold plots in many categories. An axes object is an abstract class that represents what should be drawn in the axes. The following Figure shows the objects that inherit from axes objects . These objects represent primitives that can compose a plot. A plot category might depend on more than one axes object . For instance, contour lines might depend on contours and labels . The same axes object can also serve a number of plot categories. For instance, a matrix can represent heatmaps and images. By composing axes objects , the library offers functions to create plots in the following main categories: Line Plots (Section Line Plots ) Data Distribution (Section Data Distribution ) Discrete Data (Section Discrete Data ) Geography (Section Geography ) Polar Plots (Section Polar Plots ) Contour Plots (Section Contour Plots ) Vector Fields (Section Vector Fields ) Surfaces (Section Surfaces ) Graphs (Section Graphs ) Images (Section Images ) Annotations (Section Annotations ) In the following subsections, we discuss some important details of the algorithms in each of these categories. Line Plots The Line Plots cover the following subcategories: Line Plot; Line Plot 3D; Stairs; Error Bars; Area; Loglog Plot; Semilogx Plot; Semilogy Plot; Function Plot; Function Plot 3D; and Implicit function. Plots in this category depend on the line object. This object stores data for two or three-dimensional lines. The error bar object includes extra lines to represent error around data points. Log plots are utility functions that adjust the \\(x\\) or \\(y\\) axes to a logarithmic scale. The stair object renders the line with stairs between data points to denote discrete data. Instead of storing data points, the objects function line and string function store a function as a lambda function or as a string with an expression. These objects use lazy evaluation to generate absolute data points. The data is generated only when the draw function is called. The filled area object creates a polygon filling the area between the \\(x\\) axis and each line. Each of these plots can be created by 1 2 vector < vector < int >> Y = { { 1 , 3 , 4 , 0 }, { 2 , 5 , 4 , 7 }, { 6 , 4 , 5 , 3 } }; area ( Y , -4 , stacked ); where stacked is a boolean that tells whether the lines in Y should be stacked. Data Distribution The Data Distribution category includes the following subcategories: Histogram; Boxplot; Scatter Plot; Scatter Plot 3D; Binned Scatter Plots; Plot Matrix; Parallel Coordinates; Pie Chart; Heatmap; and Word Cloud. These plot subcategories depend on the axes object types histogram , box chart , line , matrix , parallel lines , circles , labels . The histogram object creates the histogram edges and bins when the draw function is called for the first time with lazy evaluation. Lazy evaluation avoids calculating edges unnecessarily in case the user changes the object parameters before calling draw . This object includes several algorithms for automatically delimiting the edges and bins for the histograms. This Figure exemplifies some of these algorithms. Like the Line Plot subcategories, Scatter plots also depend on the line object. As the line object can represent lines with markers, the scatter function simply creates markers without the lines. Binned scatter plots use variations of the histogram algorithms of the previous Figure as an extra step to place all the data into two-dimensional bins that can be represented with varying colors or sizes. This is useful when there are so many data points that a scatter plot would be impractical for visualizing the data. The Plot Matrix subcategory is a combination of histograms and scatter plots. It creates a matrix of axes objects on the figure and creates a scatter plot for each pair of data sets. The function parallelplot creates a plot with Parallel Coordinates. In this type of plot, a parallel lines object stores an arbitrary set of axis objects to represent multi-dimensional data. This Figure exemplifies the parallel coordinates we can generate by 1 2 3 4 5 6 vector < vector < double >> X ( 4 ); X [ 0 ] = randn ( 100 , 50 , 200 ); X [ 1 ] = transform ( X [ 0 ], []( double x ){ return x + rand ( -30 , + 30 );}); X [ 2 ] = transform ( X [ 0 ], []( double x ){ return x > 50 ? + 1. : -1. ;}); X [ 3 ] = transform ( X [ 0 ], []( double x ){ return cos ( rand ( -30 , + 30 ));}); parallelplot ( X , X [ 2 ]); where randn and transform are shortcuts to generate random numbers with a normal distribution and to transform data. The second parameter of parallelplot determines the color of each data point, for which we use X[2] . Those axes are generated on top of a two-dimensional axes object. Word clouds are generated from text or pairs of words and their frequency. After attributing a size proportional to each word frequency, the algorithm to position the labels iterates words from the largest to the smallest. For each word, it spins the word in polar coordinates converted to Cartesian coordinates until it does not overlap with any other word. This Figure exemplifies a word cloud we can generate by 1 wordcloud ( tokens , count ); By default, the colors and the sizes depend on the word frequencies. We can customize the colors by passing a third parameter to the wordcloud function. Discrete Data The Discrete Data category includes the following subcategories: Bar Plot; Pareto Chart; Stem Plot; and Stem Plot 3D. These subcategories depend on the axes object types bars and line . Bar Plots depend on the bars object. Pareto Charts emplace a combination of bars and line . Stem plots rely on the line object. Pareto Charts are a type of chart that uses both \\(y\\) axes. The \\(y_1\\) axis is used to represent bars with the data values in descending order. The \\(y_2\\) axis is used to represent the cumulative distribution function of the data in the \\(y_1\\) axis. This next Figure exemplifies a Pareto chart generated by 1 2 vector < double > y = randn ( 20 , 500 , 1000 ); pareto ( y ); By default, a Pareto Chart includes up to 10 items or as many items as needed to represent 95\\% of the cumulative distribution. If the reader needs Pareto fronts rather than Pareto charts , we refer to Scatter Plots for two-dimensional fronts, Plot matrices for three-dimensional fronts, or Parallel Coordinates for many-objective fronts. These plot subcategories are described in Section Data Distribution . If the user also needs a tool to calculate these fronts efficiently, we refer to the Pareto Front Library . Geography The Geography category includes the following subcategories: Geoplot, Geoscatter, Geobubble, and Geodensity. All these subcategories depend on the line object to plot maps and data over these maps. For the first geography plot, we call geoplot() , which creates a filled polygon with the world map. This first plot receives the tag \"map\" so that subsequent geography plots recognize there is no need to recreate this world map. The data for the world map comes from Natural Earth. They provide data at 1:10m, 1:50m, and 1:110m scales. The geoplot function will initially use the data at the 1:110m scales. The geolimits function can be used to update the axis limits for geography plots. The difference between the usual functions for adjusting axis limits ( xlim and ylim ) and geolimits is that the latter will also update the map resolution according to the new limits for the \\(x\\) and \\(y\\) axis. The geolimits function will query the figure size and, depending on the new limits for the axes, update the map to the 1:10m, or 1:50m scales if needed. Because it would be very inefficient to render the whole world map at a 1:10m or 1:50m scale only to display a region of this map, the geolimits function also crops the data pertinent to the new region being displayed. Note that this does not only involve removing data points outside the new limits but it also needs to create new data points on the correct borders to create new polygons coherent with the map entry points in the region. For this reason, the algorithm needs to track all submaps represented as closed polygons in the original world map. If submaps are completely inside or outside the new ranges, we can respectively include or dismiss the data points. However, if the submap is only partially inside the new limits, to generate the correct borders for the polygons, we need to track all points outside the limits to classify the directions of these points outside the limits. We do that by only including points that change quadrants around the new limits so that the map entry points create polygons that look like they would if the complete world map were still being rendered outside these new limits. If the library user is not interested in geographic plots, the build script includes an option to remove the high-resolution maps at 1:10m and 1:50m scales from the library. In this case, the library will always use the map at a 1:110m scale no matter the axis limits. Figure exemplifies the map generated by 1 2 3 4 auto [ lon , lat , names ] = world_cities ( 6 , 8 ); auto [ lon2 , lat2 ] = greedy_tsp ( lon , lat ); geoplot ( lat2 , lon2 ) -> marker ( \"o\" ). marker_colors ( iota ( 1 , names . size ())); text ( lon , lat , names ); The function world_cities returns a list of major world cities. Its parameters define the minimum distances between cities in the \\(x\\) and \\(y\\) axes. The greedy_tsp function is a naive greedy algorithm to find a route between these cities as a Traveling Salesman Problem (TSP). We use the geoplot function to draw this route. Note that we use method chaining to define some further plot properties. Finally, the text function includes the city names in the map. Polar Plots The Polar Plots category includes the following subcategories: Polar Line Plot, Polar Scatter Plot, Polar Histogram, Compass, and Polar Function. These subcategories depend on the axes object types line , histogram , vectors , string function , and function line . By emplacing a polar plot in the axes , the axes move to a polar mode, where we use the \\(r\\) and \\(t\\) axis instead of the \\(x\\) and \\(y\\) axis. From the backend point of view, these axes are an abstraction to the user. The data points in the \\(r\\) and \\(t\\) axis are drawn by converting the positions from the polar coordinates \\(r\\) and \\(t\\) to the Cartesian coordinates \\(x\\) and \\(y\\) with the relationships \\(x=r \\cos{t}\\) and \\(y=r \\sin{t}\\) . Aside from this conversion, these plot subcategories are analogous to line plots, scatter plots, histograms, quiver plots, and line functions. The next Figure exemplifies the polar histogram generated by 1 2 vector < double > y = randp ( 100 , 1.0 , 0.5 ); polarhistogram ( y , 25 ); The function polarhistogram distributes the data into the number of bins provided as its second parameter. Contour Plots The Contour Plots category includes the following subcategories: Contour Plots, Filled Contours, and Function Contour. All these subcategories depend on the contours type. They also depend on lazy evaluation for generating the contour lines. When the function draw is called in the contours class, it preprocesses all contour lines for a three-dimensional function. Although it is relatively simple to show a heatmap with the values for the \\(z\\) -axis, calculating contour lines relative to the \\(z\\) -axis is more complex than it might seem at first. We provide the function contourc for calculating contour lines. This function uses an adaptation of the algorithm adopted by Matplotlib. The algorithm creates a quad grid defined by the \\(x\\) and \\(y\\) values. It uses this grid to infer a contour line passing through positions with the same \\(z\\) value. The algorithm sweeps through the grid twice to generate these lines. The first sweep looks for lines that start on the boundaries. The second sweep looks for interior closed loops. Filled contours are closed polygons for pairs of contour levels. Some polygons for filled contours might be holes inside other polygons. The algorithm needs to keep track of these relationships so that we can render the polygons in their accurate order. To avoid an extra step that identifies this relationship between the polygons, the sweeping algorithm already identifies which polygons are holes for each level. Once we find the quads with the contour line, the line is generated by interpolating the \\(z\\) values around that quad. For instance, consider the Rastrigin function: 1 2 3 auto rastrigin = []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }; The next Figure exemplifies the filled contour lines generated for this function by 1 fcontour ( rastrigin ) -> filled ( true ); By default, the function fcontour will generate 9 contour lines from a lambda function. The functions contour and contourf , on the other hand, plot contour lines and filled contour lines from a grid of data points for \\(x\\) , \\(y\\) , and \\(z\\) . Vector Fields The Vector Fields category includes the following subcategories: Feather, Quiver, and Quiver 3D. All these subcategories depend on the vectors object type. In a two-dimensional plot, for each value of \\(x\\) and \\(y\\) with the position of a vector, it also requires the value of \\(u\\) and \\(v\\) indicating its direction and magnitude. In a three-dimensional plot, the direction and magnitude are defined by \\(u\\) , \\(v\\) , and \\(w\\) . A quiver plot (or velocity plot) shows a grid of vectors whose direction and magnitude are scaled to prevent the overlap between vectors in subsequent quads. Still considering the Rastrigin function, we can generate a grid with its data values and its gradient by 1 2 3 auto [ x , y ] = meshgrid ( iota ( -5 , .2 , 5 )); auto z = transform ( x , y , rastrigin ); auto [ dx , dy ] = gradient ( z , .2 , .2 ); where meshgrid , transform , and gradient are simple convenience functions. We can then present the contours lines and the gradient directions by 1 2 3 contour ( x , y , z ); hold ( on ); quiver ( x , y , dx , dy ); The following Figure quiver presents the results, where the quiver vectors help us identify the directions in which the function is decreasing in the contour plot. Surfaces The Surfaces category includes the following subcategories: Surface; Surface with Contour; Mesh; Mesh with Contour; Mesh with Curtain; Function Surface; Function Mesh; Waterfall; Fence; and Ribbon. All these subcategories depend on the surface class. The Waterfall, and Fence subcategories create surface slices for each value of \\(y\\) . The Ribbon subcategory creates surface slices for each value of \\(x\\) . Still considering the Rastrigin function, the next Figure exemplifies the Ribbon plot generated by 1 2 3 auto [ X , Y ] = meshgrid ( iota ( -5 , 1 , 5 ), iota ( -5 , .1 , 5 )); auto Z = transform ( X , Y , rastrigin ); ribbon ( X , Y , Z ) -> face_alpha ( 0.8 ); To make the visualization more comfortable, we define a larger step size on the \\(x\\) axis. Graphs The Graphs category includes the following subcategories: Undirected Graphs; and Directed Graphs. All these subcategories depend on the network class. Graphs are abstract structures that represent objects and relationships between these objects. The objects are represented as vertices and the relationships are depicted as edges. In an abstract graph, the vertices have no specific position in space. Mathematically, a graph does not depend on its layout. However, the graph layout has a large impact on its understandability. The network class can calculate appropriate positions for graph vertices with several algorithms: Kamada Kawai algorithm, Fruchterman-Reingold algorithm, circle layout, random layout, and automatic layout. The implementation of the Kamada Kawai and Fruchterman-Reingold algorithms depend on the NodeSoup library. The next Figure exemplifies the Undirected Graph generated by 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector < pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 1 , 2 }, { 1 , 4 }, { 2 , 3 }, { 3 , 5 }, { 4 , 5 }, { 4 , 6 }, { 6 , 8 }, { 8 , 9 }, { 7 , 9 }, { 8 , 7 }, { 9 , 10 } }; vector < double > weights = { 4 , 4 , 2 , 1 , 1 , 4 , 2 , 1 , 3 , 3 , 2 , 4 , 1 }; graph ( edges ) -> edge_labels ( weights ); The automatic layout uses the Kamada Kawai algorithm for small graphs and the Fruchterman-Reingold algorithm for larger graphs. Images The Images category includes the following subcategories: Image Show; Image Matrix; and Scaled Image. These subcategories depend on the matrix class. The matrix class can have up to four matrices. If it has only one matrix, it is represented with a colormap. If it has three matrices, they represent the red, green, and blue channels. If it has four matrices, the fourth matrix represents an alpha channel to control the transparency of each pixel. We use the CImg library to load and save images. CImg can handle many common image formats as long as it has access to the appropriate libraries. The Matplot++ build script will look at compile-time for the following optional libraries: JPEG, TIFF, ZLIB, PNG, LAPACK, BLAS, OpenCV, X11, fftw3, OpenEXR, and Magick++. The build script will attempt to link all libraries from this list to Matplot++ . Matplot++ includes a few convenience functions to manipulate matrices with images: imread , rgb2gray , gray2rgb , imresize , and imwrite . All these functions work with lists of matrices. The next Figure exemplifies the image generated by 1 2 3 auto image = imread ( \"lena_gray.tiff\" ); imshow ( image [ 0 ]); colormap ( palette :: default_map ()); Because image is a list of matrices, image[0] is a matrix with the gray channel. If we used imread to load a colored image, image[0] would represent the red channel. Because the matrix has only one channel, it uses the default colormap. By default, the imshow function sets the grayscale colormap as the axes colormap. We use the colormap function to change it to the default colormap and generate a colored image. Annotations The Annotations category includes the following subcategories: Text; Text with Arrow; Rectangle; Filled Polygon; Ellipse; Textbox; Arrow; and Line. These subcategories depend on the axes object types labels , line , and vectors . The annotations category is meant to create individual objects on the plot rather than representations of data sets. An important difference between the annotations category and other categories is that, by default, the annotations do not replace the plot that already exists in the axes object, even if the user does not call the hold function. The next Figure exemplifies a number of annotations generated by 1 2 3 4 5 6 7 8 9 10 11 vector < double > x = { 0 , 8 , 8 , 0 }; vector < double > y = { 0 , 0 , 4 , 4 }; polygon ( x , y , \"g\" ); rectangle ( 0 , 0 , 2 , 4 , 0 ) -> fill ( true ). color ( \"red\" ); rectangle ( 3 , 0 , 2 , 4 , 1 ) -> fill ( true ). color ( \"magenta\" ); rectangle ( 6 , 0 , 2 , 4 , 0.5 ) -> fill ( true ). color ( \"yellow\" ); text ( 2 , 2 , \"Curvature 0\" ) -> alignment ( labels :: alignment :: right ); text ( 4 , 2 , \"Curvature 1\" ) -> alignment ( labels :: alignment :: center ); text ( 6 , 2 , \"Curvature 0.5\" ) -> alignment ( labels :: alignment :: left ); arrow ( 4 , 2.2 , 3 , 3 ); textarrow ( 6 , 1 , 8 , 0 , \"Last corner\" ); The rectangle object can have a border curvature from \\(0\\) to \\(1\\) . We can also annotate with text, arrows, polygons, and lines. Appearance All objects have numerous methods to control their appearance. This control is fundamental for high-quality publication images. As a convenience, the colors.h header contains many functions to generate colors from strings and vice-versa. It also contains dozens of functions to generate colormaps. The axes object has functions to control the labels for each axis, the subplot title, and the legends for child objects. Each axis object has functions to control its limits, manually adjust the axis ticks, define labels for manual ticks, and label formats for automatic ticks. There are various functions that allow and facilitate multiplots in a figure. The hold and use_y2 functions allow multiple plots on the same axes object. The subplot and nexttile functions allow a layout with many axes objects on the same figure . Another option is to create extra figure objects, which would open more plot windows. The colormaps can be used with two-dimensional plots to represent an extra dimension. Finally, the view and lightning functions can be used in three-dimensional plots to change the camera position and light intensity. The next Figure exemplifies two camera and lighting configurations for the Ackley function. The example is generated by 1 2 3 4 5 6 7 8 9 10 11 auto ackley = []( double x , double y ) { return -20 * exp ( -0.2 * sqrt ( 0.5 * ( pow ( x , 2 ) + pow ( y , 2 )))) - exp ( 0.5 * ( cos ( 2 * pi * x ) + cos ( 2 * pi * y ))) + exp ( 1 ) + 20 ; }; subplot ( 1 , 2 , 0 ); fsurf ( ackley ) -> lighting ( true ). primary ( 0.7 ). specular ( 0.9 ); subplot ( 1 , 2 , 1 ); fsurf ( ackley ); rotate ( 20 , 30 ); Coding Styles Member vs. Free-standing Functions Like in Matplotlib, we support two coding styles: Free-standing functions and an Object-oriented interface. With free-standing functions, we call functions to create plots on the current axes. The global current axes object is the current axes object in the current figure in the global figure registry (Section Figures and Axes ). For instance, one can use plot(y); to create a line plot on the current axes (or create a new axes object if needed). Also, one can use plot(ax,y); to create a line plot on the axes object ax . This is less verbose for small projects and quick tests. The library looks for existing axes to create the plot. In the object-oriented interface, we explicitly create figures and call methods on them. For instance, one can use ax->plot(y); to plot on the axes object ax . We can create the same line plot on the current axes by auto ax = gca(); ax->plot(y); . This is less verbose and provides better control in large projects where we need to pass these objects around. The user manages axes handles containing plots. Assuming the user is explicitly managing the axes to create plots in another function, a more complete example of these styles could be 1 2 3 4 // Free-standing functions auto ax = gca (); plot ( ax , x , y ) -> color ( \"red\" ). line_width ( 2 ); my_function ( ax ); and 1 2 3 4 // Object-oriented interface auto ax = gca (); ax -> plot ( x , y ) -> color ( \"red\" ). line_width ( 2 ); my_function ( ax ); Both examples would generate the same plot. All free-standing functions are templated functions that use meta-programming to call the main function on the current axes object. If the first parameter is not an axes_handle , it will get an axes_handle from the figure registry with gca (Section Figures and Axes ) and forward all parameters to the function in this axes object. If the first parameter is an axes_handle , the template function will forward all parameters, but the first one, to this axes object. This use of templates for the free-standing functions keeps both coding styles maintainable by the developers. Note that, because the example needs the axes object for the function my_function , we also need to get a reference to the axes object with the free-standing functions. In that case, the free-standing functions are not less verbose than the object-oriented interface. To adhere to free-standing functions, we could create two versions of my_function : one that receives an axes_handle , and a second version that would get an axes_handle from the figure registry and call the first version. If my_function is going to be exposed to other users as a library, this could be a convenience to these users. However, notice that this is only moving the verbosity from the main function to my_function . In fact, this is how the free-standing functions in Matplot++ work. Reactive figures There are also two modes for figures: reactive (or interactive) mode and quiet mode. Figures in reactive mode are updated whenever any of their child objects change. This happens through the touch function, that gets called on any child object when it changes its appearance. This creates an interactive mode in which figures are updated as soon as we adjust their properties. If we combine interactive figures with free-standing functions, we have a \"Matlab-like style\" for plots. This is a coding pattern where the figure registry works as a stream for plots. The problem with this coding style is that the user might unnecessarily create useless intermediary plots. Figures in quiet mode are updated by calling the functions draw() or show() (Section Figures and Axes ). Unless these functions are called, nothing changes in the figure. The combination of the object-oriented coding style and quiet mode is the \"OO-Matplotlib-like style\" for plots. This is a coding style in which the user explicitly decides when the plot is shown or updated. This is beneficial to applications that cannot waste computational resources on intermediary figures that might not be valuable to the application. We generally use free-standing functions with reactive mode and the object-oriented interface with quiet mode. By default, new figures are in reactive mode, unless it is using an non-interactive backend. One can turn this reactive mode on and off with: ion() or ioff() free-standing functions reactive(bool) or quiet(bool) function on the figure object figure(true) or figure(false) when explicitly creating a new figure A more complete example of the reactive mode would be: 1 2 3 4 5 6 // Reactive mode auto f = gcf ( false ); auto ax = f -> gca (); auto p = ax -> plot ( ax , x , y ); // draws once p -> color ( \"red\" ). line_width ( 2 ); // draws twice more wait (); // pause console For convenience, the examples in Section Plot Categories use the reactive mode. The wait function pauses the console until the user interacts with the plot window. If the backend is based on process pipes, because these are unidirectional, closing the window is not enough to resume. The user needs to use the console to unblock execution. A similar example is quiet mode would be 1 2 3 4 5 6 // Quiet mode auto f = gcf ( true ); auto ax = f -> gca (); auto p = ax -> plot ( x , y ); // does not draw p -> color ( \"red\" ). line_width ( 2 ); // does not draw f -> show (); // draw only once and pause console In this example, the figure is only updated once. The user could replace the show function with the draw function, but the window would close as soon as execution completes. It is important to use wait() and show() with caution. These functions are meant for some particular executables so that an interactive plot does not close before the user can see it. It is probably unreasonable to call these functions inside a library because the user would have to manually interfere with the execution to continue. Method Chaining To support a more compact syntax, the library allows method chaining on plot objects. For instance, we can create a simple line plot and modify its appearance by 1 2 3 4 5 6 // Using the line handle auto p = plot ( x , y , \"--gs\" ); p -> line_width ( 2 ); p -> marker_size ( 10 ); p -> marker_color ( \"b\" ); p -> marker_face_color ({ .5 , .5 , .5 }); or 1 2 // Method chaining plot ( x , y , \"--gs\" ) -> line_width ( 2 ). marker_size ( 10 ). marker_color ( \"b\" ). marker_face_color ({ .5 , .5 , .5 }); The first code snippet works because plot returns a line_handle to the object in the axes . We can use this line handle to modify the line plot. Whenever we modify a property, the setter function calls touch , which will draw the figure again if it is in reactive mode. The second option works because setters return a reference to *this rather than void. Ranges The plotting functions work on any range of elements convertible to double . For instance, we can create a line plot from a set of elements by 1 2 set < int > y = { 6 , 3 , 8 , 2 , 5 }; plot ( y ); Any object that has the functions begin and end are considered iterable ranges. Most axes object subclasses use vector<double> or vector<vector<double>> to store their data. For convenience, the common.h header file includes the aliases vector_1d and vector_2d to these data types. These conversions also work on ranges of ranges: 1 2 3 vector < set < int >> Y = { { 6 , 3 , 8 , 2 , 5 }, { 6 , 3 , 5 , 8 , 2 } }; plot ( Y ); Unfortunately, because of how templated functions work, one exception is initializer lists. Initializer lists only work for functions that are explicitly defined for them. Utilities The headers common.h and colors.h include a number of utilities we use in our examples. These include naive functions to generate and manipulate vectors and strings; handle RGBA color arrays; convert points to and from polar coordinates; read files to strings; write strings to files; calculate gradients; read, write, and manipulate images; and generate vectors with random numbers. Although some of these functions might be helpful, most functions only operate on vector<double> and they are not intended to be a library of utilities. The sole purpose of these algorithms is to simplify the examples. Backend Interface While Matplot++ provides a shared representation for plots, there are innumerable technologies through which these objects can become interactive or non-interactive images. Users might want to export images, monitor metrics in real-time, or generate images for GUIs that might involve several libraries. It is unrealistic to anticipate the technologies involved in all applications that might benefit from Matplot++ . The only way to open these possibilities to users is by separating the implementation layers managing objects from the layers that generate the images for a given application. This enables users to reuse the Matplot+ + data structures in any application. For this reason, the figure object stores a shared pointer to a backend_interface that is responsible for ultimately drawing the plots. Libraries, such as Matplotlib, and languages with plotting capabilities, like Octave, usually have many backends for drawing objects, depending on the operating system and user demands. For interactive plots, these usually involve backends that are specific to the operating system. The backend_interface has many virtual functions that can be overridden to create new backends for these plots. The first set of functions in this interface are designed to identify the operation mode of a backend. The function is_interactive returns whether a backend is in interactive mode. Note that a backend can operate on both modes, depending on its parameters. For instance, a Gnuplot backend can work in interactive or non-interactive mode, depending on its terminal. Also, an OpenGL backend can work in non-interactive mode, in which case we would export its current pixels to an image file. The function output defines the output file name and file format for non-interactive plots. The next set of functions in the backend_interface are related to figure properties. These include functions to set or get the figure properties such as width, height, position, background color. The position is mostly relevant for interactive plots. Note that although we can set the image size through the figure object, the width and height properties are ultimately stored in the backend. The reason for this is that, in interactive plots, the user might manually move and resize the window, and the figure object has to respond accordingly. The last set of commands are related to drawing. In that regard, there are two types of backends. Some backends, like a Gnuplot backend, are based on commands and some backends, like an OpenGL backend, are based on vertices. We could try to recreate Gnuplot commands that would emulate a library based on vertices, but such a strategy would be wasteful. It would require the Gnuplot backends to find workarounds to bypass its default axes objects, manually recreate projections, and require the Gnuplot pipe to execute more commands than would be necessary for the plots. In that case, our preliminary solution has been to include interfaces for commands and vertices. If a backend is based on commands, functions such as run_command should be overridden to consume these commands. If a backend is based on vertices, functions such as draw_path and draw_image should be overridden to directly draw the specified vertices on the canvas. Because the library is in an embryonic stage regarding its available backends, the backend_interface is open for change as we identify new demands from backend developers. These extensions might involve more complex strategies for unifying the types of backends, internal algorithms for 3D graphical projections, or abstractions to draw different types of objects through the backend. Examples In this Section, we compare our interface with other similar libraries, provide examples integrating the library into some scientific applications, explain how unique plot categories can be defined, and discuss some limitations of the library. Interface Although the internal structure of Matplot++ is not the same as Matplotlib or the Matlab graphics functions, all interfaces are very similar. The comparable function names are mostly intended as a convenience to the transitioning user who is not concerned about specific internal details of the library. We cover almost all plot categories that exist in Matplotlib and Matlab. However, it seems like Matplotlib has no special plot category for networks. In Python, this can be solved with NetworkX. It is also important to note that Matlab has innumerable astounding toolboxes for various categories of problems and these toolboxes tend to include graphics for their specific domains. Matplot++ has neither the intention nor the capacity to compete in that domain. A Minimal Application Section Plot Categories previously included many examples that cover each plot category. The repository contains hundreds of examples that include all subcategories. Thus, it would be redundant to spend this Section with disconnected examples of more plot subcategories. Rather, in this Section we exemplify a use case where the user wants to integrate plots into a minimal application. This provides an opportunity to discuss how one can manage handles and apply the coding styles of Section Coding Styles in an application. In this example, let us suppose our data scientist is using the Travelling Salesman Problem (TSP) as a model to plan an Eurotrip. We can define the city names and their geographical positions: 1 2 3 vector < string > names = { \"Tirana\" , \"Andorra la Vella\" , \"Vienna\" /*, ...*/ }; vector < double > lat = { + 41.3317 , + 42.5075 , + 48.2092 /*,...*/ }; vector < double > lon = { + 19.8172 , + 1.5218 , + 16.3728 /*,...*/ }; The complete example, with 44 cities, is available in our repository. Because the axes object is going to be managed inside an application, we create a quiet figure and pass its only axes object to our object eurotrip_solver representing the application by 1 2 3 figure_handle f = figure ( true ); eurotrip_solver s ( lat , lon , names , f -> current_axes ()); s . run (); The eurotrip_solver has the following interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class eurotrip_solver { public : eurotrip_solver ( const vector < double >& lat , const vector < double >& lon , const vector < string >& names , axes_handle ax ); void run ( int iterations = 100 ); private : void setup_starting_point ( size_t iteration ); double tour_distance ( const vector < size_t >& tour ); void iteration (); static vector < vector < size_t >> get_neighbors ( const std :: vector < size_t >& tour ); bool update_if_better ( const vector < size_t > & neighbor ); void draw_if_improvement (); void draw (); private : vector < double > lat_ ; vector < double > lon_ ; vector < string > names_ ; axes_handle ax_ ; // Current tour double curr_dist_ { 0.0 }; vector < size_t > curr_tour_ ; // Best tour double min_dist_ { 0.0 }; vector < size_t > best_tour_ ; }; A note to programmers not familiar with C++ is that size_t is an unsigned integer type commonly used to represent sizes and indexes. The eurotrip_solver object includes a reference to an axes_handle and vector s with information about the cities. This is all the information we need to plot our map. The run function will generate a new starting tour curr_tour_ and run an iteration of the algorithm iterations times: 1 2 3 4 5 6 7 8 void eurotrip_solver :: run ( int iterations ) { for ( size_t i = 0 ; i < iterations ; ++ i ) { setup_starting_point ( i ); iteration (); } ax_ -> draw (); ax_ -> parent () -> save ( \"eurotrip.svg\" ); } The function setup_starting_point creates an initial tour with a greedy algorithm that uses the current iteration as seed for its starting point. This is meant to generate a different starting point for each iteration. The iteration function runs a local search algorithm on that starting point. It visits all neighbors of curr_tour_ and stores any neighbors that happen to be better than best_tour_ . Whenever we find a better solution, the iteration function calls the draw function: 1 2 3 4 5 6 7 8 9 10 11 12 13 void eurotrip_solver :: iteration () { bool improvement = true ; while ( improvement ) { improvement = false ; for ( const auto & neighbor : get_neighbors ( curr_tour_ )) { improvement = update_if_better ( neighbor ); draw_if_improvement (); if ( improvement ) { break ; } } } } While calling a get_neighbors(curr_tour_) to pre-calculate all neighbors is certainly not an efficient solution, it is an abstraction that serves this example well by abstracting away unnecessary details of the search algorithm. The function update_if_better will update curr_tour_ and best_tour_ if the neighbor solution happens to be better than any of them. The draw_if_improvement function will only call the draw if there has been some improvement on the best solution. We also use this opportunity to check the last time we called draw and skip the function call if the frame rate happens to be higher than necessary. This is useful in this sort of algorithm to make sure we do not spend more time plotting than searching for solutions. 1 2 3 4 5 6 7 8 9 10 11 12 13 void eurotrip_solver :: draw_if_improvement () { static auto last_draw = chrono :: high_resolution_clock :: now () - chrono :: seconds ( 1 ); static auto min_dist_when_last_draw = min_dist_ ; const auto current_time = chrono :: high_resolution_clock :: now (); const bool its_been_a_while = current_time - last_draw > chrono :: seconds ( 1 ); const bool things_are_better = min_dist_ < min_dist_when_last_draw ; if ( its_been_a_while && things_are_better ) { last_draw = current_time ; min_dist_when_last_draw = min_dist_ ; draw (); } } Finally, the draw function uses our axes_handle to update the figure whenever we find a better solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void eurotrip_solver :: draw () { ax_ -> clear (); ax_ -> geolimits ( min ( lat_ ) -5 , max ( lat_ ) + 5 , min ( lon_ ) -2 , max ( lon_ ) + 10 ); vector < double > sorted_lat ; vector < double > sorted_lon ; for ( const int & idx : best_tour_ ) { sorted_lat . emplace_back ( lat_ [ idx ]); sorted_lon . emplace_back ( lon_ [ idx ]); } sorted_lat . emplace_back ( lat_ [ best_tour_ [ 0 ]]); sorted_lon . emplace_back ( lon_ [ best_tour_ [ 0 ]]); ax_ -> geoplot ( sorted_lat , sorted_lon ); ax_ -> hold ( true ); ax_ -> geoscatter ( lat_ , lon_ ); auto [ lon_c , lat_c , names_c ] = clear_overlapping_labels ( lon_ , lat_ , names_ , 1 , 1 ); ax_ -> text ( lon_c , lat_c , names_c ); ax_ -> title ( \"Tour distance \" + num2str ( min_dist_ )); ax_ -> draw (); } Because we are moving the handles around, we use the object-oriented coding style. The geolimits function will adjust the map limits around Europe. The draw function will then create a line going through the cities according to the order indicated by the current best tour. The geoscatter function does not need the cities to be in order because it plots no lines. The text function creates an annotation on top of the map with the city names. The function clear_overlapping_labels is an auxiliary function to remove overlapping labels from the map. The title function creates a title with the current distance. Because the figure is in quiet mode, we need to call the draw function. In this case, the quiet mode avoided rendering the figure five times with unnecessary intermediary plots. Besides interactively showing intermediary results during the algorithm execution, the run function also saves the figure to a vector graphics, that is appropriate for printing the results at any size. The save function will temporarily and transparently change the figure backend to a non-interactive backend for Scalable Vector Graphics (SVG) and draw the figure to an output file. The following Figure shows the final image. Applications Managing Plot Handles Notice in the previous example that we only keep a handle for the axes object in our application. Every time we call the draw() function, we clear the axes object and recreate its plots. For instance, this algorithm is recalculating the same geolimits every time we update the plot. In this Section, we examine a more high-level use case where we cache handles to the axes object and its plots to update the figure more efficiently. Whenever we find a better solution, we only update the plots instead of recreating them on the axes object. To differentiate the example, we consider the Americas for this example 1 2 3 vector < string > names = { \"Marigot\" , \"The Valley\" , \"Saint John's\" /*,...*/ }; vector < double > lat = { 18.0731 , 18.2166 , 17.1166 /*,...*/ }; vector < double > lon = { -63.0822 , -63.0500 , -61.8500 /*,...*/ }; The americas_trip_solver now has two extra-members in its interface: 1 2 3 4 5 6 7 class americas_trip_solver { // ... private : void setup_axes (); // ... line_handle lh_ ; }; The extra handle to the line plot inside the axes object allows us to only modify the data in that plot instead of recreating all the plots. The code that was previously in draw will now be split between draw and setup_axes . We plot almost everything in the setup_axes function: 1 2 3 4 5 6 7 8 9 10 void americas_trip_solver :: setup_axes () { ax_ -> clear (); ax_ -> geolimits ( min ( lat_ ) -5 , max ( lat_ ) + 5 , min ( lon_ ) -30 , max ( lon_ ) + 50 ); lh_ = ax_ -> geoplot ( lat_ , lon_ ); ax_ -> hold ( true ); ax_ -> geoscatter ( lat_ , lon_ ); auto [ lon_c , lat_c , names_c ] = clear_overlapping_labels ( lon_ , lat_ , names_ , 2 , 2 ); ax_ -> text ( lon_c , lat_c , names_c ); ax_ -> draw (); } Notice that we do not need to recreate the map, the scatter points, or the text annotation when drawing the plot. When plotting the route, we keep a handle to the line object in lh_ . This is the only element we need to update when drawing the plot with a new route. Thus, the draw function is simplified to 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void americas_trip_solver :: draw () { vector < double > sorted_lat ; vector < double > sorted_lon ; for ( const int & idx : best_tour_ ) { sorted_lat . emplace_back ( lat_ [ idx ]); sorted_lon . emplace_back ( lon_ [ idx ]); } sorted_lat . emplace_back ( lat_ [ best_tour_ [ 0 ]]); sorted_lon . emplace_back ( lon_ [ best_tour_ [ 0 ]]); lh_ -> x_data ( sorted_lon ); lh_ -> y_data ( sorted_lat ); ax_ -> title ( \"Tour distance \" + num2str ( min_dist_ )); ax_ -> draw (); } The function is only responsible for creating a different line with the current route and updating the title. This significantly simplifies the process of refreshing the figure. All other axes children stay as they are. The rest of the americas_trip_solver class remains the same as eurotrip_solver . The following Figure displays the final image for this example. With the examples from Section Plot Categories , the example from Section minimal_application and this Section should demonstrate how Matplot++ can work at various levels of complexity and abstraction. Section minimal_application exemplified Matplot++ as a solution for users who want to create simple plots for experiments, while this Section exemplifies a more complex application that requires more efficient interactive plots. Although more complicated, the library architecture also allows tighter integration with GUIs with the development of backends that are specific to the domain of a GUI library. Exporting Figures Some previous examples involved the save function. There are two ways to save figures: manually and programmatically. The interactive plot window has a widget to save the current figure. Because this widget uses the same backend as the one used to produce the interactive image, the final image matches closely what the user sees in the window. The user can also programatically save the figure in a number of formats with the save function: 1 save ( filename ); or 1 save ( filename , fileformat ); The first option infers the appropriate file format from the filename extension. In both cases, this function temporarily changes the backend to a non-interactive backend appropriate to draw the figure. A different backend is used for each format and, depending on the format, the final image does not necessarily match what is on the interactive plot window. The reason is that some file formats purposefully do not include the same features. For instance, consider the bar chart generated by 1 2 vector < double > x = { 29 , 17 , 14 , 13 , 12 , 4 , 11 }; bar ( x ); If we export the image with 1 save ( \"barchart.svg\" ); we get the vector graphics Exporting the image with 1 save ( \"barchart.txt\" ); generates a representation of the image appropriate for text or markdown files, such as 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 30 +-----------------------------------------------------------+ | ******* + + + + + + | | * * | 25 |-+ * * +-| | * * | | * * | 20 |-+ * * +-| | * * | | * ******** | 15 |-+ * ** * +-| | * ** * ******* | | * ** * * ******** ******* | | * ** * * ** * * * ******* | 10 |-+ * ** * * ** * * * * * +-| | * ** * * ** * * * * * | | * ** * * ** * * * * * | 5 |-+ * ** * * ** * * ******** * * +-| | * ** * * ** * * ** * * * | | * + ** + * * + ** + * * + ** + * * + * | 0 +-----------------------------------------------------------+ 1 2 3 4 5 6 7 As the last example, saving an image with 1 save ( \"barchart.tex\" ); would save the image in a format appropriate to embed in latex documents, such as This exports the image in a format in which the labels are replaced by latex text so that the plot fits the rest of the document. Creating new plot types There are two options for creating new plot styles: concatenating the existing plotting styles or creating a class that inherits from axes object . The first is probably enough for most cases because there are already many primitives that can form new plot types. In fact, most plot types discussed in Section Plot Categories are combinations of axes object subcategories rather than different primitives. Creating a new class that inherits from axes object is only necessary if we are working on a new plot category that needs to manage its own pre-processed data, like networks, contours, and histograms. Note that, if it were not for the algorithms involved in these types of plots, we could comfortably replace networks, contours, and histograms by a combination of scatter plots, line plots, filled polygons, and bar plots. To create a new class inheriting from axes object , the user needs to override several virtual functions. Although the exact function types might slightly change between library versions, these functions should return the object boundaries in each axis (so that the axes object knows how to adjust automatic axis objects); return the valid object coordinates (two-dimensional, three-dimensional, or polar); consume labels from the legend object; and return an optional tag that describes the plot category. Backends The repository includes a directory for complete backends and backends that exemplify how we can integrate other technologies with Matplot++ . As usual in many C++ plotting libraries (Section Alternatives for Data Visualization in C++ ), this library offers a complete backend that uses pipes to Gnuplot processes as backends. Each Gnuplot output format represents a possible backend in Matplot++ . That was also the approach in the early versions of Octave, which now provides an additional backend based on OpenGL. The main advantage of a default Gnuplot backend at this point is that it can work in interactive and non-interactive mode. Its various auxiliary terminals can be used as additional non-interactive backends to export plots to a variety of useful formats that would be impossible otherwise, such as the SVG and latex file formats examined in Section Exporting Data . The second benefit of Gnuplot is that it allows us to abstract away technologies that are specific to each operating system. Without Gnuplot, these features would only be possible through a large number of other backends. For this reason, we currently make this our default backend. Although we use Gnuplot as a default backend, this is transparent to the user and we attempt to limit the internal rendering functions to its most primitive methods, as in the subclasses of axes object described in Section Plot Categories . For instance, the library can independently calculate its contours, interpolations, automatic axis ticks, parallel axes, and histograms without recurring to the backend. This constraint on plotting primitives is intended to make it more straightforward to implement other backends we might need in the future. These new backends could be implemented in a Dear ImGui backend style, where the library is only responsible for creating plots for a rendering engine that has a render loop running on the main thread. The main difference in such an architecture is that Gnuplot expects commands rather than vertices. This is probably the case with other potential backends, such as non-interactive backends for exporting plots to image files. As an example, the repository also includes an instance of a backend implementation that uses OpenGL. The main drawback of Gnuplot as a default backend is that it depends on process pipes. Since a pipe is by definition unidirectional, the constrains some features we could have in interactive plots, such as: Parameters will come from the figure object and not from the interactive window. This means plots are not as responsive as they could when moving and resizing windows. For this reason, it is always best to programmatically set the window size on the figure object rather than manually changing it, especially when you intend to save the image programmatically. There is no straightforward way to query the exact word positions in Word Clouds (Section Data Distribution ). This means the algorithm to generate clouds needs to estimate where the words are. This makes word clouds very sensitive to the backend. When saving a word cloud, it's best to save it non-programmatically. The interactive features of Gnuplot, like rotating three-dimensional plots, do not work well with subplots. Gnuplot pipes impose extra requirements on the backend interface (Section Backend Interface ). The illustrative backends in our repository demonstrate that other backends could make it possible for plots to be more interactive in these regards. For instance, a backend based on OpenGL might offer much more control over interactive plots. However, these backends can have drawbacks that make them less appropriate as a default backend at this point. For instance, in some operating systems, OpenGL can only run on the main thread. One solution to this problem would be to defer plotting to another process. However, this would make the OpenGL backend very similar to the default Gnuplot pipe. The process of sending data to another process could be inefficient or depend on interprocess communication strategies for the operating system that could more complex than the backend. A second alternative to this problem is to create a backend that would always work on a secondary thread. OpenGL would block the main thread with its render loop and Matplot++ would create plots for this main application. In this sense, Matplotlib++ would work like backends for Dear ImGui. Although such a backend could be useful to many applications, that makes is less of a library for accessible data visualization and more like a widget for GUIs. Although most costly in terms of development, a more reliable strategy would be for developers to solve these problems with native backends targeted at specific operating systems. Because this imposes a high development cost, these backends should appear over time, as the demand for each of these backends grows. Note that all this discussion does not even include non-interactive backends. Users might need to handle technologies specific to the operating system, integrate plots into an existing GUI, display their plots on a web page through WebGL, export images for scientific papers, or stream their plots to the console. As discussed in Section Backend Interface , there are too many possibilities and use cases for data visualization, and that is precisely the rationale for the backend interface. What is most important is that the implementation layer is open for more advanced users to adapt the library to their needs. Performance We are incrementally improving the code for performance and avoid any counter-productive coding patterns. The axes objects that depend on expensive calculations all use lazy evaluation to avoid calculating data for unnecessary plots. Having said that, Matplot++ concentrates intensively on the design goals described in Section Data Visualization : interactive plotting, high-quality exporting tools, and productivity. The rationale is that, for now, most applications of interest are environments where plotting is inexpensive compared to the processes we are monitoring. Conclusion The paper presented Matplot++ , an alternative for data visualization in C++. Aiming at scientific computing, the design goals of Matplot++ are interactive plotting, high-quality exporting tools, and simplicity. The library allows users to create sophisticated plots with a compact syntax. This enables programmers to monitor metrics and scientists to create high-quality figures for publications. Current work includes continuous performance gains, further specialized backends for multiple operating systems, and increasing support for more types of backends in the present plot categories. References Abadi M, Barham P, Chen J, Chen Z, Davis A, Dean J, Devin M, Ghemawat S, Irving G,Isard M,et al.(2016). \"Tensorflow: A system for large-scale machine learning.\" In 12th USENIX symposium on operating systems design and implementation (OSDI 16), pp.265-283. Angerson E, Bai Z, Dongarra J, Greenbaum A, McKenney A, Du Croz J, Hammarling S,Demmel J, Bischof C, Sorensen D (1990). \"LAPACK: A portable linear algebra library for high-performance computers.\" In Supercomputing'90: Proceedings of the 1990 ACM/IEEE Conference on Supercomputing, pp. 2-11. IEEE. Antcheva I, Ballintijn M, Bellenot B, Biskup M, Brun R, Buncic N, Canal P, Casadei D, CouetO, Fine V, et al.(2011). \"ROOT-A C++ framework for petabyte data storage, statistical analysis and visualization.\"Computer Physics Communications,182(6), 1384-1385. Baratov R (2019). Hunter. URL: https://hunter.readthedocs.io . Barrett P, Hunter J, Miller JT, Hsu JC, Greenfield P (2005). \"matplotlib-A Portable Python Plotting Package.\" In Astronomical data analysis software and systems XIV, volume 347,p. 91. Bezanson J, Edelman A, Karpinski S, Shah VB (2017). \"Julia: A fresh approach to numerical computing. \"SIAM review,59(1), 65-98. CEGUI Team (2020). CEGUI. URL: http://cegui.org.uk . Cornut O (2020). Dear ImGui: Bloat-free Immediate Mode Graphical User Interface for C++ with minimal dependencies. URL: https://github.com/ocornut/imgui . de Guzman J (2020). Elements. URL: http://cycfi.github.io/elements/ . Eichhammer E (2020). QCustomPlot. URL: https://www.qcustomplot.com . Evers B (2019). Matplotlib-cpp. URL: https://github.com/lava/matplotlib-cpp . Freitas A (2020). Pareto Front Library. URL: https://github.com/alandefreitas/pareto-front . Frigo M, Johnson SG (1998). \"FFTW: An adaptive software architecture for the FFT.\" In Proceedings of the 1998 IEEE International Conference on Acoustics, Speech and Signal Processing, ICASSP'98 (Cat. No. 98CH36181), volume 3, pp. 1381-1384. IEEE. Fruchterman TM, Reingold EM (1991). \"Graph drawing by force-directed placement. \"Software: Practice and experience, 21(11), 1129-1164. GNU Project (2020). GNU Octave: Introduction to Plotting. URL: https://octave.org/doc/v4.2.2/Introduction-to-Plotting.html . Guy Eric Schalnat Andreas Dilger GRP (2020). Libpng. URL: https://sourceforge.net/p/libpng/ . Hao J (2020). Nana. URL: http://nanapro.org/ . Hunter JD (2007). \"Matplotlib: A 2D graphics environment. \"Computing in Science & Engineering, 9(3), 90-95. doi:10.1109/MCSE.2007.55. Idea4good (2020). GuiLite. URL: https://github.com/idea4good/GuiLite . ImageMagick Studio LLC (2020). Magick++. URL: https://imagemagick.org/Magick++/ . Independent JPEG Group (2020). Libjpeg. URL: http://libjpeg.sourceforge.net . Intel Corporation, Willow Garage I (2020). Open Source Computer Vision Library (OpenCV). URL: https://opencv.org/ . Jakob W (2017). PyBind11. URL: https://pybind11.readthedocs.io/en/stable/ . Kagstrom B LP, C VL (2020). Basic Linear Algebra Subprograms (BLAS). URL: http://www.netlib.org/blas/ . Kainz F, Bogart R, Hess D (2003). \"The OpenEXR image file format.\"SIGGRAPH TechnicalSketches. Kamada T, Kawai S,et al.(1989). \"An algorithm for drawing general undirected graphs.\"Information processing letters,31(1), 7-15. Loup Gailly J, Adler M (2020). Zlib. URL: https://github.com/madler/zlib . Martin K, Hoffman B (2010). Mastering CMake: a cross-platform build system. Kitware. McKinney W,et al.(2011). \"Pandas: a foundational Python library for data analysis and statistics. \"Python for High Performance and Scientific Computing, 14(9). Conan.io (2020). Conan. URL: https://conan.io . Melchior L (2020). CPM.cmake. URL: https://github.com/TheLartians/CPM.cmake . Murray Cumming DE (2020). Gtkmm. URL: https://www.gtkmm.org/ . Natural Earth (2018). \"Natural earth. Free vector and raster map data.\" URL: http://www.naturalearthdata.com/downloads/ . NetworkX developers (2020). NetworkX. URL: https://networkx.github.io . Olivier Birot (2020). nodesoup. URL: https://github.com/olvb/nodesoup . Pezent E (2020). ImPlot. URL: https://github.com/epezent/implot . Sam Leffler SG (2020). Libtiff. URL: https://gitlab.com/libtiff/libtiff . Schaling B (2011). The boost C++ libraries. Boris Schaling. Spitzak B, et al.(2004). \"Fast Light Toolkit (FLTK).\" FTLK: Fast light toolkit. Available: http://www.fltk.org/ Stahlke D (2020). Gnuplot-Iostream. URL: http://stahlke.org/dan/gnuplot-iostream/ . Storer J (2020). JUCE. URL: https://juce.com . Terra Informatica Software, Inc (2020). Sciter. URL: https://sciter.com . The FLTK Team (2020). FLTK. URL: https://www.fltk.org . The MathWorks, Inc (2020). MatlabGraphics. URL: https://www.mathworks.com/help/matlab/graphics.html . The Qt Company (2020). Qt. URL: https://www.qt.io . Tschumperle D (2020). CImg. URL: http://cimg.eu . van der Zijp J (2020). Fox toolkit. URL: http://fox-toolkit.org . Vasilev V, Canal P, Naumann A, Russo P (2012). \"Cling-the new interactive interpreter for root 6.\" In Journal of Physics: Conference Series, volume 396, p. 052071. Walt Svd, Colbert SC, Varoquaux G (2011). \"The NumPy array: a structure for efficient numerical computation.\" Computing in science & engineering,13(2), 22-30. Wei V (2020). MiniGUI. URL: http://www.minigui.com . Williams T, Kelley C, Bersch C, Broker HB, Campbell J, Cunningham R, Denholm D, Elber G, Fearick R, Grammes C,et al.(2017). \"gnuplot 5.2.\" wxWidgets (2020). WxWidgets. URL: https://wxwidgets.org . XOrg Foundation (2020). X11. URL: https://www.x.org/ . Zaitsev S (2020). Webview. URL: https://github.com/zserge/webview . Zakai A (2011). \"Emscripten: an LLVM-to-JavaScript compiler.\" In Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion, pp. 301-312.","title":"White Paper"},{"location":"white-paper/#matplot-a-c-graphics-library-for-data-visualization","text":"Data visualization can help programmers and scientists identify trends in their data and efficiently communicate these results with their peers. Modern C++ is being used for a variety of scientific applications, and this environment can benefit considerably from graphics libraries that attend the typical design goals toward scientific data visualization. Besides the option of exporting results to other environments, the customary alternatives in C++ are either non-dedicated libraries that depend on existing user interfaces or bindings to other languages. Matplot++ is a graphics library for data visualization that provides interactive plotting, means for exporting plots in high-quality formats for scientific publications, a compact syntax consistent with similar libraries, dozens of plot categories with specialized algorithms, multiple coding styles, and supports generic backends.","title":"Matplot++: A C++ Graphics Library for Data Visualization"},{"location":"white-paper/#table-of-contents","text":"Introduction Data Visualization in C++ Data Visualization Scientific Computing in C++ Alternatives for Data Visualization in C++ Bindings Exporting Data Plotting widgets Gnuplot Pipes The Matplot library Figures and Axes Plot Categories Line Plots Data Distribution Discrete Data Geography Polar Plots Contour Plots Vector Fields Surfaces Graphs Images Annotations Appearance Coding Styles Member vs. Free-standing Functions Reactive figures Method Chaining Ranges Utilities Backend Interface Examples Interface A Minimal Application Applications Managing Plot Handles Exporting Figures Creating new plot types Backends Performance Conclusion References","title":"Table of Contents"},{"location":"white-paper/#introduction","text":"Data visualization is fundamental to scientific computing and metrics-driven development. Programmers can use interactive plotting to monitor their quality metrics more efficiently. Scientists rely on these tools to export their graphics in high-quality formats for scientific writings. The process of generating these graphics cannot be more expensive in terms of development time than the resources spent on the main problem at hand (Section Data Visualization ). While C++ has been valuable for a variety of scientific problems (Section Scientific Computing in C++ ), there is currently no alternative for data visualization that attends the design goals we habitually expect from scientific libraries (Section Alternatives for Data Visualization in C++ ). For this reason, this article presents Matplot++ (Section The Matplot++ Library ), a graphics library for data visualization in C++. The library maintains a high-level hierarchical structure to manage plots the user can create transparently with single function calls. The main library objects represent figures and axes that can hierarchically store child objects that can collectively represent plots in many categories (Section Figures and Axes ). Each plot category includes algorithms to solve numerous hurdles demanded in data visualization (Section Plot Categories ). For instance, producing plots might involve calculating multi-dimensional histogram bins, generating word clouds, efficiently cropping maps, converting data between coordinate systems, identifying contour lines, producing network layouts, and applying filters to images. Like present libraries for different programming languages, Matplot++ allows flexible coding styles (Section Coding Styles ). The user can choose between object-oriented programming or free-standing functions (Section Member vs. Free-Standing Functions ), reactive or quiet figures (Section Reactive Figures ), method chaining or smart pointers to adjust plot properties (Section Method Chaining ), and use any convertible range data type as input for the algorithms (Section Ranges ). Matplot++ also includes simple convenience functions to manipulate data (Section Utilities ) and the backend interface makes it viable to use Matplot++ in countless contexts (Section Backend Interface ). In Section Examples , we examine how Matplot++ relates to other comparable libraries and environments by addressing its interface (Section Interface ), provide extra examples of intricate integration into existent applications (Sections Minimal Application and Applications Managing Plot Handles ), illustrate the results for varying image formats (Sections Exporting Data ), and consider more high-level practices, like conceiving novel plot categories (Section Creating New Plot Categories ) and backends for unique environments (Section Backends ).","title":"Introduction"},{"location":"white-paper/#data-visualization-in-c","text":"","title":"Data Visualization in C++"},{"location":"white-paper/#data-visualization","text":"Data visualization can help us promptly recognize trends in data. It is an indispensable means to interpret large volumes of data and to watch high-performance applications. Besides tests and benchmarks, data visualization also enables programmers to benefit more effectively from metrics-driven development. These metrics are particularly critical for high-performance computing, where unit tests can only identify bugs in scenarios we know about. Also, benchmarks cannot ordinarily identify bottlenecks for code optimization that replicate the production environment and its edge cases. It is ineffective to work to improve systems without proper instruments to measure their performance. For these purposes, tools for data experts usually incorporate functions for graphics. The design goals of these libraries tend to revolve around three aims: Interactive plotting: plots usually comprise reactive objects that get refreshed as soon as the figure attributes change. These reactive objects are valuable for monitoring systems in real-time. Exporting tools: libraries should have the means to export images in high-quality formats to communicate results in scientific writings. Productivity: the interface should incorporate commands to instantly produce the most well-known varieties of plots with a single function call. Additional commands should be required solely to attach supplementary plots to a figure or to customize plot features. Programmers should not spend substantial development time to produce plots. The development cost of including plots should be near zero. Matplotlib had the philosophy that it should take as few commands as possible to generate a plot. If feasible, that would be only one command. For instance, one should be able to create a line plot from x and y by 1 plt . plot ( x , y ) The Matlab environment embeds one of these graphic libraries. It incorporates a comfortable interface to interactively update plots and generate high-quality graphics for publications. Since then, this is one of the peculiarities that made Matlab a highly valuable environment for data analysis. Many scientists and programmers export their data to Matlab to adopt it as a mechanism for generating publication-quality images. Likewise, Octave incorporates a similar syntax for the equivalent kinds of graphics. The earliest versions of Octave used Gnuplot as a backend for its graphics. Since then, it has transitioned to a backend based on FLTK. Julia is yet another programming language that combines data visualization as part of its standard libraries. Meanwhile, Python has increasingly matured as a powerful means for data analysis, with libraries such as Pandas and Numpy. Python provides a compromise between abstraction and performance by transparently integrating high-performance compiled code. In this context, Matplotlib became a dominant tool that satisfied the demand for a Python graphics library. Matplotlib has a syntax comparable to the Matlab graphics library, which simplifies the transition from Matlab to Python for data scientists. Matplotlib incorporates functions to plot anything directly on an Axes object. Differently from Matlab, though, Matplotlib supports two coding styles. The first coding style uses the object-oriented class methods while the second is a wrapper around these objects to make the plots available as free-standing functions. The object-oriented style is more natural to Python programmers. Given an Axes object ax , one can create a line plot from x and y by 1 ax -> plot ( x , y ) The second coding style is designed to emulate the Matlab environment for transitioning users. In the first versions of Matplotlib, barrett2005matplotlib had a major express plan to conceive an interface as similar as possible to Matlab.","title":"Data Visualization"},{"location":"white-paper/#scientific-computing-in-c","text":"Since C++11, often referred to as Modern C++, C++ has become a very useful language for scientific computing. Features such as functional programming, type inference, constant expressions, structured binding declarations, ranges, concepts, smart pointers, variant types, and move semantics enabled C++ to catch up with most high-level programming languages. At the same time, C++ was capable of implementing these innovations without dropping its zero-overhead principle, which makes high-performance code expedient. There are several compelling reasons to use C++ in scientific computing: Performance: scientific applications that rely on approximations through iterative heuristics tend to benefit the greatest from C++. Numeric libraries: there are many reliable numeric libraries available for C++. Integration: it is accessible to integrate C++ libraries into other languages and tools. Licenses: there is no necessity of special licenses, like in Matlab Bindings: one can always call their C++ code from Python, Matlab, or R, for instance. Distribution: if you intend to distribute your compiled code, high-performance machine code circumvents the necessity of creating prototypes in one programming language and then repeating all the work once your experiments are successful. In parallel with the rising notoriety of Python, it has also become very prevalent the address the most computationally expensive pieces of a Python project in C++. A representative illustration of this strategy is the TensorFlow library. Modern libraries, such as PyBind11, expedite the generation of bindings connecting the two languages, making it easy for C++ programmers to provide performance to libraries in other programming languages. Although the C++ compilation process is how it accomplishes its performance, it might be oftentimes inconvenient to data scientists, who want to smoothly experiment with data more dynamically. An intermediary solution in this regard is CERN's ROOT data analysis framework, which provides Cling, a C++ interpreter. Another option to alleviate this obstacle is to maintain smaller shared libraries with a build tool, which makes the compilation process greatly faster. The absence of a cross-platform building system used to be a limitation of C++ over other languages for scientific computing. However, various recent C++ projects are based on CMake, which is a set of tools for building platform and compiler independent software. With the broad adoption of CMake, projects can be easily rebuilt on different platforms. By combining CMake and Emscripten, zakai2011emscripten makes it possible to even run high-performance C++ on the web with near-native speed. Some popular IDEs, such as CLion and Cevelop, use CMake as a standard format for its C++ projects. Package-management systems are likewise a relevant component of scientific programming, as it allows programmers to quickly experiment with combinations of algorithms. The typical solution to share libraries in C++ used to be header-only libraries, which do not need to be separately compiled. Most packages in the Boost libraries are header-only and work well with the C++ standard library. However, header-only libraries lead to longer compilation times and large libraries, such as Boost, might include too many unnecessary dependencies in our projects. An alternative to header-only libraries has been incorporated into CMake. CMake introduces commands such as ExternalProject and FetchContent to add custom targets to a project. These commands can download subprojects from usual URLs or Git repositories. If the external project is header-only or also based on CMake, the integration is particularly straightforward. Some packages, such as CPM.cmake, extend these features to provide light dependency management to C++ projects. Other packages, such as Conan and Hunter, provide more elaborate package managers. Finally, C++20 offers a feature for modules, which overcome the constraints of header files and make it more accessible to provide packages to existing projects. The standard library in Modern C++ offers many data structures based on templates with minimal computational overhead. This is an extra opportunity for data scientists to optimize their code in styles that are impractical in more simplistic high-level languages. For instance, while Matlab is extremely comfortable for matrix operations, it might become quite inconvenient for projects whose performance depends profoundly on more distinct data structures. There are innumerable C++ libraries for Graphical User Interfaces (GUIs) and low-level High-Performance Graphics. However, in a context where C++ is becoming increasingly more suitable to scientific applications, programmers must have access to libraries for accessible data visualization, for the very same purposes discussed in Section Data Visualization .","title":"Scientific Computing in C++"},{"location":"white-paper/#alternatives-for-data-visualization-in-c","text":"","title":"Alternatives for Data Visualization in C++"},{"location":"white-paper/#bindings","text":"One possibility is to use bindings to libraries meant for other high-level languages, such as Matplotlib. One such solution is matplotlib-cpp. These bindings create a convenient environment without too much effort on the user side. For instance, one can produce a line plot in matplotlib-cpp by 1 plt :: plot ( x , y ); However, these bindings (i) might create the necessity of large extra dependencies in our project, (ii) could partially eliminate the performance advantages for which developers are likely to have transitioned to C++, (iii) has an integration cost that affects the productivity design goal discussed in Section Data Visualization , (iv) would make integration with native GUIs tough or even impracticable in some circumstances, (v) rely on the maintainers to catch up with the primary package, and (vi) are invariably restricted by the features of the original library. In these situations, depending on the complexity of the project and how much the programmers need data visualization, a more suitable possibility might be to leave the C++ environment entirely, which might be proper to some projects but, as argued in Section Scientific Computing in C++ , could deny programmers of gains C++ can offer to many high-performance projects.","title":"Bindings"},{"location":"white-paper/#exporting-data","text":"A customary solution among C++ programmers is to export the data from a C++ application in a common format to other environments. The most informal format for exporting data is probably files with Comma-Separated Values (CSV). Excel, Gnuplot, Matlab, or Python can effortlessly import these files. The benefit of this strategy is that programmers can use other mechanisms to produce high-quality plots that are suitable for scientific publications while bypassing the nuisance of learning, integrating, or even implementing a native library. However, this hand-operated method is very unproductive in terms of development cost. Data visualization cannot occur interactively, so the user cannot watch the relevant metrics in real-time. This makes the development cycle longer since various failures cannot be recognized until all experiments are finished. If we avoid this manual process by programmatically exporting and importing the data in real-time to the secondary environment, we can get quasi-interactive plots. However, this requires a significantly higher development cost that could be better employed on the main project. Besides, if plots are refreshed very frequently, this would be comparable to a cumbersome and wasteful implementation of bindings, inheriting all their difficulties discussed in Section Bindings .","title":"Exporting Data"},{"location":"white-paper/#plotting-widgets","text":"There are innumerable libraries for GUIs in C++. Some representative examples are Qt, wxWidgets, Dear ImGui, Webview, Nana, gtkmm, FLTK, JUCE, Fox toolkit, CEGUI, Sciter, MiniGUI, GuiLite, and Elements. GUI libraries in other programming languages are often bindings to these libraries. There are usually plotting widgets for these libraries. For instance, Qt has its objects for Charts. Libraries such as QCustomPlot can further extend these functionalities. Dear ImGui also incorporates objects for simplistic line plots and histograms. ImPlot provides additional objects for shaded plots, scatter plots, bar graphs, error bars, pie charts, and heatmaps. Some different libraries, like Webview, can take full advantage of any other plotting libraries for HTML. Despite being normally quite restricted in their functionalities, plotting widgets for GUI libraries have many advantages. Once a project has settled on a GUI library for the application, these plotting widgets are appropriate for incorporating supplemental plots into graphical interfaces. They enable interactive plots that communicate excellently with the main application and the final user. However, these are not suited for prototyping or scientific computing. If the programmer has not already engaged to a given GUI library for the project, including these libraries merely for producing plots to observe data might be more costly in terms of development time than the main application. This is particularly true for the initial stages of scientific applications where there is regularly no need for a user interface at all. However, in high-performance computing, these early stages of prototypes might be when we demand data visualization the most. This defeats the productivity criterion discussed in Section Data Visualization . A second obstacle with these widgets is that are usually not meant to produce high-quality graphics for scientific publications. This makes it more troublesome to communicate results.","title":"Plotting widgets"},{"location":"white-paper/#gnuplot-pipes","text":"A popular solution for plots in C++ is to create a pipe to a process running Gnuplot through direct commands. Gnuplot-Iostream implements an istream object that can communicate programmatically with Gnuplot. The chief benefit of this procedure is that we can interactively manage Gnuplot without multiple dependencies. Besides the general weaknesses of bindings (Section Bindings ), process pipes to Gnuplot require programmers to compose functions that form strings with the source code to create a given plot in Gnuplot. The user needs to study a different language for plots and this might involve an extensive number of commands even for uncomplicated line plots, which does not make plotting as smooth as expected from data visualization libraries.","title":"Gnuplot Pipes"},{"location":"white-paper/#the-matplot-library","text":"This article presents the Matplot++ library, a native object-oriented library for data visualization in C++. Objects are organized in a hierarchical structure where parent objects recursively render themselves and their child objects. Meanwhile, users can stream data to these objects with short commands that update these elements to create plots in many representative categories. The follow diagram summarizes the main classes in Matplot++ . The figure object is the object the ultimately connects to a backend. This might be a backend to render interactive plots or to export graphics to a file. A figure object might have multiple plots represented by axes objects. Each axes object has eight axis objects. For inexperienced users, the most critical of these axis objects are the ones for the coordinates \\(x\\) , \\(y\\) , and \\(z\\) . We discuss these objects in more detail in Section Figures and Axes . An axes object is an abstract class that can hold a collection of primitives representing plots. These are the objects that ultimately embody the plot categories. We list these categories in Section Plot Categories . Lastly, a legend object is responsible for storing a list of labels we can associate to each axes object , and the appearance of the box where we present these labels. For convenience, the library interface has a syntax similar to Matplotlib and Matlab. This is helpful to accommodate users transitioning from these environments. Like Matplotlib, we support two coding styles, based on object-oriented programming and free-standing functions. We address these coding styles in Section Coding Styles . Our interface also employs templates to enable the functions to operate on a range of data types and data structures. We further use method chaining to allow for a more compact syntax. In Section Examples we examine the interface, provide some more high-level usage examples, illustrate the data formats for images, enumerate some limitations of our current implementation, and contrast our library with similar solutions. We supply numerous emblematic samples for all plot categories in this paper. Besides these instances, the library repository further includes a gallery with hundreds of examples that cover all plot categories and subcategories.","title":"The Matplot++ library"},{"location":"white-paper/#figures-and-axes","text":"The central object in Matplot++ is a figure , which describes a window or image on which we can plot one or more axes objects. The following Figure depict these main classes in more detail. Note that, unless the user needs to control these objects directly, this entire procedure of generating and maintaining the relevant figure for a plot is transparent to the user. The data scientist running a short experiment would probably just call a single command to stream their data to whatever plot category seems more suitable to visualize the data. A simple figure will usually have one axes object that stores the plots. A figure in quiet mode (non-reactive mode), will only be updated when the user calls the draw function, which recursively calls the draw function on all its child objects. This is the function we call to send the appropriate commands or vertices to the backend. If a figure is not in quiet mode, updating a property in any child object will automatically call the draw function. By default, figures are not in quiet mode. The show function is a variant of draw that blocks the execution until the user closes the figure or interacts with the console. This is useful to ensure one can visualize the results before the execution terminates. While this function is helpful for experiments, it should not be employed inside a library that will be used non-interactively. The touch function is intended to be used internally by child objects. The function calls draw only if the figure is in reactive mode. The commands add_axes , add_subplot , and nexttile create and properly position new axes in the figure. add_axes adds a new axes object in any absolute position on the figure, and we can choose to replace an existent axes object if it overlaps with the new axes. add_subplot will construct a new axes object in a position consistent with a layout of rows rows and cols columns. nexttile adds a subplot coherent with the rows, columns, and id defined by tiledlayout and currenttile . All these functions return an axes_handle object, which is a shared pointer to an axes object. The user can use this handle to update axes properties. When the last shared pointer to an axes objects ceases to exist, the axes object is deallocated from memory. The figure also holds a handle current_axes , which points to the last axes we added to the figure unless the user modifies it. The user can create multiple figures in the same process. If they are all interactive figures, this will open multiple windows in the same process. All new figures go to a global figure registry of figure handles. If the user calls a plotting command, it will use the current figure in the registry. The free-standing function gcf() returns a handle to the current figure in the registry. If there is no figure in the registry, gcf() adds a new figure to the registry and returns its handle. Because free-standing functions to create plots rely on gcf() , if there is no current figure in the registry, the registry creates a new figure for any initial plot the command. This allows users to use the library as a resource to stream their data transparently. The axes object is the object responsible for maintaining the plots. The following Figure presents more details. A new axes object will have no child objects and no legend. It has only its original collection of axis objects with default attributes for each coordinate. If we draw this new axes object, we get a figure like: In this Section, we export the figures with a gray background to help the reader differentiate the figure and axes objects. Analogous to gcf() , the method gca() returns a handle to the current axes in the current figure. If there is no current axes object in the figure, gca() will create a new axes . The method emplace_object pushes a new axes object to the axes . However, this method is not expected to be used directly. A variety of auxiliary methods create the appropriate axes object for a given plot category and make necessary calls to emplace_object . For instance, 1 2 vector < int > y = { 2 , 4 , 7 , 7 , 6 , 3 , 9 , 7 , 3 , 5 }; plot ( y ); is internally equivalent to 1 2 3 vector < int > y = { 2 , 4 , 7 , 7 , 6 , 3 , 9 , 7 , 3 , 5 }; line_handle l = make_shared < class line > ( gca (), y ); gca () -> emplace_object ( l ); Both would generate this line plot: For convenience, we assume throughout this paper we are operating in the matplot and std namespaces. This practice, nevertheless, is probably not recommendable in large projects and surely not advisable in header files. Besides the functions presented in last diagram, the axes object has dozens of methods to control its appearance. The methods can determine the axes location, camera positioning (for 3D plots), shortcuts to define the appearance of axis objects, its title, font properties, colors, grids behind the data, and boxes around the axes. These methods are described in detail in the documentation. There are also dozens of shortcuts to construct and emplace objects representing diverse plot categories. We discuss these categories in Section Plot Categories . The axis objects depict a specific coordinate. The \\(x\\) and \\(y\\) coordinates are used in two-dimensional plots. Two-dimensional plots can also use the extra coordinates \\(x_2\\) and \\(y_2\\) . The \\(x\\) , \\(y\\) , \\(z\\) coordinates are used in three-dimensional plots. The \\(r\\) and \\(t\\) coordinates are used in polar plots. Finally, the \\(cb\\) coordinate is used to determine the range of colorbars. Colorbars are useful to provide a third dimension to two-dimensional plots. For instance, we can use the \\(y_2\\) axis by 1 2 3 4 5 vector < int > y1 = { 1 , 10 , 7 , 6 , 7 , 7 , 4 , 6 , 1 , 6 }; vector < int > y2 = { 7 , 2 , 9 , 1 , 9 , 7 , 2 , 1 , 10 , 5 }; plot ( y1 ); hold ( on ); plot ( y2 ) -> use_y2 ( true ); The hold function determines the next_plot_replace property of the current axes . This property decides whether the next object we emplace in the axes should replace the current objects. The hold function expects a bool as a parameter. As a convenience for users transitioning from Matlab, we use constexpr to define on and off as aliases for true and false . As an extra convenience, note how we call use_y2 through method chaining, which can directly alter properties on the handle. The following Figure shows the resulting plot. Lastly, if the axes object has a legend object, it will store labels for the data in the axes and manage the presentation of the box with these labels. The legend function can be used to create such an object in the current axes. The function returns a legend_handle we can use to set its appearance. The axes objects can get their labels from the legend object or their display_name . For instance, given a set of line plots, we can combine both strategies by 1 2 3 vector < line_handle > ls = plot ( random_lines ); legend ( \"Line 1\" , \"Line 2\" ); ls [ 2 ] -> display_name ( \"Line 3\" ); This would create the plot presented in the following Figure: In this example, the plot receives four lines as input and returns a list of line handles. We use legend function to attribute a label to the first two line handles that have no display name. The third line has its label directly defined with display_name . The fourth line has no legend.","title":"Figures and Axes"},{"location":"white-paper/#plot-categories","text":"An axes object can hold plots in many categories. An axes object is an abstract class that represents what should be drawn in the axes. The following Figure shows the objects that inherit from axes objects . These objects represent primitives that can compose a plot. A plot category might depend on more than one axes object . For instance, contour lines might depend on contours and labels . The same axes object can also serve a number of plot categories. For instance, a matrix can represent heatmaps and images. By composing axes objects , the library offers functions to create plots in the following main categories: Line Plots (Section Line Plots ) Data Distribution (Section Data Distribution ) Discrete Data (Section Discrete Data ) Geography (Section Geography ) Polar Plots (Section Polar Plots ) Contour Plots (Section Contour Plots ) Vector Fields (Section Vector Fields ) Surfaces (Section Surfaces ) Graphs (Section Graphs ) Images (Section Images ) Annotations (Section Annotations ) In the following subsections, we discuss some important details of the algorithms in each of these categories.","title":"Plot Categories"},{"location":"white-paper/#line-plots","text":"The Line Plots cover the following subcategories: Line Plot; Line Plot 3D; Stairs; Error Bars; Area; Loglog Plot; Semilogx Plot; Semilogy Plot; Function Plot; Function Plot 3D; and Implicit function. Plots in this category depend on the line object. This object stores data for two or three-dimensional lines. The error bar object includes extra lines to represent error around data points. Log plots are utility functions that adjust the \\(x\\) or \\(y\\) axes to a logarithmic scale. The stair object renders the line with stairs between data points to denote discrete data. Instead of storing data points, the objects function line and string function store a function as a lambda function or as a string with an expression. These objects use lazy evaluation to generate absolute data points. The data is generated only when the draw function is called. The filled area object creates a polygon filling the area between the \\(x\\) axis and each line. Each of these plots can be created by 1 2 vector < vector < int >> Y = { { 1 , 3 , 4 , 0 }, { 2 , 5 , 4 , 7 }, { 6 , 4 , 5 , 3 } }; area ( Y , -4 , stacked ); where stacked is a boolean that tells whether the lines in Y should be stacked.","title":"Line Plots"},{"location":"white-paper/#data-distribution","text":"The Data Distribution category includes the following subcategories: Histogram; Boxplot; Scatter Plot; Scatter Plot 3D; Binned Scatter Plots; Plot Matrix; Parallel Coordinates; Pie Chart; Heatmap; and Word Cloud. These plot subcategories depend on the axes object types histogram , box chart , line , matrix , parallel lines , circles , labels . The histogram object creates the histogram edges and bins when the draw function is called for the first time with lazy evaluation. Lazy evaluation avoids calculating edges unnecessarily in case the user changes the object parameters before calling draw . This object includes several algorithms for automatically delimiting the edges and bins for the histograms. This Figure exemplifies some of these algorithms. Like the Line Plot subcategories, Scatter plots also depend on the line object. As the line object can represent lines with markers, the scatter function simply creates markers without the lines. Binned scatter plots use variations of the histogram algorithms of the previous Figure as an extra step to place all the data into two-dimensional bins that can be represented with varying colors or sizes. This is useful when there are so many data points that a scatter plot would be impractical for visualizing the data. The Plot Matrix subcategory is a combination of histograms and scatter plots. It creates a matrix of axes objects on the figure and creates a scatter plot for each pair of data sets. The function parallelplot creates a plot with Parallel Coordinates. In this type of plot, a parallel lines object stores an arbitrary set of axis objects to represent multi-dimensional data. This Figure exemplifies the parallel coordinates we can generate by 1 2 3 4 5 6 vector < vector < double >> X ( 4 ); X [ 0 ] = randn ( 100 , 50 , 200 ); X [ 1 ] = transform ( X [ 0 ], []( double x ){ return x + rand ( -30 , + 30 );}); X [ 2 ] = transform ( X [ 0 ], []( double x ){ return x > 50 ? + 1. : -1. ;}); X [ 3 ] = transform ( X [ 0 ], []( double x ){ return cos ( rand ( -30 , + 30 ));}); parallelplot ( X , X [ 2 ]); where randn and transform are shortcuts to generate random numbers with a normal distribution and to transform data. The second parameter of parallelplot determines the color of each data point, for which we use X[2] . Those axes are generated on top of a two-dimensional axes object. Word clouds are generated from text or pairs of words and their frequency. After attributing a size proportional to each word frequency, the algorithm to position the labels iterates words from the largest to the smallest. For each word, it spins the word in polar coordinates converted to Cartesian coordinates until it does not overlap with any other word. This Figure exemplifies a word cloud we can generate by 1 wordcloud ( tokens , count ); By default, the colors and the sizes depend on the word frequencies. We can customize the colors by passing a third parameter to the wordcloud function.","title":"Data Distribution"},{"location":"white-paper/#discrete-data","text":"The Discrete Data category includes the following subcategories: Bar Plot; Pareto Chart; Stem Plot; and Stem Plot 3D. These subcategories depend on the axes object types bars and line . Bar Plots depend on the bars object. Pareto Charts emplace a combination of bars and line . Stem plots rely on the line object. Pareto Charts are a type of chart that uses both \\(y\\) axes. The \\(y_1\\) axis is used to represent bars with the data values in descending order. The \\(y_2\\) axis is used to represent the cumulative distribution function of the data in the \\(y_1\\) axis. This next Figure exemplifies a Pareto chart generated by 1 2 vector < double > y = randn ( 20 , 500 , 1000 ); pareto ( y ); By default, a Pareto Chart includes up to 10 items or as many items as needed to represent 95\\% of the cumulative distribution. If the reader needs Pareto fronts rather than Pareto charts , we refer to Scatter Plots for two-dimensional fronts, Plot matrices for three-dimensional fronts, or Parallel Coordinates for many-objective fronts. These plot subcategories are described in Section Data Distribution . If the user also needs a tool to calculate these fronts efficiently, we refer to the Pareto Front Library .","title":"Discrete Data"},{"location":"white-paper/#geography","text":"The Geography category includes the following subcategories: Geoplot, Geoscatter, Geobubble, and Geodensity. All these subcategories depend on the line object to plot maps and data over these maps. For the first geography plot, we call geoplot() , which creates a filled polygon with the world map. This first plot receives the tag \"map\" so that subsequent geography plots recognize there is no need to recreate this world map. The data for the world map comes from Natural Earth. They provide data at 1:10m, 1:50m, and 1:110m scales. The geoplot function will initially use the data at the 1:110m scales. The geolimits function can be used to update the axis limits for geography plots. The difference between the usual functions for adjusting axis limits ( xlim and ylim ) and geolimits is that the latter will also update the map resolution according to the new limits for the \\(x\\) and \\(y\\) axis. The geolimits function will query the figure size and, depending on the new limits for the axes, update the map to the 1:10m, or 1:50m scales if needed. Because it would be very inefficient to render the whole world map at a 1:10m or 1:50m scale only to display a region of this map, the geolimits function also crops the data pertinent to the new region being displayed. Note that this does not only involve removing data points outside the new limits but it also needs to create new data points on the correct borders to create new polygons coherent with the map entry points in the region. For this reason, the algorithm needs to track all submaps represented as closed polygons in the original world map. If submaps are completely inside or outside the new ranges, we can respectively include or dismiss the data points. However, if the submap is only partially inside the new limits, to generate the correct borders for the polygons, we need to track all points outside the limits to classify the directions of these points outside the limits. We do that by only including points that change quadrants around the new limits so that the map entry points create polygons that look like they would if the complete world map were still being rendered outside these new limits. If the library user is not interested in geographic plots, the build script includes an option to remove the high-resolution maps at 1:10m and 1:50m scales from the library. In this case, the library will always use the map at a 1:110m scale no matter the axis limits. Figure exemplifies the map generated by 1 2 3 4 auto [ lon , lat , names ] = world_cities ( 6 , 8 ); auto [ lon2 , lat2 ] = greedy_tsp ( lon , lat ); geoplot ( lat2 , lon2 ) -> marker ( \"o\" ). marker_colors ( iota ( 1 , names . size ())); text ( lon , lat , names ); The function world_cities returns a list of major world cities. Its parameters define the minimum distances between cities in the \\(x\\) and \\(y\\) axes. The greedy_tsp function is a naive greedy algorithm to find a route between these cities as a Traveling Salesman Problem (TSP). We use the geoplot function to draw this route. Note that we use method chaining to define some further plot properties. Finally, the text function includes the city names in the map.","title":"Geography"},{"location":"white-paper/#polar-plots","text":"The Polar Plots category includes the following subcategories: Polar Line Plot, Polar Scatter Plot, Polar Histogram, Compass, and Polar Function. These subcategories depend on the axes object types line , histogram , vectors , string function , and function line . By emplacing a polar plot in the axes , the axes move to a polar mode, where we use the \\(r\\) and \\(t\\) axis instead of the \\(x\\) and \\(y\\) axis. From the backend point of view, these axes are an abstraction to the user. The data points in the \\(r\\) and \\(t\\) axis are drawn by converting the positions from the polar coordinates \\(r\\) and \\(t\\) to the Cartesian coordinates \\(x\\) and \\(y\\) with the relationships \\(x=r \\cos{t}\\) and \\(y=r \\sin{t}\\) . Aside from this conversion, these plot subcategories are analogous to line plots, scatter plots, histograms, quiver plots, and line functions. The next Figure exemplifies the polar histogram generated by 1 2 vector < double > y = randp ( 100 , 1.0 , 0.5 ); polarhistogram ( y , 25 ); The function polarhistogram distributes the data into the number of bins provided as its second parameter.","title":"Polar Plots"},{"location":"white-paper/#contour-plots","text":"The Contour Plots category includes the following subcategories: Contour Plots, Filled Contours, and Function Contour. All these subcategories depend on the contours type. They also depend on lazy evaluation for generating the contour lines. When the function draw is called in the contours class, it preprocesses all contour lines for a three-dimensional function. Although it is relatively simple to show a heatmap with the values for the \\(z\\) -axis, calculating contour lines relative to the \\(z\\) -axis is more complex than it might seem at first. We provide the function contourc for calculating contour lines. This function uses an adaptation of the algorithm adopted by Matplotlib. The algorithm creates a quad grid defined by the \\(x\\) and \\(y\\) values. It uses this grid to infer a contour line passing through positions with the same \\(z\\) value. The algorithm sweeps through the grid twice to generate these lines. The first sweep looks for lines that start on the boundaries. The second sweep looks for interior closed loops. Filled contours are closed polygons for pairs of contour levels. Some polygons for filled contours might be holes inside other polygons. The algorithm needs to keep track of these relationships so that we can render the polygons in their accurate order. To avoid an extra step that identifies this relationship between the polygons, the sweeping algorithm already identifies which polygons are holes for each level. Once we find the quads with the contour line, the line is generated by interpolating the \\(z\\) values around that quad. For instance, consider the Rastrigin function: 1 2 3 auto rastrigin = []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }; The next Figure exemplifies the filled contour lines generated for this function by 1 fcontour ( rastrigin ) -> filled ( true ); By default, the function fcontour will generate 9 contour lines from a lambda function. The functions contour and contourf , on the other hand, plot contour lines and filled contour lines from a grid of data points for \\(x\\) , \\(y\\) , and \\(z\\) .","title":"Contour Plots"},{"location":"white-paper/#vector-fields","text":"The Vector Fields category includes the following subcategories: Feather, Quiver, and Quiver 3D. All these subcategories depend on the vectors object type. In a two-dimensional plot, for each value of \\(x\\) and \\(y\\) with the position of a vector, it also requires the value of \\(u\\) and \\(v\\) indicating its direction and magnitude. In a three-dimensional plot, the direction and magnitude are defined by \\(u\\) , \\(v\\) , and \\(w\\) . A quiver plot (or velocity plot) shows a grid of vectors whose direction and magnitude are scaled to prevent the overlap between vectors in subsequent quads. Still considering the Rastrigin function, we can generate a grid with its data values and its gradient by 1 2 3 auto [ x , y ] = meshgrid ( iota ( -5 , .2 , 5 )); auto z = transform ( x , y , rastrigin ); auto [ dx , dy ] = gradient ( z , .2 , .2 ); where meshgrid , transform , and gradient are simple convenience functions. We can then present the contours lines and the gradient directions by 1 2 3 contour ( x , y , z ); hold ( on ); quiver ( x , y , dx , dy ); The following Figure quiver presents the results, where the quiver vectors help us identify the directions in which the function is decreasing in the contour plot.","title":"Vector Fields"},{"location":"white-paper/#surfaces","text":"The Surfaces category includes the following subcategories: Surface; Surface with Contour; Mesh; Mesh with Contour; Mesh with Curtain; Function Surface; Function Mesh; Waterfall; Fence; and Ribbon. All these subcategories depend on the surface class. The Waterfall, and Fence subcategories create surface slices for each value of \\(y\\) . The Ribbon subcategory creates surface slices for each value of \\(x\\) . Still considering the Rastrigin function, the next Figure exemplifies the Ribbon plot generated by 1 2 3 auto [ X , Y ] = meshgrid ( iota ( -5 , 1 , 5 ), iota ( -5 , .1 , 5 )); auto Z = transform ( X , Y , rastrigin ); ribbon ( X , Y , Z ) -> face_alpha ( 0.8 ); To make the visualization more comfortable, we define a larger step size on the \\(x\\) axis.","title":"Surfaces"},{"location":"white-paper/#graphs","text":"The Graphs category includes the following subcategories: Undirected Graphs; and Directed Graphs. All these subcategories depend on the network class. Graphs are abstract structures that represent objects and relationships between these objects. The objects are represented as vertices and the relationships are depicted as edges. In an abstract graph, the vertices have no specific position in space. Mathematically, a graph does not depend on its layout. However, the graph layout has a large impact on its understandability. The network class can calculate appropriate positions for graph vertices with several algorithms: Kamada Kawai algorithm, Fruchterman-Reingold algorithm, circle layout, random layout, and automatic layout. The implementation of the Kamada Kawai and Fruchterman-Reingold algorithms depend on the NodeSoup library. The next Figure exemplifies the Undirected Graph generated by 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 vector < pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 1 , 2 }, { 1 , 4 }, { 2 , 3 }, { 3 , 5 }, { 4 , 5 }, { 4 , 6 }, { 6 , 8 }, { 8 , 9 }, { 7 , 9 }, { 8 , 7 }, { 9 , 10 } }; vector < double > weights = { 4 , 4 , 2 , 1 , 1 , 4 , 2 , 1 , 3 , 3 , 2 , 4 , 1 }; graph ( edges ) -> edge_labels ( weights ); The automatic layout uses the Kamada Kawai algorithm for small graphs and the Fruchterman-Reingold algorithm for larger graphs.","title":"Graphs"},{"location":"white-paper/#images","text":"The Images category includes the following subcategories: Image Show; Image Matrix; and Scaled Image. These subcategories depend on the matrix class. The matrix class can have up to four matrices. If it has only one matrix, it is represented with a colormap. If it has three matrices, they represent the red, green, and blue channels. If it has four matrices, the fourth matrix represents an alpha channel to control the transparency of each pixel. We use the CImg library to load and save images. CImg can handle many common image formats as long as it has access to the appropriate libraries. The Matplot++ build script will look at compile-time for the following optional libraries: JPEG, TIFF, ZLIB, PNG, LAPACK, BLAS, OpenCV, X11, fftw3, OpenEXR, and Magick++. The build script will attempt to link all libraries from this list to Matplot++ . Matplot++ includes a few convenience functions to manipulate matrices with images: imread , rgb2gray , gray2rgb , imresize , and imwrite . All these functions work with lists of matrices. The next Figure exemplifies the image generated by 1 2 3 auto image = imread ( \"lena_gray.tiff\" ); imshow ( image [ 0 ]); colormap ( palette :: default_map ()); Because image is a list of matrices, image[0] is a matrix with the gray channel. If we used imread to load a colored image, image[0] would represent the red channel. Because the matrix has only one channel, it uses the default colormap. By default, the imshow function sets the grayscale colormap as the axes colormap. We use the colormap function to change it to the default colormap and generate a colored image.","title":"Images"},{"location":"white-paper/#annotations","text":"The Annotations category includes the following subcategories: Text; Text with Arrow; Rectangle; Filled Polygon; Ellipse; Textbox; Arrow; and Line. These subcategories depend on the axes object types labels , line , and vectors . The annotations category is meant to create individual objects on the plot rather than representations of data sets. An important difference between the annotations category and other categories is that, by default, the annotations do not replace the plot that already exists in the axes object, even if the user does not call the hold function. The next Figure exemplifies a number of annotations generated by 1 2 3 4 5 6 7 8 9 10 11 vector < double > x = { 0 , 8 , 8 , 0 }; vector < double > y = { 0 , 0 , 4 , 4 }; polygon ( x , y , \"g\" ); rectangle ( 0 , 0 , 2 , 4 , 0 ) -> fill ( true ). color ( \"red\" ); rectangle ( 3 , 0 , 2 , 4 , 1 ) -> fill ( true ). color ( \"magenta\" ); rectangle ( 6 , 0 , 2 , 4 , 0.5 ) -> fill ( true ). color ( \"yellow\" ); text ( 2 , 2 , \"Curvature 0\" ) -> alignment ( labels :: alignment :: right ); text ( 4 , 2 , \"Curvature 1\" ) -> alignment ( labels :: alignment :: center ); text ( 6 , 2 , \"Curvature 0.5\" ) -> alignment ( labels :: alignment :: left ); arrow ( 4 , 2.2 , 3 , 3 ); textarrow ( 6 , 1 , 8 , 0 , \"Last corner\" ); The rectangle object can have a border curvature from \\(0\\) to \\(1\\) . We can also annotate with text, arrows, polygons, and lines.","title":"Annotations"},{"location":"white-paper/#appearance","text":"All objects have numerous methods to control their appearance. This control is fundamental for high-quality publication images. As a convenience, the colors.h header contains many functions to generate colors from strings and vice-versa. It also contains dozens of functions to generate colormaps. The axes object has functions to control the labels for each axis, the subplot title, and the legends for child objects. Each axis object has functions to control its limits, manually adjust the axis ticks, define labels for manual ticks, and label formats for automatic ticks. There are various functions that allow and facilitate multiplots in a figure. The hold and use_y2 functions allow multiple plots on the same axes object. The subplot and nexttile functions allow a layout with many axes objects on the same figure . Another option is to create extra figure objects, which would open more plot windows. The colormaps can be used with two-dimensional plots to represent an extra dimension. Finally, the view and lightning functions can be used in three-dimensional plots to change the camera position and light intensity. The next Figure exemplifies two camera and lighting configurations for the Ackley function. The example is generated by 1 2 3 4 5 6 7 8 9 10 11 auto ackley = []( double x , double y ) { return -20 * exp ( -0.2 * sqrt ( 0.5 * ( pow ( x , 2 ) + pow ( y , 2 )))) - exp ( 0.5 * ( cos ( 2 * pi * x ) + cos ( 2 * pi * y ))) + exp ( 1 ) + 20 ; }; subplot ( 1 , 2 , 0 ); fsurf ( ackley ) -> lighting ( true ). primary ( 0.7 ). specular ( 0.9 ); subplot ( 1 , 2 , 1 ); fsurf ( ackley ); rotate ( 20 , 30 );","title":"Appearance"},{"location":"white-paper/#coding-styles","text":"","title":"Coding Styles"},{"location":"white-paper/#member-vs-free-standing-functions","text":"Like in Matplotlib, we support two coding styles: Free-standing functions and an Object-oriented interface. With free-standing functions, we call functions to create plots on the current axes. The global current axes object is the current axes object in the current figure in the global figure registry (Section Figures and Axes ). For instance, one can use plot(y); to create a line plot on the current axes (or create a new axes object if needed). Also, one can use plot(ax,y); to create a line plot on the axes object ax . This is less verbose for small projects and quick tests. The library looks for existing axes to create the plot. In the object-oriented interface, we explicitly create figures and call methods on them. For instance, one can use ax->plot(y); to plot on the axes object ax . We can create the same line plot on the current axes by auto ax = gca(); ax->plot(y); . This is less verbose and provides better control in large projects where we need to pass these objects around. The user manages axes handles containing plots. Assuming the user is explicitly managing the axes to create plots in another function, a more complete example of these styles could be 1 2 3 4 // Free-standing functions auto ax = gca (); plot ( ax , x , y ) -> color ( \"red\" ). line_width ( 2 ); my_function ( ax ); and 1 2 3 4 // Object-oriented interface auto ax = gca (); ax -> plot ( x , y ) -> color ( \"red\" ). line_width ( 2 ); my_function ( ax ); Both examples would generate the same plot. All free-standing functions are templated functions that use meta-programming to call the main function on the current axes object. If the first parameter is not an axes_handle , it will get an axes_handle from the figure registry with gca (Section Figures and Axes ) and forward all parameters to the function in this axes object. If the first parameter is an axes_handle , the template function will forward all parameters, but the first one, to this axes object. This use of templates for the free-standing functions keeps both coding styles maintainable by the developers. Note that, because the example needs the axes object for the function my_function , we also need to get a reference to the axes object with the free-standing functions. In that case, the free-standing functions are not less verbose than the object-oriented interface. To adhere to free-standing functions, we could create two versions of my_function : one that receives an axes_handle , and a second version that would get an axes_handle from the figure registry and call the first version. If my_function is going to be exposed to other users as a library, this could be a convenience to these users. However, notice that this is only moving the verbosity from the main function to my_function . In fact, this is how the free-standing functions in Matplot++ work.","title":"Member vs. Free-standing Functions"},{"location":"white-paper/#reactive-figures","text":"There are also two modes for figures: reactive (or interactive) mode and quiet mode. Figures in reactive mode are updated whenever any of their child objects change. This happens through the touch function, that gets called on any child object when it changes its appearance. This creates an interactive mode in which figures are updated as soon as we adjust their properties. If we combine interactive figures with free-standing functions, we have a \"Matlab-like style\" for plots. This is a coding pattern where the figure registry works as a stream for plots. The problem with this coding style is that the user might unnecessarily create useless intermediary plots. Figures in quiet mode are updated by calling the functions draw() or show() (Section Figures and Axes ). Unless these functions are called, nothing changes in the figure. The combination of the object-oriented coding style and quiet mode is the \"OO-Matplotlib-like style\" for plots. This is a coding style in which the user explicitly decides when the plot is shown or updated. This is beneficial to applications that cannot waste computational resources on intermediary figures that might not be valuable to the application. We generally use free-standing functions with reactive mode and the object-oriented interface with quiet mode. By default, new figures are in reactive mode, unless it is using an non-interactive backend. One can turn this reactive mode on and off with: ion() or ioff() free-standing functions reactive(bool) or quiet(bool) function on the figure object figure(true) or figure(false) when explicitly creating a new figure A more complete example of the reactive mode would be: 1 2 3 4 5 6 // Reactive mode auto f = gcf ( false ); auto ax = f -> gca (); auto p = ax -> plot ( ax , x , y ); // draws once p -> color ( \"red\" ). line_width ( 2 ); // draws twice more wait (); // pause console For convenience, the examples in Section Plot Categories use the reactive mode. The wait function pauses the console until the user interacts with the plot window. If the backend is based on process pipes, because these are unidirectional, closing the window is not enough to resume. The user needs to use the console to unblock execution. A similar example is quiet mode would be 1 2 3 4 5 6 // Quiet mode auto f = gcf ( true ); auto ax = f -> gca (); auto p = ax -> plot ( x , y ); // does not draw p -> color ( \"red\" ). line_width ( 2 ); // does not draw f -> show (); // draw only once and pause console In this example, the figure is only updated once. The user could replace the show function with the draw function, but the window would close as soon as execution completes. It is important to use wait() and show() with caution. These functions are meant for some particular executables so that an interactive plot does not close before the user can see it. It is probably unreasonable to call these functions inside a library because the user would have to manually interfere with the execution to continue.","title":"Reactive figures"},{"location":"white-paper/#method-chaining","text":"To support a more compact syntax, the library allows method chaining on plot objects. For instance, we can create a simple line plot and modify its appearance by 1 2 3 4 5 6 // Using the line handle auto p = plot ( x , y , \"--gs\" ); p -> line_width ( 2 ); p -> marker_size ( 10 ); p -> marker_color ( \"b\" ); p -> marker_face_color ({ .5 , .5 , .5 }); or 1 2 // Method chaining plot ( x , y , \"--gs\" ) -> line_width ( 2 ). marker_size ( 10 ). marker_color ( \"b\" ). marker_face_color ({ .5 , .5 , .5 }); The first code snippet works because plot returns a line_handle to the object in the axes . We can use this line handle to modify the line plot. Whenever we modify a property, the setter function calls touch , which will draw the figure again if it is in reactive mode. The second option works because setters return a reference to *this rather than void.","title":"Method Chaining"},{"location":"white-paper/#ranges","text":"The plotting functions work on any range of elements convertible to double . For instance, we can create a line plot from a set of elements by 1 2 set < int > y = { 6 , 3 , 8 , 2 , 5 }; plot ( y ); Any object that has the functions begin and end are considered iterable ranges. Most axes object subclasses use vector<double> or vector<vector<double>> to store their data. For convenience, the common.h header file includes the aliases vector_1d and vector_2d to these data types. These conversions also work on ranges of ranges: 1 2 3 vector < set < int >> Y = { { 6 , 3 , 8 , 2 , 5 }, { 6 , 3 , 5 , 8 , 2 } }; plot ( Y ); Unfortunately, because of how templated functions work, one exception is initializer lists. Initializer lists only work for functions that are explicitly defined for them.","title":"Ranges"},{"location":"white-paper/#utilities","text":"The headers common.h and colors.h include a number of utilities we use in our examples. These include naive functions to generate and manipulate vectors and strings; handle RGBA color arrays; convert points to and from polar coordinates; read files to strings; write strings to files; calculate gradients; read, write, and manipulate images; and generate vectors with random numbers. Although some of these functions might be helpful, most functions only operate on vector<double> and they are not intended to be a library of utilities. The sole purpose of these algorithms is to simplify the examples.","title":"Utilities"},{"location":"white-paper/#backend-interface","text":"While Matplot++ provides a shared representation for plots, there are innumerable technologies through which these objects can become interactive or non-interactive images. Users might want to export images, monitor metrics in real-time, or generate images for GUIs that might involve several libraries. It is unrealistic to anticipate the technologies involved in all applications that might benefit from Matplot++ . The only way to open these possibilities to users is by separating the implementation layers managing objects from the layers that generate the images for a given application. This enables users to reuse the Matplot+ + data structures in any application. For this reason, the figure object stores a shared pointer to a backend_interface that is responsible for ultimately drawing the plots. Libraries, such as Matplotlib, and languages with plotting capabilities, like Octave, usually have many backends for drawing objects, depending on the operating system and user demands. For interactive plots, these usually involve backends that are specific to the operating system. The backend_interface has many virtual functions that can be overridden to create new backends for these plots. The first set of functions in this interface are designed to identify the operation mode of a backend. The function is_interactive returns whether a backend is in interactive mode. Note that a backend can operate on both modes, depending on its parameters. For instance, a Gnuplot backend can work in interactive or non-interactive mode, depending on its terminal. Also, an OpenGL backend can work in non-interactive mode, in which case we would export its current pixels to an image file. The function output defines the output file name and file format for non-interactive plots. The next set of functions in the backend_interface are related to figure properties. These include functions to set or get the figure properties such as width, height, position, background color. The position is mostly relevant for interactive plots. Note that although we can set the image size through the figure object, the width and height properties are ultimately stored in the backend. The reason for this is that, in interactive plots, the user might manually move and resize the window, and the figure object has to respond accordingly. The last set of commands are related to drawing. In that regard, there are two types of backends. Some backends, like a Gnuplot backend, are based on commands and some backends, like an OpenGL backend, are based on vertices. We could try to recreate Gnuplot commands that would emulate a library based on vertices, but such a strategy would be wasteful. It would require the Gnuplot backends to find workarounds to bypass its default axes objects, manually recreate projections, and require the Gnuplot pipe to execute more commands than would be necessary for the plots. In that case, our preliminary solution has been to include interfaces for commands and vertices. If a backend is based on commands, functions such as run_command should be overridden to consume these commands. If a backend is based on vertices, functions such as draw_path and draw_image should be overridden to directly draw the specified vertices on the canvas. Because the library is in an embryonic stage regarding its available backends, the backend_interface is open for change as we identify new demands from backend developers. These extensions might involve more complex strategies for unifying the types of backends, internal algorithms for 3D graphical projections, or abstractions to draw different types of objects through the backend.","title":"Backend Interface"},{"location":"white-paper/#examples","text":"In this Section, we compare our interface with other similar libraries, provide examples integrating the library into some scientific applications, explain how unique plot categories can be defined, and discuss some limitations of the library.","title":"Examples"},{"location":"white-paper/#interface","text":"Although the internal structure of Matplot++ is not the same as Matplotlib or the Matlab graphics functions, all interfaces are very similar. The comparable function names are mostly intended as a convenience to the transitioning user who is not concerned about specific internal details of the library. We cover almost all plot categories that exist in Matplotlib and Matlab. However, it seems like Matplotlib has no special plot category for networks. In Python, this can be solved with NetworkX. It is also important to note that Matlab has innumerable astounding toolboxes for various categories of problems and these toolboxes tend to include graphics for their specific domains. Matplot++ has neither the intention nor the capacity to compete in that domain.","title":"Interface"},{"location":"white-paper/#a-minimal-application","text":"Section Plot Categories previously included many examples that cover each plot category. The repository contains hundreds of examples that include all subcategories. Thus, it would be redundant to spend this Section with disconnected examples of more plot subcategories. Rather, in this Section we exemplify a use case where the user wants to integrate plots into a minimal application. This provides an opportunity to discuss how one can manage handles and apply the coding styles of Section Coding Styles in an application. In this example, let us suppose our data scientist is using the Travelling Salesman Problem (TSP) as a model to plan an Eurotrip. We can define the city names and their geographical positions: 1 2 3 vector < string > names = { \"Tirana\" , \"Andorra la Vella\" , \"Vienna\" /*, ...*/ }; vector < double > lat = { + 41.3317 , + 42.5075 , + 48.2092 /*,...*/ }; vector < double > lon = { + 19.8172 , + 1.5218 , + 16.3728 /*,...*/ }; The complete example, with 44 cities, is available in our repository. Because the axes object is going to be managed inside an application, we create a quiet figure and pass its only axes object to our object eurotrip_solver representing the application by 1 2 3 figure_handle f = figure ( true ); eurotrip_solver s ( lat , lon , names , f -> current_axes ()); s . run (); The eurotrip_solver has the following interface: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class eurotrip_solver { public : eurotrip_solver ( const vector < double >& lat , const vector < double >& lon , const vector < string >& names , axes_handle ax ); void run ( int iterations = 100 ); private : void setup_starting_point ( size_t iteration ); double tour_distance ( const vector < size_t >& tour ); void iteration (); static vector < vector < size_t >> get_neighbors ( const std :: vector < size_t >& tour ); bool update_if_better ( const vector < size_t > & neighbor ); void draw_if_improvement (); void draw (); private : vector < double > lat_ ; vector < double > lon_ ; vector < string > names_ ; axes_handle ax_ ; // Current tour double curr_dist_ { 0.0 }; vector < size_t > curr_tour_ ; // Best tour double min_dist_ { 0.0 }; vector < size_t > best_tour_ ; }; A note to programmers not familiar with C++ is that size_t is an unsigned integer type commonly used to represent sizes and indexes. The eurotrip_solver object includes a reference to an axes_handle and vector s with information about the cities. This is all the information we need to plot our map. The run function will generate a new starting tour curr_tour_ and run an iteration of the algorithm iterations times: 1 2 3 4 5 6 7 8 void eurotrip_solver :: run ( int iterations ) { for ( size_t i = 0 ; i < iterations ; ++ i ) { setup_starting_point ( i ); iteration (); } ax_ -> draw (); ax_ -> parent () -> save ( \"eurotrip.svg\" ); } The function setup_starting_point creates an initial tour with a greedy algorithm that uses the current iteration as seed for its starting point. This is meant to generate a different starting point for each iteration. The iteration function runs a local search algorithm on that starting point. It visits all neighbors of curr_tour_ and stores any neighbors that happen to be better than best_tour_ . Whenever we find a better solution, the iteration function calls the draw function: 1 2 3 4 5 6 7 8 9 10 11 12 13 void eurotrip_solver :: iteration () { bool improvement = true ; while ( improvement ) { improvement = false ; for ( const auto & neighbor : get_neighbors ( curr_tour_ )) { improvement = update_if_better ( neighbor ); draw_if_improvement (); if ( improvement ) { break ; } } } } While calling a get_neighbors(curr_tour_) to pre-calculate all neighbors is certainly not an efficient solution, it is an abstraction that serves this example well by abstracting away unnecessary details of the search algorithm. The function update_if_better will update curr_tour_ and best_tour_ if the neighbor solution happens to be better than any of them. The draw_if_improvement function will only call the draw if there has been some improvement on the best solution. We also use this opportunity to check the last time we called draw and skip the function call if the frame rate happens to be higher than necessary. This is useful in this sort of algorithm to make sure we do not spend more time plotting than searching for solutions. 1 2 3 4 5 6 7 8 9 10 11 12 13 void eurotrip_solver :: draw_if_improvement () { static auto last_draw = chrono :: high_resolution_clock :: now () - chrono :: seconds ( 1 ); static auto min_dist_when_last_draw = min_dist_ ; const auto current_time = chrono :: high_resolution_clock :: now (); const bool its_been_a_while = current_time - last_draw > chrono :: seconds ( 1 ); const bool things_are_better = min_dist_ < min_dist_when_last_draw ; if ( its_been_a_while && things_are_better ) { last_draw = current_time ; min_dist_when_last_draw = min_dist_ ; draw (); } } Finally, the draw function uses our axes_handle to update the figure whenever we find a better solution: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void eurotrip_solver :: draw () { ax_ -> clear (); ax_ -> geolimits ( min ( lat_ ) -5 , max ( lat_ ) + 5 , min ( lon_ ) -2 , max ( lon_ ) + 10 ); vector < double > sorted_lat ; vector < double > sorted_lon ; for ( const int & idx : best_tour_ ) { sorted_lat . emplace_back ( lat_ [ idx ]); sorted_lon . emplace_back ( lon_ [ idx ]); } sorted_lat . emplace_back ( lat_ [ best_tour_ [ 0 ]]); sorted_lon . emplace_back ( lon_ [ best_tour_ [ 0 ]]); ax_ -> geoplot ( sorted_lat , sorted_lon ); ax_ -> hold ( true ); ax_ -> geoscatter ( lat_ , lon_ ); auto [ lon_c , lat_c , names_c ] = clear_overlapping_labels ( lon_ , lat_ , names_ , 1 , 1 ); ax_ -> text ( lon_c , lat_c , names_c ); ax_ -> title ( \"Tour distance \" + num2str ( min_dist_ )); ax_ -> draw (); } Because we are moving the handles around, we use the object-oriented coding style. The geolimits function will adjust the map limits around Europe. The draw function will then create a line going through the cities according to the order indicated by the current best tour. The geoscatter function does not need the cities to be in order because it plots no lines. The text function creates an annotation on top of the map with the city names. The function clear_overlapping_labels is an auxiliary function to remove overlapping labels from the map. The title function creates a title with the current distance. Because the figure is in quiet mode, we need to call the draw function. In this case, the quiet mode avoided rendering the figure five times with unnecessary intermediary plots. Besides interactively showing intermediary results during the algorithm execution, the run function also saves the figure to a vector graphics, that is appropriate for printing the results at any size. The save function will temporarily and transparently change the figure backend to a non-interactive backend for Scalable Vector Graphics (SVG) and draw the figure to an output file. The following Figure shows the final image.","title":"A Minimal Application"},{"location":"white-paper/#applications-managing-plot-handles","text":"Notice in the previous example that we only keep a handle for the axes object in our application. Every time we call the draw() function, we clear the axes object and recreate its plots. For instance, this algorithm is recalculating the same geolimits every time we update the plot. In this Section, we examine a more high-level use case where we cache handles to the axes object and its plots to update the figure more efficiently. Whenever we find a better solution, we only update the plots instead of recreating them on the axes object. To differentiate the example, we consider the Americas for this example 1 2 3 vector < string > names = { \"Marigot\" , \"The Valley\" , \"Saint John's\" /*,...*/ }; vector < double > lat = { 18.0731 , 18.2166 , 17.1166 /*,...*/ }; vector < double > lon = { -63.0822 , -63.0500 , -61.8500 /*,...*/ }; The americas_trip_solver now has two extra-members in its interface: 1 2 3 4 5 6 7 class americas_trip_solver { // ... private : void setup_axes (); // ... line_handle lh_ ; }; The extra handle to the line plot inside the axes object allows us to only modify the data in that plot instead of recreating all the plots. The code that was previously in draw will now be split between draw and setup_axes . We plot almost everything in the setup_axes function: 1 2 3 4 5 6 7 8 9 10 void americas_trip_solver :: setup_axes () { ax_ -> clear (); ax_ -> geolimits ( min ( lat_ ) -5 , max ( lat_ ) + 5 , min ( lon_ ) -30 , max ( lon_ ) + 50 ); lh_ = ax_ -> geoplot ( lat_ , lon_ ); ax_ -> hold ( true ); ax_ -> geoscatter ( lat_ , lon_ ); auto [ lon_c , lat_c , names_c ] = clear_overlapping_labels ( lon_ , lat_ , names_ , 2 , 2 ); ax_ -> text ( lon_c , lat_c , names_c ); ax_ -> draw (); } Notice that we do not need to recreate the map, the scatter points, or the text annotation when drawing the plot. When plotting the route, we keep a handle to the line object in lh_ . This is the only element we need to update when drawing the plot with a new route. Thus, the draw function is simplified to 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void americas_trip_solver :: draw () { vector < double > sorted_lat ; vector < double > sorted_lon ; for ( const int & idx : best_tour_ ) { sorted_lat . emplace_back ( lat_ [ idx ]); sorted_lon . emplace_back ( lon_ [ idx ]); } sorted_lat . emplace_back ( lat_ [ best_tour_ [ 0 ]]); sorted_lon . emplace_back ( lon_ [ best_tour_ [ 0 ]]); lh_ -> x_data ( sorted_lon ); lh_ -> y_data ( sorted_lat ); ax_ -> title ( \"Tour distance \" + num2str ( min_dist_ )); ax_ -> draw (); } The function is only responsible for creating a different line with the current route and updating the title. This significantly simplifies the process of refreshing the figure. All other axes children stay as they are. The rest of the americas_trip_solver class remains the same as eurotrip_solver . The following Figure displays the final image for this example. With the examples from Section Plot Categories , the example from Section minimal_application and this Section should demonstrate how Matplot++ can work at various levels of complexity and abstraction. Section minimal_application exemplified Matplot++ as a solution for users who want to create simple plots for experiments, while this Section exemplifies a more complex application that requires more efficient interactive plots. Although more complicated, the library architecture also allows tighter integration with GUIs with the development of backends that are specific to the domain of a GUI library.","title":"Applications Managing Plot Handles"},{"location":"white-paper/#exporting-figures","text":"Some previous examples involved the save function. There are two ways to save figures: manually and programmatically. The interactive plot window has a widget to save the current figure. Because this widget uses the same backend as the one used to produce the interactive image, the final image matches closely what the user sees in the window. The user can also programatically save the figure in a number of formats with the save function: 1 save ( filename ); or 1 save ( filename , fileformat ); The first option infers the appropriate file format from the filename extension. In both cases, this function temporarily changes the backend to a non-interactive backend appropriate to draw the figure. A different backend is used for each format and, depending on the format, the final image does not necessarily match what is on the interactive plot window. The reason is that some file formats purposefully do not include the same features. For instance, consider the bar chart generated by 1 2 vector < double > x = { 29 , 17 , 14 , 13 , 12 , 4 , 11 }; bar ( x ); If we export the image with 1 save ( \"barchart.svg\" ); we get the vector graphics Exporting the image with 1 save ( \"barchart.txt\" ); generates a representation of the image appropriate for text or markdown files, such as 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 30 +-----------------------------------------------------------+ | ******* + + + + + + | | * * | 25 |-+ * * +-| | * * | | * * | 20 |-+ * * +-| | * * | | * ******** | 15 |-+ * ** * +-| | * ** * ******* | | * ** * * ******** ******* | | * ** * * ** * * * ******* | 10 |-+ * ** * * ** * * * * * +-| | * ** * * ** * * * * * | | * ** * * ** * * * * * | 5 |-+ * ** * * ** * * ******** * * +-| | * ** * * ** * * ** * * * | | * + ** + * * + ** + * * + ** + * * + * | 0 +-----------------------------------------------------------+ 1 2 3 4 5 6 7 As the last example, saving an image with 1 save ( \"barchart.tex\" ); would save the image in a format appropriate to embed in latex documents, such as This exports the image in a format in which the labels are replaced by latex text so that the plot fits the rest of the document.","title":"Exporting Figures"},{"location":"white-paper/#creating-new-plot-types","text":"There are two options for creating new plot styles: concatenating the existing plotting styles or creating a class that inherits from axes object . The first is probably enough for most cases because there are already many primitives that can form new plot types. In fact, most plot types discussed in Section Plot Categories are combinations of axes object subcategories rather than different primitives. Creating a new class that inherits from axes object is only necessary if we are working on a new plot category that needs to manage its own pre-processed data, like networks, contours, and histograms. Note that, if it were not for the algorithms involved in these types of plots, we could comfortably replace networks, contours, and histograms by a combination of scatter plots, line plots, filled polygons, and bar plots. To create a new class inheriting from axes object , the user needs to override several virtual functions. Although the exact function types might slightly change between library versions, these functions should return the object boundaries in each axis (so that the axes object knows how to adjust automatic axis objects); return the valid object coordinates (two-dimensional, three-dimensional, or polar); consume labels from the legend object; and return an optional tag that describes the plot category.","title":"Creating new plot types"},{"location":"white-paper/#backends","text":"The repository includes a directory for complete backends and backends that exemplify how we can integrate other technologies with Matplot++ . As usual in many C++ plotting libraries (Section Alternatives for Data Visualization in C++ ), this library offers a complete backend that uses pipes to Gnuplot processes as backends. Each Gnuplot output format represents a possible backend in Matplot++ . That was also the approach in the early versions of Octave, which now provides an additional backend based on OpenGL. The main advantage of a default Gnuplot backend at this point is that it can work in interactive and non-interactive mode. Its various auxiliary terminals can be used as additional non-interactive backends to export plots to a variety of useful formats that would be impossible otherwise, such as the SVG and latex file formats examined in Section Exporting Data . The second benefit of Gnuplot is that it allows us to abstract away technologies that are specific to each operating system. Without Gnuplot, these features would only be possible through a large number of other backends. For this reason, we currently make this our default backend. Although we use Gnuplot as a default backend, this is transparent to the user and we attempt to limit the internal rendering functions to its most primitive methods, as in the subclasses of axes object described in Section Plot Categories . For instance, the library can independently calculate its contours, interpolations, automatic axis ticks, parallel axes, and histograms without recurring to the backend. This constraint on plotting primitives is intended to make it more straightforward to implement other backends we might need in the future. These new backends could be implemented in a Dear ImGui backend style, where the library is only responsible for creating plots for a rendering engine that has a render loop running on the main thread. The main difference in such an architecture is that Gnuplot expects commands rather than vertices. This is probably the case with other potential backends, such as non-interactive backends for exporting plots to image files. As an example, the repository also includes an instance of a backend implementation that uses OpenGL. The main drawback of Gnuplot as a default backend is that it depends on process pipes. Since a pipe is by definition unidirectional, the constrains some features we could have in interactive plots, such as: Parameters will come from the figure object and not from the interactive window. This means plots are not as responsive as they could when moving and resizing windows. For this reason, it is always best to programmatically set the window size on the figure object rather than manually changing it, especially when you intend to save the image programmatically. There is no straightforward way to query the exact word positions in Word Clouds (Section Data Distribution ). This means the algorithm to generate clouds needs to estimate where the words are. This makes word clouds very sensitive to the backend. When saving a word cloud, it's best to save it non-programmatically. The interactive features of Gnuplot, like rotating three-dimensional plots, do not work well with subplots. Gnuplot pipes impose extra requirements on the backend interface (Section Backend Interface ). The illustrative backends in our repository demonstrate that other backends could make it possible for plots to be more interactive in these regards. For instance, a backend based on OpenGL might offer much more control over interactive plots. However, these backends can have drawbacks that make them less appropriate as a default backend at this point. For instance, in some operating systems, OpenGL can only run on the main thread. One solution to this problem would be to defer plotting to another process. However, this would make the OpenGL backend very similar to the default Gnuplot pipe. The process of sending data to another process could be inefficient or depend on interprocess communication strategies for the operating system that could more complex than the backend. A second alternative to this problem is to create a backend that would always work on a secondary thread. OpenGL would block the main thread with its render loop and Matplot++ would create plots for this main application. In this sense, Matplotlib++ would work like backends for Dear ImGui. Although such a backend could be useful to many applications, that makes is less of a library for accessible data visualization and more like a widget for GUIs. Although most costly in terms of development, a more reliable strategy would be for developers to solve these problems with native backends targeted at specific operating systems. Because this imposes a high development cost, these backends should appear over time, as the demand for each of these backends grows. Note that all this discussion does not even include non-interactive backends. Users might need to handle technologies specific to the operating system, integrate plots into an existing GUI, display their plots on a web page through WebGL, export images for scientific papers, or stream their plots to the console. As discussed in Section Backend Interface , there are too many possibilities and use cases for data visualization, and that is precisely the rationale for the backend interface. What is most important is that the implementation layer is open for more advanced users to adapt the library to their needs.","title":"Backends"},{"location":"white-paper/#performance","text":"We are incrementally improving the code for performance and avoid any counter-productive coding patterns. The axes objects that depend on expensive calculations all use lazy evaluation to avoid calculating data for unnecessary plots. Having said that, Matplot++ concentrates intensively on the design goals described in Section Data Visualization : interactive plotting, high-quality exporting tools, and productivity. The rationale is that, for now, most applications of interest are environments where plotting is inexpensive compared to the processes we are monitoring.","title":"Performance"},{"location":"white-paper/#conclusion","text":"The paper presented Matplot++ , an alternative for data visualization in C++. Aiming at scientific computing, the design goals of Matplot++ are interactive plotting, high-quality exporting tools, and simplicity. The library allows users to create sophisticated plots with a compact syntax. This enables programmers to monitor metrics and scientists to create high-quality figures for publications. Current work includes continuous performance gains, further specialized backends for multiple operating systems, and increasing support for more types of backends in the present plot categories.","title":"Conclusion"},{"location":"white-paper/#references","text":"Abadi M, Barham P, Chen J, Chen Z, Davis A, Dean J, Devin M, Ghemawat S, Irving G,Isard M,et al.(2016). \"Tensorflow: A system for large-scale machine learning.\" In 12th USENIX symposium on operating systems design and implementation (OSDI 16), pp.265-283. Angerson E, Bai Z, Dongarra J, Greenbaum A, McKenney A, Du Croz J, Hammarling S,Demmel J, Bischof C, Sorensen D (1990). \"LAPACK: A portable linear algebra library for high-performance computers.\" In Supercomputing'90: Proceedings of the 1990 ACM/IEEE Conference on Supercomputing, pp. 2-11. IEEE. Antcheva I, Ballintijn M, Bellenot B, Biskup M, Brun R, Buncic N, Canal P, Casadei D, CouetO, Fine V, et al.(2011). \"ROOT-A C++ framework for petabyte data storage, statistical analysis and visualization.\"Computer Physics Communications,182(6), 1384-1385. Baratov R (2019). Hunter. URL: https://hunter.readthedocs.io . Barrett P, Hunter J, Miller JT, Hsu JC, Greenfield P (2005). \"matplotlib-A Portable Python Plotting Package.\" In Astronomical data analysis software and systems XIV, volume 347,p. 91. Bezanson J, Edelman A, Karpinski S, Shah VB (2017). \"Julia: A fresh approach to numerical computing. \"SIAM review,59(1), 65-98. CEGUI Team (2020). CEGUI. URL: http://cegui.org.uk . Cornut O (2020). Dear ImGui: Bloat-free Immediate Mode Graphical User Interface for C++ with minimal dependencies. URL: https://github.com/ocornut/imgui . de Guzman J (2020). Elements. URL: http://cycfi.github.io/elements/ . Eichhammer E (2020). QCustomPlot. URL: https://www.qcustomplot.com . Evers B (2019). Matplotlib-cpp. URL: https://github.com/lava/matplotlib-cpp . Freitas A (2020). Pareto Front Library. URL: https://github.com/alandefreitas/pareto-front . Frigo M, Johnson SG (1998). \"FFTW: An adaptive software architecture for the FFT.\" In Proceedings of the 1998 IEEE International Conference on Acoustics, Speech and Signal Processing, ICASSP'98 (Cat. No. 98CH36181), volume 3, pp. 1381-1384. IEEE. Fruchterman TM, Reingold EM (1991). \"Graph drawing by force-directed placement. \"Software: Practice and experience, 21(11), 1129-1164. GNU Project (2020). GNU Octave: Introduction to Plotting. URL: https://octave.org/doc/v4.2.2/Introduction-to-Plotting.html . Guy Eric Schalnat Andreas Dilger GRP (2020). Libpng. URL: https://sourceforge.net/p/libpng/ . Hao J (2020). Nana. URL: http://nanapro.org/ . Hunter JD (2007). \"Matplotlib: A 2D graphics environment. \"Computing in Science & Engineering, 9(3), 90-95. doi:10.1109/MCSE.2007.55. Idea4good (2020). GuiLite. URL: https://github.com/idea4good/GuiLite . ImageMagick Studio LLC (2020). Magick++. URL: https://imagemagick.org/Magick++/ . Independent JPEG Group (2020). Libjpeg. URL: http://libjpeg.sourceforge.net . Intel Corporation, Willow Garage I (2020). Open Source Computer Vision Library (OpenCV). URL: https://opencv.org/ . Jakob W (2017). PyBind11. URL: https://pybind11.readthedocs.io/en/stable/ . Kagstrom B LP, C VL (2020). Basic Linear Algebra Subprograms (BLAS). URL: http://www.netlib.org/blas/ . Kainz F, Bogart R, Hess D (2003). \"The OpenEXR image file format.\"SIGGRAPH TechnicalSketches. Kamada T, Kawai S,et al.(1989). \"An algorithm for drawing general undirected graphs.\"Information processing letters,31(1), 7-15. Loup Gailly J, Adler M (2020). Zlib. URL: https://github.com/madler/zlib . Martin K, Hoffman B (2010). Mastering CMake: a cross-platform build system. Kitware. McKinney W,et al.(2011). \"Pandas: a foundational Python library for data analysis and statistics. \"Python for High Performance and Scientific Computing, 14(9). Conan.io (2020). Conan. URL: https://conan.io . Melchior L (2020). CPM.cmake. URL: https://github.com/TheLartians/CPM.cmake . Murray Cumming DE (2020). Gtkmm. URL: https://www.gtkmm.org/ . Natural Earth (2018). \"Natural earth. Free vector and raster map data.\" URL: http://www.naturalearthdata.com/downloads/ . NetworkX developers (2020). NetworkX. URL: https://networkx.github.io . Olivier Birot (2020). nodesoup. URL: https://github.com/olvb/nodesoup . Pezent E (2020). ImPlot. URL: https://github.com/epezent/implot . Sam Leffler SG (2020). Libtiff. URL: https://gitlab.com/libtiff/libtiff . Schaling B (2011). The boost C++ libraries. Boris Schaling. Spitzak B, et al.(2004). \"Fast Light Toolkit (FLTK).\" FTLK: Fast light toolkit. Available: http://www.fltk.org/ Stahlke D (2020). Gnuplot-Iostream. URL: http://stahlke.org/dan/gnuplot-iostream/ . Storer J (2020). JUCE. URL: https://juce.com . Terra Informatica Software, Inc (2020). Sciter. URL: https://sciter.com . The FLTK Team (2020). FLTK. URL: https://www.fltk.org . The MathWorks, Inc (2020). MatlabGraphics. URL: https://www.mathworks.com/help/matlab/graphics.html . The Qt Company (2020). Qt. URL: https://www.qt.io . Tschumperle D (2020). CImg. URL: http://cimg.eu . van der Zijp J (2020). Fox toolkit. URL: http://fox-toolkit.org . Vasilev V, Canal P, Naumann A, Russo P (2012). \"Cling-the new interactive interpreter for root 6.\" In Journal of Physics: Conference Series, volume 396, p. 052071. Walt Svd, Colbert SC, Varoquaux G (2011). \"The NumPy array: a structure for efficient numerical computation.\" Computing in science & engineering,13(2), 22-30. Wei V (2020). MiniGUI. URL: http://www.minigui.com . Williams T, Kelley C, Bersch C, Broker HB, Campbell J, Cunningham R, Denholm D, Elber G, Fearick R, Grammes C,et al.(2017). \"gnuplot 5.2.\" wxWidgets (2020). WxWidgets. URL: https://wxwidgets.org . XOrg Foundation (2020). X11. URL: https://www.x.org/ . Zaitsev S (2020). Webview. URL: https://github.com/zserge/webview . Zakai A (2011). \"Emscripten: an LLVM-to-JavaScript compiler.\" In Proceedings of the ACM international conference companion on Object oriented programming systems languages and applications companion, pp. 301-312.","title":"References"},{"location":"annotations/arrow/","text":"Arrow 1 arrow ( x1 , y1 , x2 , y2 ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto a = arrow ( 2.5 , 6.5 , 5 , 5 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto a = arrow ( 2.5 , 6.5 , 5 , 5 ); a -> color ( \"blue\" ); a -> line_width ( 4 ); show (); return 0 ; }","title":"Arrow"},{"location":"annotations/arrow/#arrow","text":"1 arrow ( x1 , y1 , x2 , y2 ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto a = arrow ( 2.5 , 6.5 , 5 , 5 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto a = arrow ( 2.5 , 6.5 , 5 , 5 ); a -> color ( \"blue\" ); a -> line_width ( 4 ); show (); return 0 ; }","title":"Arrow"},{"location":"annotations/ellipse/","text":"Ellipse 1 ellipse ( x , y , w , h ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -4 , 4 ); auto y = transform ( x , []( double x ) { return pow ( x , 3 ) - 12 * x ; }); plot ( x , y ); auto e = ellipse ( -3.5 , 11 , 3.5 , 8 ); auto r = rectangle ( -3.5 , 11 , 3.5 , 8 ); r -> color ( \"red\" ); show (); return 0 ; }","title":"Ellipse"},{"location":"annotations/ellipse/#ellipse","text":"1 ellipse ( x , y , w , h ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -4 , 4 ); auto y = transform ( x , []( double x ) { return pow ( x , 3 ) - 12 * x ; }); plot ( x , y ); auto e = ellipse ( -3.5 , 11 , 3.5 , 8 ); auto r = rectangle ( -3.5 , 11 , 3.5 , 8 ); r -> color ( \"red\" ); show (); return 0 ; }","title":"Ellipse"},{"location":"annotations/filled-polygon/","text":"Filled Polygon 1 polygon ( x0 , y0 , color ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d t = iota ( 1. / 16 , 1. / 8 , 1 ); t = transform ( t , []( double t ) { return t * 2. * pi ; }); vector_1d x = transform ( t , []( double t ) { return cos ( t ); }); vector_1d y = transform ( t , []( double t ) { return sin ( t ); }); std :: string color = \"r\" ; matplot :: fill ( x , y , color ); axis ( equal ); show (); return 0 ; }","title":"Filled Polygon"},{"location":"annotations/filled-polygon/#filled-polygon","text":"1 polygon ( x0 , y0 , color ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d t = iota ( 1. / 16 , 1. / 8 , 1 ); t = transform ( t , []( double t ) { return t * 2. * pi ; }); vector_1d x = transform ( t , []( double t ) { return cos ( t ); }); vector_1d y = transform ( t , []( double t ) { return sin ( t ); }); std :: string color = \"r\" ; matplot :: fill ( x , y , color ); axis ( equal ); show (); return 0 ; }","title":"Filled Polygon"},{"location":"annotations/line/","text":"Line 1 line ( x1 , y1 , x2 , y2 ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); line ( 3 , 3 , 3 , 4 ); arrow ( 3 , 4 , 4 , 4 ); show (); return 0 ; }","title":"Line"},{"location":"annotations/line/#line","text":"1 line ( x1 , y1 , x2 , y2 ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); line ( 3 , 3 , 3 , 4 ); arrow ( 3 , 4 , 4 , 4 ); show (); return 0 ; }","title":"Line"},{"location":"annotations/rectangle/","text":"Rectangle 1 rectangle ( x , y , w , h ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d data = { 2 , 4 , 6 , 7 , 8 , 7 , 5 , 2 }; stem ( data ); auto r1 = rectangle ( 2.5 , 5.5 , 2 , 2 ); r1 -> color ( \"red\" ); auto r2 = rectangle ( 6.5 , 4.5 , 1 , 1 ); r2 -> fill ( true ); r2 -> color ({ 0.8 , 0 , 0 , 1 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; rectangle ( 0 , 0 , 2 , 4 , 0 ); rectangle ( 3 , 0 , 2 , 4 , 1 ); rectangle ( 6 , 0 , 2 , 4 , 0.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; rectangle ( 2 , 4 , 2 , 2 , 1. ); auto r2 = rectangle ( 2 , 4 , 2 , 2 , 0. ); r2 -> color ( \"red\" ); axis ( equal ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r = rectangle ( 1 , 2 , 5 , 10 ); r -> fill ( true ); r -> color ({ 0 , .5 , .5 }); r -> line_width ( 3 ); auto r2 = rectangle ( 1 , 2 , 5 , 10 ); r2 -> color ( \"blue\" ); r2 -> line_width ( 3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; using namespace std ; vector < double > x = { 0 , 8 , 8 , 0 }; vector < double > y = { 0 , 0 , 4 , 4 }; polygon ( x , y , \"g\" ); rectangle ( 0 , 0 , 2 , 4 , 0 ) -> fill ( true ). color ( \"red\" ); rectangle ( 3 , 0 , 2 , 4 , 1 ) -> fill ( true ). color ( \"magenta\" ); rectangle ( 6 , 0 , 2 , 4 , 0.5 ) -> fill ( true ). color ( \"yellow\" ); text ( 2 , 2 , \"Curvature 0\" ) -> alignment ( labels :: alignment :: right ); text ( 4 , 2 , \"Curvature 1\" ) -> alignment ( labels :: alignment :: center ); text ( 6 , 2 , \"Curvature 0.5\" ) -> alignment ( labels :: alignment :: left ); arrow ( 4 , 2.2 , 3 , 3 ); textarrow ( 6 , 1 , 8 , 0 , \"Last corner\" ); show (); return 0 ; } The rectangle object can have a border curvature from to . We can also annotate with text, arrows, polygons, and lines.","title":"Rectangle"},{"location":"annotations/rectangle/#rectangle","text":"1 rectangle ( x , y , w , h ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d data = { 2 , 4 , 6 , 7 , 8 , 7 , 5 , 2 }; stem ( data ); auto r1 = rectangle ( 2.5 , 5.5 , 2 , 2 ); r1 -> color ( \"red\" ); auto r2 = rectangle ( 6.5 , 4.5 , 1 , 1 ); r2 -> fill ( true ); r2 -> color ({ 0.8 , 0 , 0 , 1 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; rectangle ( 0 , 0 , 2 , 4 , 0 ); rectangle ( 3 , 0 , 2 , 4 , 1 ); rectangle ( 6 , 0 , 2 , 4 , 0.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; rectangle ( 2 , 4 , 2 , 2 , 1. ); auto r2 = rectangle ( 2 , 4 , 2 , 2 , 0. ); r2 -> color ( \"red\" ); axis ( equal ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r = rectangle ( 1 , 2 , 5 , 10 ); r -> fill ( true ); r -> color ({ 0 , .5 , .5 }); r -> line_width ( 3 ); auto r2 = rectangle ( 1 , 2 , 5 , 10 ); r2 -> color ( \"blue\" ); r2 -> line_width ( 3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; using namespace std ; vector < double > x = { 0 , 8 , 8 , 0 }; vector < double > y = { 0 , 0 , 4 , 4 }; polygon ( x , y , \"g\" ); rectangle ( 0 , 0 , 2 , 4 , 0 ) -> fill ( true ). color ( \"red\" ); rectangle ( 3 , 0 , 2 , 4 , 1 ) -> fill ( true ). color ( \"magenta\" ); rectangle ( 6 , 0 , 2 , 4 , 0.5 ) -> fill ( true ). color ( \"yellow\" ); text ( 2 , 2 , \"Curvature 0\" ) -> alignment ( labels :: alignment :: right ); text ( 4 , 2 , \"Curvature 1\" ) -> alignment ( labels :: alignment :: center ); text ( 6 , 2 , \"Curvature 0.5\" ) -> alignment ( labels :: alignment :: left ); arrow ( 4 , 2.2 , 3 , 3 ); textarrow ( 6 , 1 , 8 , 0 , \"Last corner\" ); show (); return 0 ; } The rectangle object can have a border curvature from to . We can also annotate with text, arrows, polygons, and lines.","title":"Rectangle"},{"location":"annotations/text-with-arrow/","text":"Text with Arrow 1 textarrow ( x1 , y1 , x2 , y2 , str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto [ t , a ] = textarrow ( 2.5 , 6.5 , 5 , 5 , \"y=x\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto [ t , a ] = textarrow ( 2.5 , 6.5 , 5 , 5 , \"y=x\" ); t -> color ( \"red\" ). font_size ( 14 ); a -> color ( \"blue\" ); show (); return 0 ; }","title":"Text with Arrow"},{"location":"annotations/text-with-arrow/#text-with-arrow","text":"1 textarrow ( x1 , y1 , x2 , y2 , str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto [ t , a ] = textarrow ( 2.5 , 6.5 , 5 , 5 , \"y=x\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto [ t , a ] = textarrow ( 2.5 , 6.5 , 5 , 5 , \"y=x\" ); t -> color ( \"red\" ). font_size ( 14 ); a -> color ( \"blue\" ); show (); return 0 ; }","title":"Text with Arrow"},{"location":"annotations/text/","text":"Text The annotations category is meant to create individual objects on the plot rather than representations of data sets. An important difference between the annotations category and other categories is that, by default, the annotations do not replace the plot that already exists in the axes object, even if the user does not call the hold function. 1 text ( x0 , y0 , str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , pi / 20 , 2 * pi ); std :: vector < double > y = transform ( x , []( auto x ) { return sin ( x ); }); plot ( x , y ); text ( pi , 0 , \"\u2190 sin(\u03c0)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -5 , + 5 ); std :: vector < double > y = transform ( x , []( auto x ) { return pow ( x , 3 ) - 12 * x ; }); plot ( x , y ); std :: vector < double > xt = { -2 , + 2 }; std :: vector < double > yt = { 16 , -16 }; std :: string str = \"dy/dx = 0\" ; text ( xt , yt , str ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -5 , + 5 ); std :: vector < double > y = transform ( x , []( auto x ) { return pow ( x , 3 ) - 12 * x ; }); plot ( x , y ); std :: vector < double > xt = { -2 , + 2 }; std :: vector < double > yt = { 16 , -16 }; std :: vector < std :: string > str = { \"local max\" , \"local min\" }; text ( xt , yt , str ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); text ( 2 , 7 , \"A simple plot \\\\ nfrom 1 to 10\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); text ({ 2 , 8 }, { 7 , 7 }, std :: vector < std :: string > ({ \"A simple plot \\\\ nfrom 1 to 10\" , \"y=x\" })); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto t = text ( 2 , 8 , \"A simple plot\" ) -> color ( \"red\" ). font_size ( 14 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -5 , + 5 ); auto y = transform ( x , []( double x ) { return pow ( x , 3 ) - 12 * x ; }); plot ( x , y ); auto t = text ({ -2 , 2 }, { 16 , -16 }, \"dy/dx=0\" ); t -> colors ({ .0 , 1. }); t -> sizes ({ 14 , 10 }); gca () -> colormap ({{ 1 , 0 , 0 }, { 0 , 0 , 0 }}); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto y = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( y ); text ( 3 , 90 , \"\u03bb_{12}^{3/2}/\u03c0 - \u03c0\u0394^{2/3}\" ); text ( 4 , 60 , \"lambda12^{3/2}/pi - pi delta^{2/3}\" ); show (); return 0 ; }","title":"Text"},{"location":"annotations/text/#text","text":"The annotations category is meant to create individual objects on the plot rather than representations of data sets. An important difference between the annotations category and other categories is that, by default, the annotations do not replace the plot that already exists in the axes object, even if the user does not call the hold function. 1 text ( x0 , y0 , str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , pi / 20 , 2 * pi ); std :: vector < double > y = transform ( x , []( auto x ) { return sin ( x ); }); plot ( x , y ); text ( pi , 0 , \"\u2190 sin(\u03c0)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -5 , + 5 ); std :: vector < double > y = transform ( x , []( auto x ) { return pow ( x , 3 ) - 12 * x ; }); plot ( x , y ); std :: vector < double > xt = { -2 , + 2 }; std :: vector < double > yt = { 16 , -16 }; std :: string str = \"dy/dx = 0\" ; text ( xt , yt , str ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -5 , + 5 ); std :: vector < double > y = transform ( x , []( auto x ) { return pow ( x , 3 ) - 12 * x ; }); plot ( x , y ); std :: vector < double > xt = { -2 , + 2 }; std :: vector < double > yt = { 16 , -16 }; std :: vector < std :: string > str = { \"local max\" , \"local min\" }; text ( xt , yt , str ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); text ( 2 , 7 , \"A simple plot \\\\ nfrom 1 to 10\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); text ({ 2 , 8 }, { 7 , 7 }, std :: vector < std :: string > ({ \"A simple plot \\\\ nfrom 1 to 10\" , \"y=x\" })); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); auto t = text ( 2 , 8 , \"A simple plot\" ) -> color ( \"red\" ). font_size ( 14 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -5 , + 5 ); auto y = transform ( x , []( double x ) { return pow ( x , 3 ) - 12 * x ; }); plot ( x , y ); auto t = text ({ -2 , 2 }, { 16 , -16 }, \"dy/dx=0\" ); t -> colors ({ .0 , 1. }); t -> sizes ({ 14 , 10 }); gca () -> colormap ({{ 1 , 0 , 0 }, { 0 , 0 , 0 }}); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto y = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( y ); text ( 3 , 90 , \"\u03bb_{12}^{3/2}/\u03c0 - \u03c0\u0394^{2/3}\" ); text ( 4 , 60 , \"lambda12^{3/2}/pi - pi delta^{2/3}\" ); show (); return 0 ; }","title":"Text"},{"location":"annotations/textbox/","text":"Textbox 1 textbox ( x , y , w , h , str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); textbox ( 2 , 8 , 4 , 0.5 , \"String line from 1 to 10\" ); show (); return 0 ; }","title":"Textbox"},{"location":"annotations/textbox/#textbox","text":"1 textbox ( x , y , w , h , str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); textbox ( 2 , 8 , 4 , 0.5 , \"String line from 1 to 10\" ); show (); return 0 ; }","title":"Textbox"},{"location":"appearance/axes-object/","text":"Axes Object 1 auto ax1 = gca (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ax1 = gca (); axis ({ -100 , + 100 , -30 , + 30 }); fplot ( ax1 , \"3*cos(3*x) + tan(x)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto ax1 = axes ({ 0.1 , 0.1 , 0.7 , 0.7 }); auto ax2 = axes ({ 0.65 , 0.65 , 0.28 , 0.28 }); auto [ X , Y , Z ] = peaks ( 20 ); contour ( ax1 , X , Y , Z ); colorbar ( ax1 , off ); surf ( ax2 , X , Y , Z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto ax1 = axes ({ 0.1 , 0.1 , 0.6 , 0.6 }); auto ax2 = axes ({ 0.35 , 0.35 , 0.6 , 0.6 }); ax1 -> box ( true ); ax2 -> box ( true ); axes ( ax1 ); auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); show (); return 0 ; }","title":"Axes Object"},{"location":"appearance/axes-object/#axes-object","text":"1 auto ax1 = gca (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ax1 = gca (); axis ({ -100 , + 100 , -30 , + 30 }); fplot ( ax1 , \"3*cos(3*x) + tan(x)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto ax1 = axes ({ 0.1 , 0.1 , 0.7 , 0.7 }); auto ax2 = axes ({ 0.65 , 0.65 , 0.28 , 0.28 }); auto [ X , Y , Z ] = peaks ( 20 ); contour ( ax1 , X , Y , Z ); colorbar ( ax1 , off ); surf ( ax2 , X , Y , Z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto ax1 = axes ({ 0.1 , 0.1 , 0.6 , 0.6 }); auto ax2 = axes ({ 0.35 , 0.35 , 0.6 , 0.6 }); ax1 -> box ( true ); ax2 -> box ( true ); axes ( ax1 ); auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); show (); return 0 ; }","title":"Axes Object"},{"location":"appearance/clear-axes/","text":"Clear Axes 1 cla (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 2 * pi ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y1 ); hold ( on ); auto y2 = transform ( x , []( double x ) { return sin ( 2 * x ); }); plot ( x , y2 ); cla (); auto y3 = transform ( x , []( double x ) { return sin ( 3 * x ); }); plot ( x , y3 ); hold ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); auto [ x , y , z ] = peaks (); surf ( x , y , z ); auto ax2 = nexttile (); contour ( x , y , z ); cla ( ax1 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 2 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); axis ({ 0 , 5 , -2 , 2 }); cla (); show (); return 0 ; }","title":"Clear Axes"},{"location":"appearance/clear-axes/#clear-axes","text":"1 cla (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 2 * pi ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y1 ); hold ( on ); auto y2 = transform ( x , []( double x ) { return sin ( 2 * x ); }); plot ( x , y2 ); cla (); auto y3 = transform ( x , []( double x ) { return sin ( 3 * x ); }); plot ( x , y3 ); hold ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); auto [ x , y , z ] = peaks (); surf ( x , y , z ); auto ax2 = nexttile (); contour ( x , y , z ); cla ( ax1 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 2 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); axis ({ 0 , 5 , -2 , 2 }); cla (); show (); return 0 ; }","title":"Clear Axes"},{"location":"appearance/figure-object/","text":"Figure Object 1 figure (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <iostream> #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto h = figure (); auto ax = h -> current_axes (); fplot ( ax , \"cos(x)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <matplot/matplot.h> int main () { using namespace matplot ; auto h = figure ( true ); h -> name ( \"Measured Data\" ); h -> number_title ( false ); h -> color ( \"green\" ); h -> position ({ 0 , 0 , 600 , 600 }); h -> size ( 500 , 500 ); h -> draw (); h -> font ( \"Arial\" ); h -> font_size ( 40 ); h -> title ( \"My experiment\" ); constexpr double pi = 3.14 ; axis ({ - pi , pi , -1.5 , + 1.5 }); fplot ( \"cos(x)\" ); h -> draw (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f1 = figure (); auto f2 = figure (); plot ( vector_1d { 1. , 2. , 3. }, vector_1d { 2. , 4. , 6. }); figure ( f1 ); scatter ( iota ( 1 , 20 ), rand ( 20 , 0 , 1 )); show (); return 0 ; }","title":"Figure Object"},{"location":"appearance/figure-object/#figure-object","text":"1 figure (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <iostream> #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto h = figure (); auto ax = h -> current_axes (); fplot ( ax , \"cos(x)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <matplot/matplot.h> int main () { using namespace matplot ; auto h = figure ( true ); h -> name ( \"Measured Data\" ); h -> number_title ( false ); h -> color ( \"green\" ); h -> position ({ 0 , 0 , 600 , 600 }); h -> size ( 500 , 500 ); h -> draw (); h -> font ( \"Arial\" ); h -> font_size ( 40 ); h -> title ( \"My experiment\" ); constexpr double pi = 3.14 ; axis ({ - pi , pi , -1.5 , + 1.5 }); fplot ( \"cos(x)\" ); h -> draw (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f1 = figure (); auto f2 = figure (); plot ( vector_1d { 1. , 2. , 3. }, vector_1d { 2. , 4. , 6. }); figure ( f1 ); scatter ( iota ( 1 , 20 ), rand ( 20 , 0 , 1 )); show (); return 0 ; }","title":"Figure Object"},{"location":"appearance/line-specs/","text":"Line Specs 1 fplot ( fn , spec_str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; fplot ( \"sin(x)\" , \"-.r*\" ); hold ( on ); fplot ( \"sin(x-pi/2)\" , \"--mo\" ); fplot ( \"sin(x-pi)\" , \":bs\" ); show (); return 0 ; }","title":"Line Specs"},{"location":"appearance/line-specs/#line-specs","text":"1 fplot ( fn , spec_str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; fplot ( \"sin(x)\" , \"-.r*\" ); hold ( on ); fplot ( \"sin(x-pi/2)\" , \"--mo\" ); fplot ( \"sin(x-pi)\" , \":bs\" ); show (); return 0 ; }","title":"Line Specs"},{"location":"appearance/axis/adjust-axis/","text":"Adjust Axis 1 axis ({ xmin , xmax , ymin , ymax }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; fplot ( \"sin(x)\" , \"-o\" ); axis ({ 0 , 2 * pi , -1.15 , 1.5 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; fplot ( \"sin(4*x)/exp(0.1*x)\" ); axis ({ -10 , + 10 , 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); fplot ( ax1 , \"sin(x)\" ); auto ax2 = nexttile (); fplot ( ax2 , \"x < 5 ? sin(x) : -1\" ); axis ({ ax1 , ax2 }, { 0 , 10 , -1 , 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); axis ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); axis ( tight ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto c = eye ( 10 ); pcolor ( c ); colormap ( palette :: summer ()); axis ( ij ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); auto y2 = transform ( x , []( double x ) { return 2 * sin ( x ); }); hold ( on ); axis ( manual ); axis ({ 0 , 10 , -1 , + 1 }); plot ( x , y2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); auto y2 = transform ( x , []( double x ) { return 2 * sin ( x ); }); hold ( on ); axis ( manual ); axis ({ 0 , 10 , -1 , + 1 }); plot ( x , y2 ); hold ( off ); axis ( automatic ); show (); return 0 ; }","title":"Adjust Axis"},{"location":"appearance/axis/adjust-axis/#adjust-axis","text":"1 axis ({ xmin , xmax , ymin , ymax }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; fplot ( \"sin(x)\" , \"-o\" ); axis ({ 0 , 2 * pi , -1.15 , 1.5 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; fplot ( \"sin(4*x)/exp(0.1*x)\" ); axis ({ -10 , + 10 , 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); fplot ( ax1 , \"sin(x)\" ); auto ax2 = nexttile (); fplot ( ax2 , \"x < 5 ? sin(x) : -1\" ); axis ({ ax1 , ax2 }, { 0 , 10 , -1 , 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); axis ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); axis ( tight ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto c = eye ( 10 ); pcolor ( c ); colormap ( palette :: summer ()); axis ( ij ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); auto y2 = transform ( x , []( double x ) { return 2 * sin ( x ); }); hold ( on ); axis ( manual ); axis ({ 0 , 10 , -1 , + 1 }); plot ( x , y2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); auto y2 = transform ( x , []( double x ) { return 2 * sin ( x ); }); hold ( on ); axis ( manual ); axis ({ 0 , 10 , -1 , + 1 }); plot ( x , y2 ); hold ( off ); axis ( automatic ); show (); return 0 ; }","title":"Adjust Axis"},{"location":"appearance/axis/box/","text":"Box 1 box ( on ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); box ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); box ( on ); auto ax = gca (); ax -> box_full ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , iota ( 1 , 10 )); auto ax2 = nexttile (); plot ( ax2 , iota ( 1 , 10 )); box ( ax2 , off ); show (); return 0 ; }","title":"Box"},{"location":"appearance/axis/box/#box","text":"1 box ( on ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); box ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); box ( on ); auto ax = gca (); ax -> box_full ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , iota ( 1 , 10 )); auto ax2 = nexttile (); plot ( ax2 , iota ( 1 , 10 )); box ( ax2 , off ); show (); return 0 ; }","title":"Box"},{"location":"appearance/axis/x-limits/","text":"X Limits 1 xlim ({ xmin , xmax }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ({ 0 , 5 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); xlim ({ 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = linspace ( 0 , 5 , 1000 ); auto y = transform ( x , []( double x ) { return sin ( 100 * x ) / exp ( x ); }); auto ax1 = nexttile (); plot ( ax1 , x , y ); auto ax2 = nexttile (); plot ( ax2 , x , y ); xlim ( ax2 , { 0 , 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ( manual ); xlim ({ 0 , 10 }); hold ( on ); auto x2 = transform ( x , []( double x ) { return 2 * x ; }); auto y2 = transform ( y , []( double y ) { return 2 * y ; }); plot ( x2 , y2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ( manual ); xlim ({ 0 , 10 }); hold ( on ); auto x2 = transform ( x , []( double x ) { return 2 * x ; }); auto y2 = transform ( y , []( double y ) { return 2 * y ; }); plot ( x2 , y2 ); hold ( off ); xlim ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = randn ( 50 , 0 , 1 ); auto y = randn ( 50 , 0 , 1 ); scatter ( x , y ); auto xl = xlim (); std :: cout << \"xl[0]: \" << xl [ 0 ] << std :: endl ; std :: cout << \"xl[1]: \" << xl [ 1 ] << std :: endl ; show (); return 0 ; }","title":"X Limits"},{"location":"appearance/axis/x-limits/#x-limits","text":"1 xlim ({ xmin , xmax }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ({ 0 , 5 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); xlim ({ 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = linspace ( 0 , 5 , 1000 ); auto y = transform ( x , []( double x ) { return sin ( 100 * x ) / exp ( x ); }); auto ax1 = nexttile (); plot ( ax1 , x , y ); auto ax2 = nexttile (); plot ( ax2 , x , y ); xlim ( ax2 , { 0 , 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ( manual ); xlim ({ 0 , 10 }); hold ( on ); auto x2 = transform ( x , []( double x ) { return 2 * x ; }); auto y2 = transform ( y , []( double y ) { return 2 * y ; }); plot ( x2 , y2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ( manual ); xlim ({ 0 , 10 }); hold ( on ); auto x2 = transform ( x , []( double x ) { return 2 * x ; }); auto y2 = transform ( y , []( double y ) { return 2 * y ; }); plot ( x2 , y2 ); hold ( off ); xlim ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = randn ( 50 , 0 , 1 ); auto y = randn ( 50 , 0 , 1 ); scatter ( x , y ); auto xl = xlim (); std :: cout << \"xl[0]: \" << xl [ 0 ] << std :: endl ; std :: cout << \"xl[1]: \" << xl [ 1 ] << std :: endl ; show (); return 0 ; }","title":"X Limits"},{"location":"appearance/axis/y-limits/","text":"Y Limits 1 ylim ({ ymin , ymax }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); ylim ({ -2 , + 2 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); ylim ({ 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = linspace ( 0 , 10 , 1000 ); auto y = transform ( x , []( double x ) { return sin ( 10 * x ) * exp ( .5 * x ); }); auto ax1 = nexttile (); plot ( ax1 , x , y ); auto ax2 = nexttile (); plot ( ax2 , x , y ); ylim ( ax2 , { -10 , 10 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); ylim ( manual ); ylim ({ -1 , + 1 }); hold ( on ); auto y2 = transform ( x , []( double x ) { return 2 * sin ( x ); }); plot ( x , y2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); ylim ( manual ); ylim ({ -1 , + 1 }); hold ( on ); auto y2 = transform ( x , []( double x ) { return 2 * sin ( x ); }); plot ( x , y2 ); hold ( off ); ylim ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = randn ( 50 , 0 , 1 ); auto y = randn ( 50 , 0 , 1 ); scatter ( x , y ); auto yl = ylim (); std :: cout << \"yl[0]: \" << yl [ 0 ] << std :: endl ; std :: cout << \"yl[1]: \" << yl [ 1 ] << std :: endl ; show (); return 0 ; }","title":"Y Limits"},{"location":"appearance/axis/y-limits/#y-limits","text":"1 ylim ({ ymin , ymax }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); ylim ({ -2 , + 2 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); ylim ({ 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = linspace ( 0 , 10 , 1000 ); auto y = transform ( x , []( double x ) { return sin ( 10 * x ) * exp ( .5 * x ); }); auto ax1 = nexttile (); plot ( ax1 , x , y ); auto ax2 = nexttile (); plot ( ax2 , x , y ); ylim ( ax2 , { -10 , 10 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); ylim ( manual ); ylim ({ -1 , + 1 }); hold ( on ); auto y2 = transform ( x , []( double x ) { return 2 * sin ( x ); }); plot ( x , y2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); ylim ( manual ); ylim ({ -1 , + 1 }); hold ( on ); auto y2 = transform ( x , []( double x ) { return 2 * sin ( x ); }); plot ( x , y2 ); hold ( off ); ylim ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = randn ( 50 , 0 , 1 ); auto y = randn ( 50 , 0 , 1 ); scatter ( x , y ); auto yl = ylim (); std :: cout << \"yl[0]: \" << yl [ 0 ] << std :: endl ; std :: cout << \"yl[1]: \" << yl [ 1 ] << std :: endl ; show (); return 0 ; }","title":"Y Limits"},{"location":"appearance/axis/z-limits/","text":"Z Limits 1 zlim ({ zmin , zmax }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); zlim ({ -5 , 5 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); mesh ( X , Y , Z ); zlim ({ 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); surf ( ax1 , X , Y , Z ); auto ax2 = nexttile (); surf ( ax2 , X , Y , Z ); zlim ( ax2 , { -5 , 5 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto theta = linspace ( 0 , 2 * pi ); auto x = transform ( theta , []( double theta ) { return cos ( theta ); }); auto y = transform ( theta , []( double theta ) { return sin ( theta ); }); auto z = theta ; scatter3 ( x , y , z ); zlim ( manual ); zlim ({ 0 , 2 * pi }); hold ( on ); auto z2 = transform ( theta , []( double theta ) { return 5 * theta ; }); scatter3 ( x , y , z2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto theta = linspace ( 0 , 2 * pi ); auto x = transform ( theta , []( double theta ) { return cos ( theta ); }); auto y = transform ( theta , []( double theta ) { return sin ( theta ); }); auto z = theta ; scatter3 ( x , y , z ); zlim ( manual ); zlim ({ 0 , 2 * pi }); hold ( on ); auto z2 = transform ( theta , []( double theta ) { return 5 * theta ; }); scatter3 ( x , y , z2 ); hold ( off ); zlim ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = randn ( 50 , 0 , 1 ); auto y = randn ( 50 , 0 , 1 ); auto z = randn ( 50 , 0 , 1 ); scatter3 ( x , y , z ); auto zl = zlim (); std :: cout << \"zl[0]: \" << zl [ 0 ] << std :: endl ; std :: cout << \"zl[1]: \" << zl [ 1 ] << std :: endl ; show (); return 0 ; }","title":"Z Limits"},{"location":"appearance/axis/z-limits/#z-limits","text":"1 zlim ({ zmin , zmax }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); zlim ({ -5 , 5 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); mesh ( X , Y , Z ); zlim ({ 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); surf ( ax1 , X , Y , Z ); auto ax2 = nexttile (); surf ( ax2 , X , Y , Z ); zlim ( ax2 , { -5 , 5 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto theta = linspace ( 0 , 2 * pi ); auto x = transform ( theta , []( double theta ) { return cos ( theta ); }); auto y = transform ( theta , []( double theta ) { return sin ( theta ); }); auto z = theta ; scatter3 ( x , y , z ); zlim ( manual ); zlim ({ 0 , 2 * pi }); hold ( on ); auto z2 = transform ( theta , []( double theta ) { return 5 * theta ; }); scatter3 ( x , y , z2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto theta = linspace ( 0 , 2 * pi ); auto x = transform ( theta , []( double theta ) { return cos ( theta ); }); auto y = transform ( theta , []( double theta ) { return sin ( theta ); }); auto z = theta ; scatter3 ( x , y , z ); zlim ( manual ); zlim ({ 0 , 2 * pi }); hold ( on ); auto z2 = transform ( theta , []( double theta ) { return 5 * theta ; }); scatter3 ( x , y , z2 ); hold ( off ); zlim ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto x = randn ( 50 , 0 , 1 ); auto y = randn ( 50 , 0 , 1 ); auto z = randn ( 50 , 0 , 1 ); scatter3 ( x , y , z ); auto zl = zlim (); std :: cout << \"zl[0]: \" << zl [ 0 ] << std :: endl ; std :: cout << \"zl[1]: \" << zl [ 1 ] << std :: endl ; show (); return 0 ; }","title":"Z Limits"},{"location":"appearance/camera/lighting/","text":"Lighting 1 surf ( x , y , z ) -> lighting ( true ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ). primary ( 0.2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ). primary ( 0.8 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ). specular ( 0.2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ). specular ( 0.8 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); subplot ( 3 , 3 , 0 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.0 ). specular ( 0.0 ); subplot ( 3 , 3 , 1 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.5 ). specular ( 0.0 ); subplot ( 3 , 3 , 2 ); surf ( x , y , z ) -> lighting ( true ). primary ( 1.0 ). specular ( 0.0 ); subplot ( 3 , 3 , 3 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.0 ). specular ( 0.5 ); subplot ( 3 , 3 , 4 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.5 ). specular ( 0.5 ); subplot ( 3 , 3 , 5 ); surf ( x , y , z ) -> lighting ( true ). primary ( 1.0 ). specular ( 0.5 ); subplot ( 3 , 3 , 6 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.0 ). specular ( 1.0 ); subplot ( 3 , 3 , 7 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.5 ). specular ( 1.0 ); subplot ( 3 , 3 , 8 ); surf ( x , y , z ) -> lighting ( true ). primary ( 1.0 ). specular ( 1.0 ); show (); return 0 ; }","title":"Lighting"},{"location":"appearance/camera/lighting/#lighting","text":"1 surf ( x , y , z ) -> lighting ( true ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ). primary ( 0.2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ). primary ( 0.8 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ). specular ( 0.2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ) -> lighting ( true ). specular ( 0.8 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); subplot ( 3 , 3 , 0 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.0 ). specular ( 0.0 ); subplot ( 3 , 3 , 1 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.5 ). specular ( 0.0 ); subplot ( 3 , 3 , 2 ); surf ( x , y , z ) -> lighting ( true ). primary ( 1.0 ). specular ( 0.0 ); subplot ( 3 , 3 , 3 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.0 ). specular ( 0.5 ); subplot ( 3 , 3 , 4 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.5 ). specular ( 0.5 ); subplot ( 3 , 3 , 5 ); surf ( x , y , z ) -> lighting ( true ). primary ( 1.0 ). specular ( 0.5 ); subplot ( 3 , 3 , 6 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.0 ). specular ( 1.0 ); subplot ( 3 , 3 , 7 ); surf ( x , y , z ) -> lighting ( true ). primary ( 0.5 ). specular ( 1.0 ); subplot ( 3 , 3 , 8 ); surf ( x , y , z ) -> lighting ( true ). primary ( 1.0 ). specular ( 1.0 ); show (); return 0 ; }","title":"Lighting"},{"location":"appearance/camera/view/","text":"View 1 view ( az , el ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); view ( 90 , 0 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); view ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto z = transform ( x , y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); surf ( x , y , z ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); auto [ az , el ] = view (); std :: cout << \"az: \" << az << std :: endl ; std :: cout << \"el: \" << el << std :: endl ; auto [ naz , nel ] = view ( -5 , -2 , 5 ); std :: cout << \"naz: \" << naz << std :: endl ; std :: cout << \"nel: \" << nel << std :: endl ; show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 20 , 10 * pi ); auto xt1 = transform ( t , []( double t ) { return sin ( t ); }); auto yt1 = transform ( t , []( double t ) { return cos ( t ); }); tiledlayout ( 1 , 2 ); auto ax1 = nexttile (); plot3 ( ax1 , xt1 , yt1 , t ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); auto ax2 = nexttile (); plot3 ( ax2 , xt1 , yt1 , t ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); view ( ax2 , 90 , 0 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks ( 20 ); auto s = surf ( x , y , z ); xlabel ( \"x-axis\" ); ylabel ( \"y-axis\" ); zlabel ( \"z-axis\" ); rotate ( 20 , 30 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ackley = []( double x , double y ) { return -20 * exp ( -0.2 * sqrt ( 0.5 * ( pow ( x , 2 ) + pow ( y , 2 )))) - exp ( 0.5 * ( cos ( 2 * pi * x ) + cos ( 2 * pi * y ))) + exp ( 1 ) + 20 ; }; gcf () -> width ( gcf () -> width () * 2 ); subplot ( 1 , 2 , 0 ); fsurf ( ackley ) -> lighting ( true ). primary ( 0.7 ). specular ( 0.9 ); subplot ( 1 , 2 , 1 ); fsurf ( ackley ); rotate ( 20 , 30 ); show (); return 0 ; }","title":"View"},{"location":"appearance/camera/view/#view","text":"1 view ( az , el ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); view ( 90 , 0 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); view ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto z = transform ( x , y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); surf ( x , y , z ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); auto [ az , el ] = view (); std :: cout << \"az: \" << az << std :: endl ; std :: cout << \"el: \" << el << std :: endl ; auto [ naz , nel ] = view ( -5 , -2 , 5 ); std :: cout << \"naz: \" << naz << std :: endl ; std :: cout << \"nel: \" << nel << std :: endl ; show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 20 , 10 * pi ); auto xt1 = transform ( t , []( double t ) { return sin ( t ); }); auto yt1 = transform ( t , []( double t ) { return cos ( t ); }); tiledlayout ( 1 , 2 ); auto ax1 = nexttile (); plot3 ( ax1 , xt1 , yt1 , t ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); auto ax2 = nexttile (); plot3 ( ax2 , xt1 , yt1 , t ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); view ( ax2 , 90 , 0 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks ( 20 ); auto s = surf ( x , y , z ); xlabel ( \"x-axis\" ); ylabel ( \"y-axis\" ); zlabel ( \"z-axis\" ); rotate ( 20 , 30 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ackley = []( double x , double y ) { return -20 * exp ( -0.2 * sqrt ( 0.5 * ( pow ( x , 2 ) + pow ( y , 2 )))) - exp ( 0.5 * ( cos ( 2 * pi * x ) + cos ( 2 * pi * y ))) + exp ( 1 ) + 20 ; }; gcf () -> width ( gcf () -> width () * 2 ); subplot ( 1 , 2 , 0 ); fsurf ( ackley ) -> lighting ( true ). primary ( 0.7 ). specular ( 0.9 ); subplot ( 1 , 2 , 1 ); fsurf ( ackley ); rotate ( 20 , 30 ); show (); return 0 ; }","title":"View"},{"location":"appearance/colormaps/color-bar/","text":"Color Bar 1 colorbar (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colorbar (); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); contourf ( x , y , z , 20 ); gca () -> cb_position ({ 0 , 0 , 1 , 0.06 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colorbar (). reverse ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); tiledlayout ( 2 , 1 ); nexttile (); surf ( x , y , z ); colorbar (); nexttile (); mesh ( x , y , z ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); contourf ( x , y , z ); colorbar () . limits ({ -6 , 8 }) . tick_values ({ -5 , -2 , 1 , 4 , 7 }) . ticklabels ({ \"Cold\" , \"Cool\" , \"Neutral\" , \"Warm\" , \"Hot\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; std :: vector < std :: vector < double >> map = {{ 0 , 0 , 0.3 }, { 0 , 0 , 0.4 }, { 0 , 0 , 0.5 }, { 0 , 0 , 0.6 }, { 0 , 0 , 0.8 }, { 0 , 0 , 1 }}; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colorbar (). label ( \"Elevation (ft in 1000s)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colorbar ( on ); colorbar ( off ); show (); return 0 ; }","title":"Color Bar"},{"location":"appearance/colormaps/color-bar/#color-bar","text":"1 colorbar (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colorbar (); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); contourf ( x , y , z , 20 ); gca () -> cb_position ({ 0 , 0 , 1 , 0.06 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colorbar (). reverse ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); tiledlayout ( 2 , 1 ); nexttile (); surf ( x , y , z ); colorbar (); nexttile (); mesh ( x , y , z ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); contourf ( x , y , z ); colorbar () . limits ({ -6 , 8 }) . tick_values ({ -5 , -2 , 1 , 4 , 7 }) . ticklabels ({ \"Cold\" , \"Cool\" , \"Neutral\" , \"Warm\" , \"Hot\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; std :: vector < std :: vector < double >> map = {{ 0 , 0 , 0.3 }, { 0 , 0 , 0.4 }, { 0 , 0 , 0.5 }, { 0 , 0 , 0.6 }, { 0 , 0 , 0.8 }, { 0 , 0 , 1 }}; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colorbar (). label ( \"Elevation (ft in 1000s)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colorbar ( on ); colorbar ( off ); show (); return 0 ; }","title":"Color Bar"},{"location":"appearance/colormaps/colormap/","text":"Colormap As a convenience, the colors.h header contains many functions to generate colors from strings and vice-versa. 1 colormap ( colors ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colormap ( palette :: winter ()); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colormap ( palette :: summer ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colormap ( palette :: summer ()); colormap ( palette :: default_map ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); tiledlayout (); auto ax1 = nexttile (); surf ( x , y , z ); colormap ( ax1 , palette :: spring ()); auto ax2 = nexttile (); surf ( x , y , z ); colormap ( ax2 , palette :: winter ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); mesh ( x , y , z ); colormap ( palette :: parula ( 5 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; std :: vector < std :: vector < double >> map = {{ 0 , 0 , 0.3 }, { 0 , 0 , 0.4 }, { 0 , 0 , 0.5 }, { 0 , 0 , 0.6 }, { 0 , 0 , 0.8 }, { 0 , 0 , 1 }}; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colormap ( map ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); mesh ( x , y , z ); colormap ( palette :: autumn ( 5 )); auto cmap = colormap (); for ( const auto & color : cmap ) { std :: cout << \"r: \" << color [ 0 ] << \", g: \" << color [ 1 ] << \", b: \" << color [ 2 ] << std :: endl ; } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> #include <vector> int main () { using namespace matplot ; tiledlayout (); auto ax1 = nexttile (); auto [ x , y , z ] = peaks (); contourf ( x , y , z ); colormap ( ax1 , palette :: hot ( 8 )); auto ax2 = nexttile (); contourf ( x , y , z ); colormap ( ax2 , palette :: pink ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <vector> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double X , double Y ) { return pow ( X , 2 ) + pow ( Y , 2 ); }); surf ( X , Y , Z ); colorbar (); caxis ({ 20 , 50 }); show (); return 0 ; }","title":"Colormap"},{"location":"appearance/colormaps/colormap/#colormap","text":"As a convenience, the colors.h header contains many functions to generate colors from strings and vice-versa. 1 colormap ( colors ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colormap ( palette :: winter ()); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colormap ( palette :: summer ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colormap ( palette :: summer ()); colormap ( palette :: default_map ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); tiledlayout (); auto ax1 = nexttile (); surf ( x , y , z ); colormap ( ax1 , palette :: spring ()); auto ax2 = nexttile (); surf ( x , y , z ); colormap ( ax2 , palette :: winter ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); mesh ( x , y , z ); colormap ( palette :: parula ( 5 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; std :: vector < std :: vector < double >> map = {{ 0 , 0 , 0.3 }, { 0 , 0 , 0.4 }, { 0 , 0 , 0.5 }, { 0 , 0 , 0.6 }, { 0 , 0 , 0.8 }, { 0 , 0 , 1 }}; auto [ x , y , z ] = peaks (); surf ( x , y , z ); colormap ( map ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); mesh ( x , y , z ); colormap ( palette :: autumn ( 5 )); auto cmap = colormap (); for ( const auto & color : cmap ) { std :: cout << \"r: \" << color [ 0 ] << \", g: \" << color [ 1 ] << \", b: \" << color [ 2 ] << std :: endl ; } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> #include <vector> int main () { using namespace matplot ; tiledlayout (); auto ax1 = nexttile (); auto [ x , y , z ] = peaks (); contourf ( x , y , z ); colormap ( ax1 , palette :: hot ( 8 )); auto ax2 = nexttile (); contourf ( x , y , z ); colormap ( ax2 , palette :: pink ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <vector> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double X , double Y ) { return pow ( X , 2 ) + pow ( Y , 2 ); }); surf ( X , Y , Z ); colorbar (); caxis ({ 20 , 50 }); show (); return 0 ; }","title":"Colormap"},{"location":"appearance/colormaps/rgb-plot/","text":"RGB Plot 1 rgbplot ( colors ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; rgbplot ( palette :: parula ()); hold ( on ); colormap ( palette :: parula ()); colorbar (). tick_values ({}); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; auto r = iota ( 0 , .1 , .9 ); auto g = transform ( r , []( double r ) { return pow ( r , 1.8 ); }); auto b = transform ( r , []( double r ) { return pow ( r , 2.1 ); }); vector_2d mymap_channels { r , g , b }; auto mymap = transpose ( mymap_channels ); rgbplot ( mymap ); hold ( on ); colormap ( mymap ); colorbar (). tick_values ({}); show (); return 0 ; }","title":"RGB Plot"},{"location":"appearance/colormaps/rgb-plot/#rgb-plot","text":"1 rgbplot ( colors ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; rgbplot ( palette :: parula ()); hold ( on ); colormap ( palette :: parula ()); colorbar (). tick_values ({}); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; auto r = iota ( 0 , .1 , .9 ); auto g = transform ( r , []( double r ) { return pow ( r , 1.8 ); }); auto b = transform ( r , []( double r ) { return pow ( r , 2.1 ); }); vector_2d mymap_channels { r , g , b }; auto mymap = transpose ( mymap_channels ); rgbplot ( mymap ); hold ( on ); colormap ( mymap ); colorbar (). tick_values ({}); show (); return 0 ; }","title":"RGB Plot"},{"location":"appearance/grid/grid-background/","text":"Grid Background 1 grid ( on ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); grid ( on ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); grid ( off ); box ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); grid ( on ); gca () -> minor_grid ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); auto y2 = transform ( x , []( double x ) { return sin ( 3 * x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x , y1 ); auto ax2 = nexttile (); plot ( ax2 , x , y2 ); grid ( ax2 , on ); show (); return 0 ; }","title":"Grid Background"},{"location":"appearance/grid/grid-background/#grid-background","text":"1 grid ( on ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); grid ( on ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); grid ( off ); box ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); grid ( on ); gca () -> minor_grid ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); auto y2 = transform ( x , []( double x ) { return sin ( 3 * x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x , y1 ); auto ax2 = nexttile (); plot ( ax2 , x , y2 ); grid ( ax2 , on ); show (); return 0 ; }","title":"Grid Background"},{"location":"appearance/grid/x-tick-angle/","text":"X Tick Angle 1 xtickangle ( ang ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10000 , 21 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem ( x , y ); xtickangle ( 45 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , rand ( 6 , 6 , 0 , 1 )); auto ax2 = nexttile (); plot ( ax2 , rand ( 6 , 6 , 0 , 1 )); xtickangle ( ax2 , 45 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10000 , 21 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem ( x , y ); std :: cout << \"xtickangle(): \" << xtickangle () << std :: endl ; show (); return 0 ; }","title":"X Tick Angle"},{"location":"appearance/grid/x-tick-angle/#x-tick-angle","text":"1 xtickangle ( ang ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10000 , 21 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem ( x , y ); xtickangle ( 45 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , rand ( 6 , 6 , 0 , 1 )); auto ax2 = nexttile (); plot ( ax2 , rand ( 6 , 6 , 0 , 1 )); xtickangle ( ax2 , 45 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10000 , 21 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem ( x , y ); std :: cout << \"xtickangle(): \" << xtickangle () << std :: endl ; show (); return 0 ; }","title":"X Tick Angle"},{"location":"appearance/grid/x-tick-format/","text":"X Tick Format 1 xtickformat ( fmtstr ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 20 , 100 ); vector_1d y = { 88 , 67 , 98 , 43 , 45 , 65 }; bar ( x , y ); xtickformat ( \"usd\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 20 , 100 ); vector_1d y = { 88 , 67 , 98 , 43 , 45 , 65 }; bar ( x , y ); xtickformat ( \"usd\" ); std :: cout << \"xtickformat(): \" << xtickformat () << std :: endl ; xtickformat ( \"$%.0f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 10 ); vector_1d y = { .17 , .25 , .27 , .28 , .3 , .32 , .33 , .34 , .345 , .35 }; plot ( x , y , \"-v\" ); xtickformat ( \"%g GHz\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 1 , 100 ); vector_1d y = transform ( x , randn ( 100 , 0. , 1. ), []( double x , double r ) { return r * cos ( x ); }); scatter ( x , y ); xtickformat ( \"%.2f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , rand ( 6 , 6 , 0 , 1 )); auto ax2 = nexttile (); plot ( ax2 , rand ( 6 , 6 , 0 , 1 )); xtickformat ( ax2 , \"usd\" ); show (); return 0 ; }","title":"X Tick Format"},{"location":"appearance/grid/x-tick-format/#x-tick-format","text":"1 xtickformat ( fmtstr ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 20 , 100 ); vector_1d y = { 88 , 67 , 98 , 43 , 45 , 65 }; bar ( x , y ); xtickformat ( \"usd\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 20 , 100 ); vector_1d y = { 88 , 67 , 98 , 43 , 45 , 65 }; bar ( x , y ); xtickformat ( \"usd\" ); std :: cout << \"xtickformat(): \" << xtickformat () << std :: endl ; xtickformat ( \"$%.0f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 10 ); vector_1d y = { .17 , .25 , .27 , .28 , .3 , .32 , .33 , .34 , .345 , .35 }; plot ( x , y , \"-v\" ); xtickformat ( \"%g GHz\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 1 , 100 ); vector_1d y = transform ( x , randn ( 100 , 0. , 1. ), []( double x , double r ) { return r * cos ( x ); }); scatter ( x , y ); xtickformat ( \"%.2f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , rand ( 6 , 6 , 0 , 1 )); auto ax2 = nexttile (); plot ( ax2 , rand ( 6 , 6 , 0 , 1 )); xtickformat ( ax2 , \"usd\" ); show (); return 0 ; }","title":"X Tick Format"},{"location":"appearance/grid/x-tick-labels/","text":"X Tick Labels 1 xticklabels ( xstrs ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); auto ax2 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); xticks ({ 1 , 2 , 3 }); xticklabels ({ \"one\" , \"two\" , \"three\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); xticks ({ 1 , 4 , 6 , 10 }); xticklabels ({ \"A\" , \"B\" , \"C\" , \"D\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); xticks ({ 1 , 4 , 6 , 10 }); xticklabels ({ \"A\" , \"B\" , \"C\" , \"D\" }); xticks ( automatic ); xticklabels ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( rand ( 5 , 5 , 0 , 1 )); xticklabels ({}); show (); return 0 ; }","title":"X Tick Labels"},{"location":"appearance/grid/x-tick-labels/#x-tick-labels","text":"1 xticklabels ( xstrs ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); auto ax2 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); xticks ({ 1 , 2 , 3 }); xticklabels ({ \"one\" , \"two\" , \"three\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); xticks ({ 1 , 4 , 6 , 10 }); xticklabels ({ \"A\" , \"B\" , \"C\" , \"D\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); xticks ({ 1 , 4 , 6 , 10 }); xticklabels ({ \"A\" , \"B\" , \"C\" , \"D\" }); xticks ( automatic ); xticklabels ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( rand ( 5 , 5 , 0 , 1 )); xticklabels ({}); show (); return 0 ; }","title":"X Tick Labels"},{"location":"appearance/grid/x-ticks/","text":"X Ticks 1 xticks ( xs ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , y ); xticks ({ 0 , 5 , 10 }); xticklabels ({ \"x=0\" , \"x=5\" , \"x=10\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -5 , + 5 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , y ); xticks ({ -5 , -2.5 , -1 , 0 , 1 , 2.5 , 5 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 50 ); auto y = transform ( x , []( double x ) { return sin ( x / 2. ); }); plot ( x , y ); xticks ( iota ( 0 , 10 , 50 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 6 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ({ 0 , 6 * pi }); xticks ( iota ( 0 , pi , 6 * pi )); xticklabels ({ \"0\" , \"\u03c0\" , \"2\u03c0\" , \"3\u03c0\" , \"4\u03c0\" , \"5\u03c0\" , \"6\u03c0\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 0.5 , 3 ); auto y = rand ( 7 , 0 , 1 ); plot ( x , y ); auto ticks = iota ( 0 , 0.25 , 3 ); xticks ( ticks ); xlabel ( \"min\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); xticks ({ 0 , 4 , 6 , 10 }); xticks ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); auto ax2 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); xticks ({ 1 , 2 , 3 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xticks ({}); show (); return 0 ; }","title":"X Ticks"},{"location":"appearance/grid/x-ticks/#x-ticks","text":"1 xticks ( xs ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , y ); xticks ({ 0 , 5 , 10 }); xticklabels ({ \"x=0\" , \"x=5\" , \"x=10\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -5 , + 5 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , y ); xticks ({ -5 , -2.5 , -1 , 0 , 1 , 2.5 , 5 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 50 ); auto y = transform ( x , []( double x ) { return sin ( x / 2. ); }); plot ( x , y ); xticks ( iota ( 0 , 10 , 50 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 6 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ({ 0 , 6 * pi }); xticks ( iota ( 0 , pi , 6 * pi )); xticklabels ({ \"0\" , \"\u03c0\" , \"2\u03c0\" , \"3\u03c0\" , \"4\u03c0\" , \"5\u03c0\" , \"6\u03c0\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 0.5 , 3 ); auto y = rand ( 7 , 0 , 1 ); plot ( x , y ); auto ticks = iota ( 0 , 0.25 , 3 ); xticks ( ticks ); xlabel ( \"min\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); xticks ({ 0 , 4 , 6 , 10 }); xticks ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); auto ax2 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); xticks ({ 1 , 2 , 3 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xticks ({}); show (); return 0 ; }","title":"X Ticks"},{"location":"appearance/grid/y-tick-angle/","text":"Y Tick Angle 1 ytickangle ( ang ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 50 , 20 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem ( x , y ); ytickangle ( 90 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , rand ( 6 , 6 , 0 , 1 )); auto ax2 = nexttile (); plot ( ax2 , rand ( 6 , 6 , 0 , 1 )); ytickangle ( ax2 , 45 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 50 , 20 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem ( x , y ); std :: cout << \"ytickangle(): \" << ytickangle () << std :: endl ; show (); return 0 ; }","title":"Y Tick Angle"},{"location":"appearance/grid/y-tick-angle/#y-tick-angle","text":"1 ytickangle ( ang ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 50 , 20 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem ( x , y ); ytickangle ( 90 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , rand ( 6 , 6 , 0 , 1 )); auto ax2 = nexttile (); plot ( ax2 , rand ( 6 , 6 , 0 , 1 )); ytickangle ( ax2 , 45 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 50 , 20 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem ( x , y ); std :: cout << \"ytickangle(): \" << ytickangle () << std :: endl ; show (); return 0 ; }","title":"Y Tick Angle"},{"location":"appearance/grid/y-tick-format/","text":"Y Tick Format 1 ytickformat ( fmtstr ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 20 , 100 ); vector_1d y = { 88 , 67 , 98 , 43 , 45 , 65 }; bar ( x , y ); ytickformat ( \"usd\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 20 , 100 ); vector_1d y = { 88 , 67 , 98 , 43 , 45 , 65 }; bar ( x , y ); ytickformat ( \"usd\" ); std :: cout << \"ytickformat(): \" << ytickformat () << std :: endl ; ytickformat ( \"$%.0f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 10 ); vector_1d y = { 17 , 25 , 27 , 28 , 33 , 32 , 33 , 34 , 33 , 35 }; plot ( x , y , \"-V\" ); ytickformat ( \"%g M\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = rand ( 30 , 0 , 1 ); auto y = rand ( 30 , 0 , 1 ); scatter ( x , y ); ytickformat ( \"%.2f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , rand ( 6 , 6 , 0 , 1 )); auto ax2 = nexttile (); plot ( ax2 , rand ( 6 , 6 , 0 , 1 )); ytickformat ( ax2 , \"usd\" ); show (); return 0 ; }","title":"Y Tick Format"},{"location":"appearance/grid/y-tick-format/#y-tick-format","text":"1 ytickformat ( fmtstr ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 20 , 100 ); vector_1d y = { 88 , 67 , 98 , 43 , 45 , 65 }; bar ( x , y ); ytickformat ( \"usd\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 20 , 100 ); vector_1d y = { 88 , 67 , 98 , 43 , 45 , 65 }; bar ( x , y ); ytickformat ( \"usd\" ); std :: cout << \"ytickformat(): \" << ytickformat () << std :: endl ; ytickformat ( \"$%.0f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 10 ); vector_1d y = { 17 , 25 , 27 , 28 , 33 , 32 , 33 , 34 , 33 , 35 }; plot ( x , y , \"-V\" ); ytickformat ( \"%g M\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = rand ( 30 , 0 , 1 ); auto y = rand ( 30 , 0 , 1 ); scatter ( x , y ); ytickformat ( \"%.2f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , rand ( 6 , 6 , 0 , 1 )); auto ax2 = nexttile (); plot ( ax2 , rand ( 6 , 6 , 0 , 1 )); ytickformat ( ax2 , \"usd\" ); show (); return 0 ; }","title":"Y Tick Format"},{"location":"appearance/grid/y-tick-labels/","text":"Y Tick Labels 1 yticklabels ( ystrs ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); auto ax2 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); ylim ( ax2 , { 0 , 1 }); yticks ( ax2 , { 0 , 0.25 , .5 , .75 , 1 }); yticklabels ( ax2 , { \"y=0\" , \"1/4\" , \"1/2\" , \"3/4\" , \"y=1\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); yticks ({ 1 , 4 , 6 , 10 }); yticklabels ({ \"A\" , \"B\" , \"C\" , \"D\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); yticks ({ 1 , 4 , 6 , 10 }); yticklabels ({ \"A\" , \"B\" , \"C\" , \"D\" }); yticks ( automatic ); yticklabels ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( rand ( 5 , 5 , 0 , 1 )); yticklabels ({}); show (); return 0 ; }","title":"Y Tick Labels"},{"location":"appearance/grid/y-tick-labels/#y-tick-labels","text":"1 yticklabels ( ystrs ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); auto ax2 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); ylim ( ax2 , { 0 , 1 }); yticks ( ax2 , { 0 , 0.25 , .5 , .75 , 1 }); yticklabels ( ax2 , { \"y=0\" , \"1/4\" , \"1/2\" , \"3/4\" , \"y=1\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); yticks ({ 1 , 4 , 6 , 10 }); yticklabels ({ \"A\" , \"B\" , \"C\" , \"D\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); yticks ({ 1 , 4 , 6 , 10 }); yticklabels ({ \"A\" , \"B\" , \"C\" , \"D\" }); yticks ( automatic ); yticklabels ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( rand ( 5 , 5 , 0 , 1 )); yticklabels ({}); show (); return 0 ; }","title":"Y Tick Labels"},{"location":"appearance/grid/y-ticks/","text":"Y Ticks 1 yticks ( ys ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , y ); yticks ({ 0 , 50 , 100 }); yticklabels ({ \"y=0\" , \"y=50\" , \"y=100\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -5 , + 5 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , y ); yticks ({ 0 , 2 , 4 , 6 , 8 , 10 , 15 , 25 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return pow ( x , 2. ); }); plot ( x , y ); yticks ( iota ( 0 , 25 , 100 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 6 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ({ 0 , 6 * pi }); yticks ( iota ( -1 , 1 , 1 )); yticklabels ({ \"min\" , \"zero\" , \"max\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 0.5 , 3 ); auto y = rand ( 7 , 0 , 1 ); plot ( x , y ); auto ticks = iota ( 0 , 0.25 , 1. ); yticks ( ticks ); xlabel ( \"min\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); yticks ({ 0 , 5 , 10 }); yticks ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); auto ax2 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); yticks ( iota ( 0 , .2 , 1 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); yticks ({}); show (); return 0 ; }","title":"Y Ticks"},{"location":"appearance/grid/y-ticks/#y-ticks","text":"1 yticks ( ys ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , y ); yticks ({ 0 , 50 , 100 }); yticklabels ({ \"y=0\" , \"y=50\" , \"y=100\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -5 , + 5 ); auto y = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , y ); yticks ({ 0 , 2 , 4 , 6 , 8 , 10 , 15 , 25 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return pow ( x , 2. ); }); plot ( x , y ); yticks ( iota ( 0 , 25 , 100 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 6 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlim ({ 0 , 6 * pi }); yticks ( iota ( -1 , 1 , 1 )); yticklabels ({ \"min\" , \"zero\" , \"max\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = iota ( 0 , 0.5 , 3 ); auto y = rand ( 7 , 0 , 1 ); plot ( x , y ); auto ticks = iota ( 0 , 0.25 , 1. ); yticks ( ticks ); xlabel ( \"min\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; stem ( iota ( 1 , 10 )); yticks ({ 0 , 5 , 10 }); yticks ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); auto ax2 = nexttile (); plot ( rand ( 3 , 3 , 0 , 1 )); yticks ( iota ( 0 , .2 , 1 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); yticks ({}); show (); return 0 ; }","title":"Y Ticks"},{"location":"appearance/grid/z-tick-format/","text":"Z Tick Format 1 ztickformat ( fmtstr ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto z = rand ( 5 , 5 , 0 , 10 ); stem3 ( z ); ztickformat ( \"usd\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto z = rand ( 5 , 5 , 0 , 10 ); stem3 ( z ); ztickformat ( \"usd\" ); std :: cout << \"ztickformat(): \" << ztickformat () << std :: endl ; ztickformat ( \"$%.0f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 10 , 10 * pi ); auto st = transform ( t , []( double t ) { return sin ( t ); }); auto ct = transform ( t , []( double t ) { return cos ( t ); }); plot3 ( st , ct , t ); grid ( on ); ztickformat ( \"%g cm\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = rand ( 50 , 0 , 10 ); auto y = rand ( 50 , 0 , 10 ); auto z = rand ( 50 , 0 , 10 ); scatter3 ( x , y , z ); ztickformat ( \"%.2f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 1 , 2 ); auto ax1 = nexttile (); stem3 ( ax1 , rand ( 5 , 5 , 0 , 4 )); ztickformat ( ax1 , \"usd\" ); auto ax2 = nexttile (); stem3 ( ax2 , rand ( 5 , 5 , 0 , 4 )); show (); return 0 ; }","title":"Z Tick Format"},{"location":"appearance/grid/z-tick-format/#z-tick-format","text":"1 ztickformat ( fmtstr ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto z = rand ( 5 , 5 , 0 , 10 ); stem3 ( z ); ztickformat ( \"usd\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto z = rand ( 5 , 5 , 0 , 10 ); stem3 ( z ); ztickformat ( \"usd\" ); std :: cout << \"ztickformat(): \" << ztickformat () << std :: endl ; ztickformat ( \"$%.0f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 10 , 10 * pi ); auto st = transform ( t , []( double t ) { return sin ( t ); }); auto ct = transform ( t , []( double t ) { return cos ( t ); }); plot3 ( st , ct , t ); grid ( on ); ztickformat ( \"%g cm\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = rand ( 50 , 0 , 10 ); auto y = rand ( 50 , 0 , 10 ); auto z = rand ( 50 , 0 , 10 ); scatter3 ( x , y , z ); ztickformat ( \"%.2f\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 1 , 2 ); auto ax1 = nexttile (); stem3 ( ax1 , rand ( 5 , 5 , 0 , 4 )); ztickformat ( ax1 , \"usd\" ); auto ax2 = nexttile (); stem3 ( ax2 , rand ( 5 , 5 , 0 , 4 )); show (); return 0 ; }","title":"Z Tick Format"},{"location":"appearance/grid/z-ticks/","text":"Z Ticks 1 zticks ( zs ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); zlim ({ -8 , 8 }); zticks ({ -8 , 0 , + 8 }); zticklabels ({ \"z=-8\" , \"z=0\" , \"z=8\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); zlim ({ -10 , 10 }); zticks ({ -10 , -2.5 , 0 , 2.5 , 10 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); zlim ({ -10 , 10 }); zticks ( iota ( -10 , 2 , 10 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 50 , 10 * pi ); auto st = transform ( t , []( double t ) { return sin ( t ); }); auto ct = transform ( t , []( double t ) { return cos ( t ); }); plot3 ( st , ct , t ); zlim ({ 0 , 40 }); zticks ( iota ( 0 , 8 , 40 )); zticks ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); stem3 ( ax1 , rand ( 5 , 5 , 0 , 4 )); zticks ( ax1 , { 0 , 1.5 , 3.25 }); auto ax2 = nexttile (); stem3 ( ax2 , rand ( 5 , 5 , 0 , 4 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); mesh ( x , y , z ); zticks ({}); box ( off ); show (); return 0 ; }","title":"Z Ticks"},{"location":"appearance/grid/z-ticks/#z-ticks","text":"1 zticks ( zs ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); zlim ({ -8 , 8 }); zticks ({ -8 , 0 , + 8 }); zticklabels ({ \"z=-8\" , \"z=0\" , \"z=8\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); zlim ({ -10 , 10 }); zticks ({ -10 , -2.5 , 0 , 2.5 , 10 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); zlim ({ -10 , 10 }); zticks ( iota ( -10 , 2 , 10 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 50 , 10 * pi ); auto st = transform ( t , []( double t ) { return sin ( t ); }); auto ct = transform ( t , []( double t ) { return cos ( t ); }); plot3 ( st , ct , t ); zlim ({ 0 , 40 }); zticks ( iota ( 0 , 8 , 40 )); zticks ( automatic ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); stem3 ( ax1 , rand ( 5 , 5 , 0 , 4 )); zticks ( ax1 , { 0 , 1.5 , 3.25 }); auto ax2 = nexttile (); stem3 ( ax2 , rand ( 5 , 5 , 0 , 4 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); mesh ( x , y , z ); zticks ({}); box ( off ); show (); return 0 ; }","title":"Z Ticks"},{"location":"appearance/labels/legend/","text":"Legend 1 legend ({ str1 , str2 , str3 }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , pi ); std :: vector < double > y1 = transform ( x , []( auto x ) { return cos ( x ); }); plot ( x , y1 ); hold ( on ); std :: vector < double > y2 = transform ( x , []( auto x ) { return cos ( 2 * x ); }); plot ( x , y2 ); legend ( \"cos(x)\" , \"cos(2x)\" ); std :: vector < double > y3 = transform ( x , []( auto x ) { return cos ( 3 * x ); }); auto p = plot ( x , y3 ); p -> display_name ( \"cos(3x)\" ); hold ( off ); show (); legend ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto y1 = rand ( 3 , 3 , 0 , 1 ); auto ax1 = nexttile (); plot ( y1 ); auto y2 = rand ( 3 , 3 , 0 , 1 ); auto ax2 = nexttile (); plot ( y2 ); legend ( ax1 , \"Line 1\" , \"Line 2\" , \"Line 3\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); auto p1 = plot ( x , y1 ); p1 -> display_name ( \"cos(x)\" ); hold ( on ); auto p2 = plot ( x , y2 ); p2 -> display_name ( \"cos(2x)\" ); hold ( off ); legend (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); auto y3 = transform ( x , []( double x ) { return cos ( 3 * x ); }); auto y4 = transform ( x , []( double x ) { return cos ( 4 * x ); }); plot ( x , y1 ); hold ( on ); plot ( x , y2 ); plot ( x , y3 ); plot ( x , y4 ); hold ( off ); auto l = legend ( \"cos(x)\" , \"cos(2x)\" , \"cos(3x)\" , \"cos(4x)\" ); l -> location ( legend :: general_alignment :: topleft ); l -> num_rows ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); auto y3 = transform ( x , []( double x ) { return cos ( 3 * x ); }); auto p1 = plot ( x , y1 ); hold ( on ); plot ( x , y2 ); auto p3 = plot ( x , y3 ); hold ( off ); legend ({ p1 , p3 }, { \"First\" , \"Third\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); plot ( x , y1 ); hold ( on ); plot ( x , y2 ); hold ( off ); auto lgd = legend ( \"cos(x)\" , \"cos(2x)\" ); title ( lgd , \"My legend title\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); plot ( x , y1 ); hold ( on ); plot ( x , y2 ); hold ( off ); auto lgd = legend ( \"cos(x)\" , \"cos(2x)\" ); lgd -> location ( legend :: general_alignment :: bottomleft ); lgd -> box ( false ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; auto rdm = rand ( 4 , 4 , 0 , 1 ); plot ( rdm ); auto lgd = legend ( \"Line 1\" , \"Line 2\" , \"Line 3\" , \"Line 4\" ); lgd -> font_size ( 12 ); lgd -> text_color ( \"blue\" ); lgd -> num_columns ( 2 ); show (); return 0 ; }","title":"Legend"},{"location":"appearance/labels/legend/#legend","text":"1 legend ({ str1 , str2 , str3 }); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , pi ); std :: vector < double > y1 = transform ( x , []( auto x ) { return cos ( x ); }); plot ( x , y1 ); hold ( on ); std :: vector < double > y2 = transform ( x , []( auto x ) { return cos ( 2 * x ); }); plot ( x , y2 ); legend ( \"cos(x)\" , \"cos(2x)\" ); std :: vector < double > y3 = transform ( x , []( auto x ) { return cos ( 3 * x ); }); auto p = plot ( x , y3 ); p -> display_name ( \"cos(3x)\" ); hold ( off ); show (); legend ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto y1 = rand ( 3 , 3 , 0 , 1 ); auto ax1 = nexttile (); plot ( y1 ); auto y2 = rand ( 3 , 3 , 0 , 1 ); auto ax2 = nexttile (); plot ( y2 ); legend ( ax1 , \"Line 1\" , \"Line 2\" , \"Line 3\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); auto p1 = plot ( x , y1 ); p1 -> display_name ( \"cos(x)\" ); hold ( on ); auto p2 = plot ( x , y2 ); p2 -> display_name ( \"cos(2x)\" ); hold ( off ); legend (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); auto y3 = transform ( x , []( double x ) { return cos ( 3 * x ); }); auto y4 = transform ( x , []( double x ) { return cos ( 4 * x ); }); plot ( x , y1 ); hold ( on ); plot ( x , y2 ); plot ( x , y3 ); plot ( x , y4 ); hold ( off ); auto l = legend ( \"cos(x)\" , \"cos(2x)\" , \"cos(3x)\" , \"cos(4x)\" ); l -> location ( legend :: general_alignment :: topleft ); l -> num_rows ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); auto y3 = transform ( x , []( double x ) { return cos ( 3 * x ); }); auto p1 = plot ( x , y1 ); hold ( on ); plot ( x , y2 ); auto p3 = plot ( x , y3 ); hold ( off ); legend ({ p1 , p3 }, { \"First\" , \"Third\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); plot ( x , y1 ); hold ( on ); plot ( x , y2 ); hold ( off ); auto lgd = legend ( \"cos(x)\" , \"cos(2x)\" ); title ( lgd , \"My legend title\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , pi ); auto y1 = transform ( x , []( double x ) { return cos ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( 2 * x ); }); plot ( x , y1 ); hold ( on ); plot ( x , y2 ); hold ( off ); auto lgd = legend ( \"cos(x)\" , \"cos(2x)\" ); lgd -> location ( legend :: general_alignment :: bottomleft ); lgd -> box ( false ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; auto rdm = rand ( 4 , 4 , 0 , 1 ); plot ( rdm ); auto lgd = legend ( \"Line 1\" , \"Line 2\" , \"Line 3\" , \"Line 4\" ); lgd -> font_size ( 12 ); lgd -> text_color ( \"blue\" ); lgd -> num_columns ( 2 ); show (); return 0 ; }","title":"Legend"},{"location":"appearance/labels/subplot-title/","text":"Subplot Title 1 sgtitle ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; subplot ( 2 , 2 , 0 ); title ( \"First Subplot\" ); subplot ( 2 , 2 , 1 ); title ( \"Second Subplot\" ); subplot ( 2 , 2 , 2 ); title ( \"Third Subplot\" ); subplot ( 2 , 2 , 3 ); title ( \"Fourth Subplot\" ); sgtitle ( \"Subplot Grid Title\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; subplot ( 2 , 1 , 0 ); title ( \"First Subplot\" ); subplot ( 2 , 1 , 1 ); title ( \"Second Subplot\" ); sgtitle ( \"Subplot Grid Title\" , \"red\" ); gcf () -> title_font_size_multiplier ( 2.0 ); show (); return 0 ; }","title":"Subplot Title"},{"location":"appearance/labels/subplot-title/#subplot-title","text":"1 sgtitle ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; subplot ( 2 , 2 , 0 ); title ( \"First Subplot\" ); subplot ( 2 , 2 , 1 ); title ( \"Second Subplot\" ); subplot ( 2 , 2 , 2 ); title ( \"Third Subplot\" ); subplot ( 2 , 2 , 3 ); title ( \"Fourth Subplot\" ); sgtitle ( \"Subplot Grid Title\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; subplot ( 2 , 1 , 0 ); title ( \"First Subplot\" ); subplot ( 2 , 1 , 1 ); title ( \"Second Subplot\" ); sgtitle ( \"Subplot Grid Title\" , \"red\" ); gcf () -> title_font_size_multiplier ( 2.0 ); show (); return 0 ; }","title":"Subplot Title"},{"location":"appearance/labels/title/","text":"Title 1 title ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"My title\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); double f = 70. ; double c = ( f - 32 ) / 1.8 ; title ( \"Temperature is \" + num2str ( c ) + \" C\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"Case number # 3\" , \"m\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , 0.01 , 0.2 ); auto y = transform ( t , []( double x ) { return exp ( -25 * x ); }); plot ( t , y ); title ( \"y = {/:Italic e^{\u03bbt}}\" , \"b\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"\u03b1^2 and X_1\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"First line \\\\ nSecond line\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"X_1\" ); gca () -> title_enhanced ( false ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x1 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); auto x2 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 3 ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x1 ); auto ax2 = nexttile (); plot ( ax2 , x2 ); title ( ax1 , \"Top Plot\" ); title ( ax2 , \"Bottom Plot\" ); show (); return 0 ; }","title":"Title"},{"location":"appearance/labels/title/#title","text":"1 title ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"My title\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); double f = 70. ; double c = ( f - 32 ) / 1.8 ; title ( \"Temperature is \" + num2str ( c ) + \" C\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"Case number # 3\" , \"m\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , 0.01 , 0.2 ); auto y = transform ( t , []( double x ) { return exp ( -25 * x ); }); plot ( t , y ); title ( \"y = {/:Italic e^{\u03bbt}}\" , \"b\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"\u03b1^2 and X_1\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"First line \\\\ nSecond line\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); title ( \"X_1\" ); gca () -> title_enhanced ( false ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x1 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); auto x2 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 3 ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x1 ); auto ax2 = nexttile (); plot ( ax2 , x2 ); title ( ax1 , \"Top Plot\" ); title ( ax2 , \"Bottom Plot\" ); show (); return 0 ; }","title":"Title"},{"location":"appearance/labels/x-label/","text":"X Label 1 xlabel ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); xlabel ( \"Population\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); xlabel ( \"Population \\\\ n(in thousands)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -2 * pi , + 2 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlabel ( \"-2\u03c0 \u2264 x \u2264 2\u03c0\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); int year = 2014 ; xlabel ( \"Population for Year \" + num2str ( year )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = linspace ( 0 , 1 ); auto y = transform ( t , []( double t ) { return exp ( t ); }); plot ( t , y ); xlabel ( \"t_{seconds}\" ); ylabel ( \"e^t\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); xlabel ( \"Population\" ); auto ax = gca (); ax -> x_axis (). label_font_size ( 12 ); ax -> x_axis (). label_weight ( \"bold\" ); ax -> x_axis (). label_color ({ 0 , 1 , 0 , 0 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x1 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); auto x2 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 3 ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( x1 ); xlabel ( ax1 , \"Population\" ); auto ax2 = nexttile (); plot ( x2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); xlabel ( \"Population\" ); gca () -> x_axis (). label_color ( \"red\" ); show (); return 0 ; }","title":"X Label"},{"location":"appearance/labels/x-label/#x-label","text":"1 xlabel ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); xlabel ( \"Population\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); xlabel ( \"Population \\\\ n(in thousands)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -2 * pi , + 2 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); xlabel ( \"-2\u03c0 \u2264 x \u2264 2\u03c0\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); int year = 2014 ; xlabel ( \"Population for Year \" + num2str ( year )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = linspace ( 0 , 1 ); auto y = transform ( t , []( double t ) { return exp ( t ); }); plot ( t , y ); xlabel ( \"t_{seconds}\" ); ylabel ( \"e^t\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); xlabel ( \"Population\" ); auto ax = gca (); ax -> x_axis (). label_font_size ( 12 ); ax -> x_axis (). label_weight ( \"bold\" ); ax -> x_axis (). label_color ({ 0 , 1 , 0 , 0 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x1 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); auto x2 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 3 ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( x1 ); xlabel ( ax1 , \"Population\" ); auto ax2 = nexttile (); plot ( x2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); xlabel ( \"Population\" ); gca () -> x_axis (). label_color ( \"red\" ); show (); return 0 ; }","title":"X Label"},{"location":"appearance/labels/y-label/","text":"Y Label 1 ylabel ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); ylabel ( \"Population\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); ylabel ( \"2010 Population \\\\ nin Years\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -2 * pi , + 2 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); ylabel ( \"-2\u03c0 \u2264 x \u2264 2\u03c0\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); int year = 2014 ; ylabel ( \"Population for Year \" + num2str ( year )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = linspace ( 0 , 1 ); auto y = transform ( t , []( double t ) { return exp ( t ); }); plot ( t , y ); ylabel ( \"t_{seconds}\" ); ylabel ( \"e^t\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); ylabel ( \"Population\" ); auto ax = gca (); ax -> y_axis (). label_font_size ( 12 ); ax -> y_axis (). label_weight ( \"bold\" ); ax -> y_axis (). label_color ({ 0 , 1 , 0 , 0 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x1 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); auto x2 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 3 ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( x1 ); ylabel ( ax1 , \"Population\" ); auto ax2 = nexttile (); plot ( x2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); ylabel ( \"Population\" ); gca () -> y_axis (). label_color ( \"red\" ); show (); return 0 ; }","title":"Y Label"},{"location":"appearance/labels/y-label/#y-label","text":"1 ylabel ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); ylabel ( \"Population\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); ylabel ( \"2010 Population \\\\ nin Years\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( -2 * pi , + 2 * pi ); auto y = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y ); ylabel ( \"-2\u03c0 \u2264 x \u2264 2\u03c0\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); int year = 2014 ; ylabel ( \"Population for Year \" + num2str ( year )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = linspace ( 0 , 1 ); auto y = transform ( t , []( double t ) { return exp ( t ); }); plot ( t , y ); ylabel ( \"t_{seconds}\" ); ylabel ( \"e^t\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); ylabel ( \"Population\" ); auto ax = gca (); ax -> y_axis (). label_font_size ( 12 ); ax -> y_axis (). label_weight ( \"bold\" ); ax -> y_axis (). label_color ({ 0 , 1 , 0 , 0 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x1 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); auto x2 = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 3 ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( x1 ); ylabel ( ax1 , \"Population\" ); auto ax2 = nexttile (); plot ( x2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = transform ( iota ( 1 , 10 ), []( double x ) { return pow ( x , 2 ); }); plot ( x ); ylabel ( \"Population\" ); gca () -> y_axis (). label_color ( \"red\" ); show (); return 0 ; }","title":"Y Label"},{"location":"appearance/labels/z-label/","text":"Z Label 1 zlabel ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); zlabel ( \"Height\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); auto [ X , Y , Z ] = peaks ( 30 ); surf ( ax1 , X , Y , Z ); auto ax2 = nexttile (); auto [ X2 , Y2 , Z2 ] = peaks ( 45 ); surf ( ax2 , X2 , Y2 , Z2 ); zlabel ( ax2 , \"Height\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); zlabel ( \"Population Change\" ); gca () -> z_axis (). label_color ( \"red\" ); show (); return 0 ; }","title":"Z Label"},{"location":"appearance/labels/z-label/#z-label","text":"1 zlabel ( str ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); zlabel ( \"Height\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); auto [ X , Y , Z ] = peaks ( 30 ); surf ( ax1 , X , Y , Z ); auto ax2 = nexttile (); auto [ X2 , Y2 , Z2 ] = peaks ( 45 ); surf ( ax2 , X2 , Y2 , Z2 ); zlabel ( ax2 , \"Height\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); surf ( X , Y , Z ); zlabel ( \"Population Change\" ); gca () -> z_axis (). label_color ( \"red\" ); show (); return 0 ; }","title":"Z Label"},{"location":"appearance/multiplot/color-order/","text":"Color Order 1 colororder ( colors ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_2d newcolors = {{ 0.83 , 0.14 , 0.14 }, { 1.00 , 0.54 , 0.00 }, { 0.47 , 0.25 , 0.80 }, { 0.25 , 0.80 , 0.54 }}; colororder ( newcolors ); auto x = linspace ( 0 , 10 ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); auto y2 = transform ( x , []( double x ) { return sin ( x - 0.5 ); }); auto y3 = transform ( x , []( double x ) { return sin ( x - 1 ); }); auto y4 = transform ( x , []( double x ) { return sin ( x - 1.5 ); }); plot ( x , y1 ) -> line_width ( 2 ); hold ( on ); plot ( x , y2 ) -> line_width ( 2 ); plot ( x , y3 ) -> line_width ( 2 ); plot ( x , y4 ) -> line_width ( 2 ); hold ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: string > newcolors = { \"#FF0000\" , \"#FF8800\" , \"#FFFF00\" , \"#00BB00\" , \"#0000FF\" , \"#5500FF\" , \"#AA00FF\" }; colororder ( newcolors ); hold ( on ); for ( size_t r = 1 ; r <= 7 ; ++ r ) { auto x = linspace ( 0. , static_cast < double > ( r ), 500 ); auto y = transform ( x , [ & ]( double x ) { return sqrt ( pow ( r , 2 ) - pow ( x , 2 )); }); plot ( x , y ) -> line_width ( 15 ); } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> newcolors = { { 0 , 0.5 , 1 }, { 0.5 , 0 , 1 }, { 0.7 , 0.7 , 0.7 }}; colororder ( newcolors ); bar ( vector_2d {{ 10 , 20 , 30 }, { 25 , 35 , 45 }, { 30 , 40 , 52 }}); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> newcolors = {{ 0.4 , 0.3 , 0.9 }, { 0.5 , 0.65 , 0.15 }}; colororder ( newcolors ); plot ( vector_2d {{ 1 , 3 }, { 2 , 4 }}); hold ( on ); auto p2 = plot ( vector_2d {{ 4 , 2 }, { 3 , 1 }}); p2 [ 0 ] -> use_y2 ( true ); p2 [ 1 ] -> use_y2 ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> leftcolors = { { 0 , 0 , 1 }, { 0 , 0.5 , 1 }, { 0 , 0.8 , 1 }}; colororder ( leftcolors ); plot ( vector_2d {{ 1 , 4 }, { 2 , 5 }, { 3 , 6 }}); auto ax = gca (); ax -> y_axis (). color ( ax -> colororder ()[ 0 ]); hold ( on ); auto p2 = plot ( vector_2d {{ 4 , 2 }, { 3 , 1 }}, \"k-\" ); p2 [ 0 ] -> use_y2 ( true ); p2 [ 1 ] -> use_y2 ( true ). line_style ( \"--\" ); ax -> y_axis (). color ( \"k\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: string > newcolors = { \"red\" , \"magenta\" , \"blue\" }; colororder ( newcolors ); scatter ( iota ( 1 , 10 ), rand ( 10 , 0 , 1 )) -> marker_face ( true ); hold ( on ); scatter ( iota ( 1 , 10 ), rand ( 10 , 0 , 1 )) -> line_style ( \"*k\" ); scatter ( iota ( 1 , 10 ), rand ( 10 , 0 , 1 )) -> marker_face ( true ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout (); nexttile (); auto p1 = plot ( vector_2d {{ 1 , 4 }, { 2 , 5 }, { 3 , 6 }}); p1 [ 0 ] -> line_width ( 2 ); p1 [ 1 ] -> line_width ( 2 ); p1 [ 2 ] -> line_width ( 2 ); auto ax = nexttile (); auto p2 = plot ( ax , vector_2d {{ 4 , 1 }, { 5 , 2 }, { 6 , 3 }}); p2 [ 0 ] -> line_width ( 2 ); p2 [ 1 ] -> line_width ( 2 ); p2 [ 2 ] -> line_width ( 2 ); auto c = ax -> colororder (); c [ 0 ] = { 0. , 0.5 , 0. , 1. }; p2 [ 0 ] -> color ( c [ 0 ]); show (); return 0 ; }","title":"Color Order"},{"location":"appearance/multiplot/color-order/#color-order","text":"1 colororder ( colors ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_2d newcolors = {{ 0.83 , 0.14 , 0.14 }, { 1.00 , 0.54 , 0.00 }, { 0.47 , 0.25 , 0.80 }, { 0.25 , 0.80 , 0.54 }}; colororder ( newcolors ); auto x = linspace ( 0 , 10 ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); auto y2 = transform ( x , []( double x ) { return sin ( x - 0.5 ); }); auto y3 = transform ( x , []( double x ) { return sin ( x - 1 ); }); auto y4 = transform ( x , []( double x ) { return sin ( x - 1.5 ); }); plot ( x , y1 ) -> line_width ( 2 ); hold ( on ); plot ( x , y2 ) -> line_width ( 2 ); plot ( x , y3 ) -> line_width ( 2 ); plot ( x , y4 ) -> line_width ( 2 ); hold ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: string > newcolors = { \"#FF0000\" , \"#FF8800\" , \"#FFFF00\" , \"#00BB00\" , \"#0000FF\" , \"#5500FF\" , \"#AA00FF\" }; colororder ( newcolors ); hold ( on ); for ( size_t r = 1 ; r <= 7 ; ++ r ) { auto x = linspace ( 0. , static_cast < double > ( r ), 500 ); auto y = transform ( x , [ & ]( double x ) { return sqrt ( pow ( r , 2 ) - pow ( x , 2 )); }); plot ( x , y ) -> line_width ( 15 ); } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> newcolors = { { 0 , 0.5 , 1 }, { 0.5 , 0 , 1 }, { 0.7 , 0.7 , 0.7 }}; colororder ( newcolors ); bar ( vector_2d {{ 10 , 20 , 30 }, { 25 , 35 , 45 }, { 30 , 40 , 52 }}); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> newcolors = {{ 0.4 , 0.3 , 0.9 }, { 0.5 , 0.65 , 0.15 }}; colororder ( newcolors ); plot ( vector_2d {{ 1 , 3 }, { 2 , 4 }}); hold ( on ); auto p2 = plot ( vector_2d {{ 4 , 2 }, { 3 , 1 }}); p2 [ 0 ] -> use_y2 ( true ); p2 [ 1 ] -> use_y2 ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> leftcolors = { { 0 , 0 , 1 }, { 0 , 0.5 , 1 }, { 0 , 0.8 , 1 }}; colororder ( leftcolors ); plot ( vector_2d {{ 1 , 4 }, { 2 , 5 }, { 3 , 6 }}); auto ax = gca (); ax -> y_axis (). color ( ax -> colororder ()[ 0 ]); hold ( on ); auto p2 = plot ( vector_2d {{ 4 , 2 }, { 3 , 1 }}, \"k-\" ); p2 [ 0 ] -> use_y2 ( true ); p2 [ 1 ] -> use_y2 ( true ). line_style ( \"--\" ); ax -> y_axis (). color ( \"k\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: string > newcolors = { \"red\" , \"magenta\" , \"blue\" }; colororder ( newcolors ); scatter ( iota ( 1 , 10 ), rand ( 10 , 0 , 1 )) -> marker_face ( true ); hold ( on ); scatter ( iota ( 1 , 10 ), rand ( 10 , 0 , 1 )) -> line_style ( \"*k\" ); scatter ( iota ( 1 , 10 ), rand ( 10 , 0 , 1 )) -> marker_face ( true ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout (); nexttile (); auto p1 = plot ( vector_2d {{ 1 , 4 }, { 2 , 5 }, { 3 , 6 }}); p1 [ 0 ] -> line_width ( 2 ); p1 [ 1 ] -> line_width ( 2 ); p1 [ 2 ] -> line_width ( 2 ); auto ax = nexttile (); auto p2 = plot ( ax , vector_2d {{ 4 , 1 }, { 5 , 2 }, { 6 , 3 }}); p2 [ 0 ] -> line_width ( 2 ); p2 [ 1 ] -> line_width ( 2 ); p2 [ 2 ] -> line_width ( 2 ); auto c = ax -> colororder (); c [ 0 ] = { 0. , 0.5 , 0. , 1. }; p2 [ 0 ] -> color ( c [ 0 ]); show (); return 0 ; }","title":"Color Order"},{"location":"appearance/multiplot/hold/","text":"Hold 1 hold ( on ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( - pi , pi ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y1 ); hold ( on ); auto y2 = transform ( x , []( double x ) { return cos ( x ); }); plot ( x , y2 ); hold ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( - pi , pi ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y1 ); hold ( on ); auto y2 = transform ( x , []( double x ) { return cos ( x ); }); plot ( x , y2 ); hold ( off ); auto y3 = transform ( x , []( double x ) { return sin ( 2 * x ); }); plot ( x , y3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x , y1 ); auto ax2 = nexttile (); plot ( ax2 , x , y2 ); hold ( ax1 , on ); auto y3 = transform ( x , []( double x ) { return sin ( 2 * x ); }); plot ( ax1 , x , y3 ); hold ( ax1 , off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 1 , 2 ); auto ax1 = nexttile (); auto ax2 = nexttile (); plot ( ax1 , { 0 , 1 , 0 , 1 }); auto s1 = scatter ( ax2 , rand ( 10 , 0 , 1 ), rand ( 10 , 0 , 1 )); s1 -> marker_face ( true ); hold ({ ax1 , ax2 }, on ); plot ( ax1 , { .5 , .2 , .5 , .2 }); auto s2 = scatter ( ax2 , rand ( 10 , 0 , 1 ), rand ( 10 , 0 , 1 )); s2 -> marker_face ( true ); show (); return 0 ; }","title":"Hold"},{"location":"appearance/multiplot/hold/#hold","text":"1 hold ( on ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( - pi , pi ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y1 ); hold ( on ); auto y2 = transform ( x , []( double x ) { return cos ( x ); }); plot ( x , y2 ); hold ( off ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( - pi , pi ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); plot ( x , y1 ); hold ( on ); auto y2 = transform ( x , []( double x ) { return cos ( x ); }); plot ( x , y2 ); hold ( off ); auto y3 = transform ( x , []( double x ) { return sin ( 2 * x ); }); plot ( x , y3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); auto y2 = transform ( x , []( double x ) { return cos ( x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x , y1 ); auto ax2 = nexttile (); plot ( ax2 , x , y2 ); hold ( ax1 , on ); auto y3 = transform ( x , []( double x ) { return sin ( 2 * x ); }); plot ( ax1 , x , y3 ); hold ( ax1 , off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 1 , 2 ); auto ax1 = nexttile (); auto ax2 = nexttile (); plot ( ax1 , { 0 , 1 , 0 , 1 }); auto s1 = scatter ( ax2 , rand ( 10 , 0 , 1 ), rand ( 10 , 0 , 1 )); s1 -> marker_face ( true ); hold ({ ax1 , ax2 }, on ); plot ( ax1 , { .5 , .2 , .5 , .2 }); auto s2 = scatter ( ax2 , rand ( 10 , 0 , 1 ), rand ( 10 , 0 , 1 )); s2 -> marker_face ( true ); show (); return 0 ; }","title":"Hold"},{"location":"appearance/multiplot/subplots/","text":"Subplots 1 subplot ( rows , cols , id ); Unlike other libraries, subplots uses 0-based indices. Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; subplot ( 2 , 1 , 0 ); fplot ( \"sin(x)\" ); subplot ( 2 , 1 , 1 ); fplot ( \"sin(5*x)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; subplot ( 2 , 2 , 0 ); fplot ( \"sin(x)\" ); title ( \"Subplot 1: sin(x)\" ); subplot ( 2 , 2 , 1 ); fplot ( \"sin(2*x)\" ); title ( \"Subplot 2: sin(2x)\" ); subplot ( 2 , 2 , 2 ); fplot ( \"sin(4*x)\" ); title ( \"Subplot 3: sin(4x)\" ); subplot ( 2 , 2 , 3 ); fplot ( \"sin(8*x)\" ); title ( \"Subplot 4: sin(8x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto ax1 = subplot ( 2 , 2 , 0 ); fplot ( \"cos(x)\" ); title ( \"Subplot 1: Cosine\" ); auto ax2 = subplot ( 2 , 2 , 1 ); fplot ( \"1 - x**2/2 + x**4/24\" ); title ( \"Subplot 2: Polynomial\" ); auto ax3 = subplot ( 2 , 2 , { 2 , 3 }); fplot ( \"cos(x)\" , \"b\" ); hold ( on ); fplot ( \"1 - x**2/2 + x**4/24\" , \"g\" ); title ( \"Subplot 3 and 4: Both\" ); axis ({ ax1 , ax2 , ax3 }, { -4 , 4 , inf , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; for ( size_t i = 0 ; i < 4 ; ++ i ) { subplot ( 2 , 2 , i ); std :: string equation = \"cos(x**\" + num2str ( i + 1 ) + \") + \" + num2str ( i ); fplot ( equation ); title ( equation ); } subplot ( 2 , 2 , 1 , true ); fplot ( \"sin(x)\" ); title ( \"sin(x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; subplot ({ 0.1 , 0.3 , 0.3 , 0.3 }); fplot ( \"sin(x)\" ); title ( \"First Subplot\" ); subplot ({ 0.5 , 0.15 , 0.4 , 0.7 }); fplot ( \"cos(x)\" ); title ( \"Second Subplot\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto ax1 = subplot ( 2 , 1 , 0 ); fplot ( \"sin(x)\" ); title ( \"First Subplot\" ); auto ax2 = subplot ( 2 , 1 , 1 ); fplot ( \"cos(x)\" ); title ( \"Second Subplot\" ); ax1 -> font_size ( 15 ); ax2 -> line_width ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; std :: vector < axes_handle > ax ; for ( size_t i = 0 ; i < 4 ; ++ i ) { ax . emplace_back ( subplot ( 2 , 2 , i )); } subplot ( ax [ 1 ]); auto p = fplot ( \"sin(x)\" ); p -> line_spec (). color ({ 0.1 , 0.5 , 0.1 }); p -> line_spec (). line_width ( 2 ); title ( \"Second subplot\" ); axis ({ 0 , 50 , -1 , 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; fplot ( \"sin(x)\" ); title ( \"Sine Plot\" ); auto ax = gca (); subplot ( 2 , 1 , 1 , ax ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; figure (); fplot ( \"sin(x)\" ); title ( \"Line Plot 1\" ); auto ax1 = gca (); figure (); fplot ( \"2*sin(x)\" ); title ( \"Line Plot 2\" ); auto ax2 = gca (); auto fnew = figure (); auto ax1_copy = ax1 -> copy ( fnew ); subplot ( 2 , 1 , 0 , ax1_copy ); auto ax2_copy = ax2 -> copy ( fnew ); subplot ( 2 , 1 , 1 , ax2_copy ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; for ( size_t k = 0 ; k < 4 ; ++ k ) { auto data = rand ( 10 , 0 , 1 ); subplot ( 2 , 2 , k ); stem ( data ); } subplot ( 2 , 2 , 1 , true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; subplot ({ 0.1 , 0.3 , 0.3 , 0.3 }); std :: vector < std :: vector < double >> y = { { 16 , 5 , 9 , 4 }, { 2 , 11 , 7 , 14 }, { 3 , 10 , 6 , 15 }, { 13 , 8 , 12 , 1 }}; plot ( y ); title ( \"First Subplot\" ); subplot ({ 0.5 , 0.15 , 0.4 , 0.7 }); bar ( y ); title ( \"Second Subplot\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; figure (); auto ax1 = subplot ( 2 , 1 , 0 ); auto theta = linspace ( 0 , 2 * pi , 50 ); auto rho = transform ( theta , []( double theta ) { return sin ( theta ) * cos ( theta ); }); polarplot ( ax1 , theta , rho ); auto ax2 = subplot ( 2 , 1 , 1 ); polarscatter ( ax2 , theta , rho ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ax1 = subplot ( 2 , 1 , 0 ); auto [ x , y , z ] = peaks (); z = transpose ( z ); plot ( ax1 , z ); xlim ( ax1 , { 0 , 20 }); auto ax2 = subplot ( 2 , 1 , 1 ); plot ( ax2 , z ); ax1 -> font_size ( 15 ); ax2 -> line_width ( 2 ); show (); return 0 ; }","title":"Subplots"},{"location":"appearance/multiplot/subplots/#subplots","text":"1 subplot ( rows , cols , id ); Unlike other libraries, subplots uses 0-based indices. Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; subplot ( 2 , 1 , 0 ); fplot ( \"sin(x)\" ); subplot ( 2 , 1 , 1 ); fplot ( \"sin(5*x)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; subplot ( 2 , 2 , 0 ); fplot ( \"sin(x)\" ); title ( \"Subplot 1: sin(x)\" ); subplot ( 2 , 2 , 1 ); fplot ( \"sin(2*x)\" ); title ( \"Subplot 2: sin(2x)\" ); subplot ( 2 , 2 , 2 ); fplot ( \"sin(4*x)\" ); title ( \"Subplot 3: sin(4x)\" ); subplot ( 2 , 2 , 3 ); fplot ( \"sin(8*x)\" ); title ( \"Subplot 4: sin(8x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto ax1 = subplot ( 2 , 2 , 0 ); fplot ( \"cos(x)\" ); title ( \"Subplot 1: Cosine\" ); auto ax2 = subplot ( 2 , 2 , 1 ); fplot ( \"1 - x**2/2 + x**4/24\" ); title ( \"Subplot 2: Polynomial\" ); auto ax3 = subplot ( 2 , 2 , { 2 , 3 }); fplot ( \"cos(x)\" , \"b\" ); hold ( on ); fplot ( \"1 - x**2/2 + x**4/24\" , \"g\" ); title ( \"Subplot 3 and 4: Both\" ); axis ({ ax1 , ax2 , ax3 }, { -4 , 4 , inf , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; for ( size_t i = 0 ; i < 4 ; ++ i ) { subplot ( 2 , 2 , i ); std :: string equation = \"cos(x**\" + num2str ( i + 1 ) + \") + \" + num2str ( i ); fplot ( equation ); title ( equation ); } subplot ( 2 , 2 , 1 , true ); fplot ( \"sin(x)\" ); title ( \"sin(x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; subplot ({ 0.1 , 0.3 , 0.3 , 0.3 }); fplot ( \"sin(x)\" ); title ( \"First Subplot\" ); subplot ({ 0.5 , 0.15 , 0.4 , 0.7 }); fplot ( \"cos(x)\" ); title ( \"Second Subplot\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto ax1 = subplot ( 2 , 1 , 0 ); fplot ( \"sin(x)\" ); title ( \"First Subplot\" ); auto ax2 = subplot ( 2 , 1 , 1 ); fplot ( \"cos(x)\" ); title ( \"Second Subplot\" ); ax1 -> font_size ( 15 ); ax2 -> line_width ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; std :: vector < axes_handle > ax ; for ( size_t i = 0 ; i < 4 ; ++ i ) { ax . emplace_back ( subplot ( 2 , 2 , i )); } subplot ( ax [ 1 ]); auto p = fplot ( \"sin(x)\" ); p -> line_spec (). color ({ 0.1 , 0.5 , 0.1 }); p -> line_spec (). line_width ( 2 ); title ( \"Second subplot\" ); axis ({ 0 , 50 , -1 , 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; fplot ( \"sin(x)\" ); title ( \"Sine Plot\" ); auto ax = gca (); subplot ( 2 , 1 , 1 , ax ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; figure (); fplot ( \"sin(x)\" ); title ( \"Line Plot 1\" ); auto ax1 = gca (); figure (); fplot ( \"2*sin(x)\" ); title ( \"Line Plot 2\" ); auto ax2 = gca (); auto fnew = figure (); auto ax1_copy = ax1 -> copy ( fnew ); subplot ( 2 , 1 , 0 , ax1_copy ); auto ax2_copy = ax2 -> copy ( fnew ); subplot ( 2 , 1 , 1 , ax2_copy ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; for ( size_t k = 0 ; k < 4 ; ++ k ) { auto data = rand ( 10 , 0 , 1 ); subplot ( 2 , 2 , k ); stem ( data ); } subplot ( 2 , 2 , 1 , true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; subplot ({ 0.1 , 0.3 , 0.3 , 0.3 }); std :: vector < std :: vector < double >> y = { { 16 , 5 , 9 , 4 }, { 2 , 11 , 7 , 14 }, { 3 , 10 , 6 , 15 }, { 13 , 8 , 12 , 1 }}; plot ( y ); title ( \"First Subplot\" ); subplot ({ 0.5 , 0.15 , 0.4 , 0.7 }); bar ( y ); title ( \"Second Subplot\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; figure (); auto ax1 = subplot ( 2 , 1 , 0 ); auto theta = linspace ( 0 , 2 * pi , 50 ); auto rho = transform ( theta , []( double theta ) { return sin ( theta ) * cos ( theta ); }); polarplot ( ax1 , theta , rho ); auto ax2 = subplot ( 2 , 1 , 1 ); polarscatter ( ax2 , theta , rho ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ax1 = subplot ( 2 , 1 , 0 ); auto [ x , y , z ] = peaks (); z = transpose ( z ); plot ( ax1 , z ); xlim ( ax1 , { 0 , 20 }); auto ax2 = subplot ( 2 , 1 , 1 ); plot ( ax2 , z ); ax1 -> font_size ( 15 ); ax2 -> line_width ( 2 ); show (); return 0 ; }","title":"Subplots"},{"location":"appearance/multiplot/tiled-layout/","text":"Tiled Layout 1 2 tiledlayout ( rows , cols ); nexttile (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); fplot ( ax1 , \"sin(x)\" ); title ( ax1 , \"Plot 1\" ); ax1 -> font_size ( 14 ); ax1 -> x_axis (). color ( \"red\" ); auto ax2 = nexttile (); fplot ( ax2 , \"cos(x)\" , \"ob\" ); title ( ax2 , \"Plot 2\" ); grid ( ax2 , on ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 2 ); auto [ x , y , z ] = peaks ( 20 ); nexttile (); surf ( x , y , z ); nexttile (); contour ( x , y , z ); nexttile (); imagesc ( z ); nexttile (); plot3 ( x , y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 30 ); auto y1 = transform ( x , []( double x ) { return sin ( x / 2 ); }); auto y2 = transform ( x , []( double x ) { return sin ( x / 3 ); }); auto y3 = transform ( x , []( double x ) { return sin ( x / 4 ); }); tiledlayout (); nexttile (); plot ( x , y1 ); nexttile (); plot ( x , y2 ); nexttile (); plot ( x , y3 ); nexttile (); plot ( x , y1 ); hold ( on ); plot ( x , y2 ); plot ( x , y3 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 30 ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); auto y2 = transform ( x , []( double x ) { return sin ( x / 2 ); }); auto y3 = transform ( x , []( double x ) { return sin ( x / 3 ); }); auto y4 = transform ( x , []( double x ) { return sin ( x / 4 ); }); tiledlayout (); nexttile (); plot ( x , y1 ); nexttile (); plot ( x , y2 ); nexttile (); plot ( x , y3 ); nexttile (); plot ( x , y4 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 2 ); nexttile (); plot ( rand ( 20 , 0 , 1 )); title ( \"Sample 1\" ); nexttile (); plot ( rand ( 20 , 0 , 1 )); title ( \"Sample 2\" ); nexttile (); plot ( rand ( 20 , 0 , 1 )); title ( \"Sample 3\" ); nexttile (); plot ( rand ( 20 , 0 , 1 )); title ( \"Sample 4\" ); sgtitle ( \"Size vs. Distance\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); nexttile (); stem ( iota ( 1 , 13 )); nexttile (); bar ( std :: vector < double > { 10 , 22 , 31 , 43 , 52 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 1 , 2 ); nexttile (); geoplot ( vector_1d { 47.62 , 61.20 }, vector_1d { -122.33 , -149.90 }, \"g-*\" ); geolimits ({ 46 , 62 }, { -160 , -110 }); nexttile (); auto theta = iota ( pi / 4 , pi / 4 , 2 * pi ); std :: vector < double > rho = { 19 , 6 , 12 , 18 , 16 , 11 , 15 , 15 }; polarscatter ( theta , rho ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 2 ); auto [ x , y , z ] = peaks ( 20 ); nexttile (); surf ( x , y , z ); nexttile (); contour ( x , y , z ); nexttile (); imagesc ( z ); nexttile (); plot3 ( x , y , z ); auto ax = nexttile ( 2 ); colormap ( ax , palette :: cool ()); show (); return 0 ; } Our tiling functions are convenience shortcuts for the subplot functions. If there is no room for the next tile, we automatically rearrange the axes and increase the number of subplot rows or columns to fit the next tile. Use subplots for more control over the subplots.","title":"Tiled Layout"},{"location":"appearance/multiplot/tiled-layout/#tiled-layout","text":"1 2 tiledlayout ( rows , cols ); nexttile (); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); fplot ( ax1 , \"sin(x)\" ); title ( ax1 , \"Plot 1\" ); ax1 -> font_size ( 14 ); ax1 -> x_axis (). color ( \"red\" ); auto ax2 = nexttile (); fplot ( ax2 , \"cos(x)\" , \"ob\" ); title ( ax2 , \"Plot 2\" ); grid ( ax2 , on ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; tiledlayout ( 2 , 2 ); auto [ x , y , z ] = peaks ( 20 ); nexttile (); surf ( x , y , z ); nexttile (); contour ( x , y , z ); nexttile (); imagesc ( z ); nexttile (); plot3 ( x , y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 30 ); auto y1 = transform ( x , []( double x ) { return sin ( x / 2 ); }); auto y2 = transform ( x , []( double x ) { return sin ( x / 3 ); }); auto y3 = transform ( x , []( double x ) { return sin ( x / 4 ); }); tiledlayout (); nexttile (); plot ( x , y1 ); nexttile (); plot ( x , y2 ); nexttile (); plot ( x , y3 ); nexttile (); plot ( x , y1 ); hold ( on ); plot ( x , y2 ); plot ( x , y3 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <iostream> #include <matplot/matplot.h> #include <set> #include <thread> #include <vector> int main () { using namespace matplot ; auto x = linspace ( 0 , 30 ); auto y1 = transform ( x , []( double x ) { return sin ( x ); }); auto y2 = transform ( x , []( double x ) { return sin ( x / 2 ); }); auto y3 = transform ( x , []( double x ) { return sin ( x / 3 ); }); auto y4 = transform ( x , []( double x ) { return sin ( x / 4 ); }); tiledlayout (); nexttile (); plot ( x , y1 ); nexttile (); plot ( x , y2 ); nexttile (); plot ( x , y3 ); nexttile (); plot ( x , y4 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 2 ); nexttile (); plot ( rand ( 20 , 0 , 1 )); title ( \"Sample 1\" ); nexttile (); plot ( rand ( 20 , 0 , 1 )); title ( \"Sample 2\" ); nexttile (); plot ( rand ( 20 , 0 , 1 )); title ( \"Sample 3\" ); nexttile (); plot ( rand ( 20 , 0 , 1 )); title ( \"Sample 4\" ); sgtitle ( \"Size vs. Distance\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); nexttile (); stem ( iota ( 1 , 13 )); nexttile (); bar ( std :: vector < double > { 10 , 22 , 31 , 43 , 52 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 1 , 2 ); nexttile (); geoplot ( vector_1d { 47.62 , 61.20 }, vector_1d { -122.33 , -149.90 }, \"g-*\" ); geolimits ({ 46 , 62 }, { -160 , -110 }); nexttile (); auto theta = iota ( pi / 4 , pi / 4 , 2 * pi ); std :: vector < double > rho = { 19 , 6 , 12 , 18 , 16 , 11 , 15 , 15 }; polarscatter ( theta , rho ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 2 ); auto [ x , y , z ] = peaks ( 20 ); nexttile (); surf ( x , y , z ); nexttile (); contour ( x , y , z ); nexttile (); imagesc ( z ); nexttile (); plot3 ( x , y , z ); auto ax = nexttile ( 2 ); colormap ( ax , palette :: cool ()); show (); return 0 ; } Our tiling functions are convenience shortcuts for the subplot functions. If there is no room for the next tile, we automatically rearrange the axes and increase the number of subplot rows or columns to fit the next tile. Use subplots for more control over the subplots.","title":"Tiled Layout"},{"location":"appearance/multiplot/yy-axis/","text":"YY-axis 1 plot ( x , y ) -> use_y2 ( true ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y1 = transform ( x , []( double x ) { return sin ( 3 * x ); }); plot ( x , y1 ); hold ( on ); auto z = transform ( x , []( double x ) { return sin ( 3 * x ) * exp ( 0.5 * x ); }); plot ( x , z ) -> use_y2 ( true ); y2lim ({ -150 , 150 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ind = linspace ( 0 , 51 ); auto drivers = transform ( ind , []( double ind ) { return pow ( ind , 2 ) + randn ( 0 , 50 ); }); scatter ( ind , drivers ); title ( \"Highway data\" ); xlabel ( \"States\" ); ylabel ( \"Licensed Drivers\" ); ylim ({ 0 , inf }); hold ( on ); auto pop = transform ( ind , []( double ind ) { return 10000 * ( pow ( ind , 2 ) + randn ( 0 , 100 )); }); scatter ( ind , pop ) -> use_y2 ( true ); y2label ( \"Vehicle Miles Traveled\" ); y2lim ({ 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d x = linspace ( 0 , 10 ); auto yl1 = transform ( x , []( double x ) { return sin ( x ); }); auto yl2 = transform ( x , []( double x ) { return sin ( x / 2 ); }); plot ( x , yl1 ) -> color ( gca () -> colororder ()[ 0 ]); hold ( on ); plot ( x , yl2 ) -> color ( gca () -> colororder ()[ 0 ]). line_style ( \"--\" ); auto yr1 = x ; auto yr2 = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , yr1 ) -> use_y2 ( true ). color ( gca () -> colororder ()[ 1 ]); plot ( x , yr2 ) -> use_y2 ( true ). color ( gca () -> colororder ()[ 1 ]). line_style ( \"--\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <matplot/matplot.h> int main () { using namespace matplot ; colororder ({ \"b\" , \"m\" }); vector_2d y = {{ 1 , 3 }, { 2 , 4 }}; auto p1 = plot ( y ); p1 [ 0 ] -> color ( \"b\" ); p1 [ 1 ] -> color ( \"b\" ). line_style ( \"--\" ); gca () -> y_axis (). color ( \"b\" ); hold ( on ); vector_2d z = {{ 4 , 2 }, { 3 , 1 }}; auto ps = plot ( z ); ps [ 0 ] -> use_y2 ( true ). color ( \"m\" ); ps [ 1 ] -> use_y2 ( true ). color ( \"m\" ). line_style ( \"--\" ); gca () -> y2_axis (). color ( \"m\" ); legend (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_2d magic = {{ 8 , 3 , 4 }, { 1 , 5 , 9 }, { 6 , 7 , 2 }}; bar ( magic ); auto ax = gca (); ax -> y_axis (). color ( ax -> colororder ()[ 0 ]); hold ( on ); scatter ( std :: vector { 1. , 2. , 3. }, std :: vector { 2. , 5. , 2. }) -> marker_face ( true ) . use_y2 ( true ); scatter ( std :: vector { 1. , 2. , 3. }, std :: vector { 3. , 4. , 1. }) -> marker_face ( true ) . use_y2 ( true ); scatter ( std :: vector { 1. , 2. , 3. }, std :: vector { 4. , 2. , 4. }) -> marker_face ( true ) . use_y2 ( true ); ax -> y2_axis (). color ( ax -> colororder ()[ 1 ]); hold ( off ); legend (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d x = linspace ( 1 , 10 ); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x , transform ( x , []( double x ) { return sin ( x ); })); hold ( on ); plot ( ax1 , x , transform ( x , []( double x ) { return exp ( x ); })) -> use_y2 ( true ); auto ax2 = nexttile (); plot ( ax2 , iota ( 1 , 10 )); show (); return 0 ; }","title":"YY-axis"},{"location":"appearance/multiplot/yy-axis/#yy-axis","text":"1 plot ( x , y ) -> use_y2 ( true ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; auto x = linspace ( 0 , 10 ); auto y1 = transform ( x , []( double x ) { return sin ( 3 * x ); }); plot ( x , y1 ); hold ( on ); auto z = transform ( x , []( double x ) { return sin ( 3 * x ) * exp ( 0.5 * x ); }); plot ( x , z ) -> use_y2 ( true ); y2lim ({ -150 , 150 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ind = linspace ( 0 , 51 ); auto drivers = transform ( ind , []( double ind ) { return pow ( ind , 2 ) + randn ( 0 , 50 ); }); scatter ( ind , drivers ); title ( \"Highway data\" ); xlabel ( \"States\" ); ylabel ( \"Licensed Drivers\" ); ylim ({ 0 , inf }); hold ( on ); auto pop = transform ( ind , []( double ind ) { return 10000 * ( pow ( ind , 2 ) + randn ( 0 , 100 )); }); scatter ( ind , pop ) -> use_y2 ( true ); y2label ( \"Vehicle Miles Traveled\" ); y2lim ({ 0 , inf }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d x = linspace ( 0 , 10 ); auto yl1 = transform ( x , []( double x ) { return sin ( x ); }); auto yl2 = transform ( x , []( double x ) { return sin ( x / 2 ); }); plot ( x , yl1 ) -> color ( gca () -> colororder ()[ 0 ]); hold ( on ); plot ( x , yl2 ) -> color ( gca () -> colororder ()[ 0 ]). line_style ( \"--\" ); auto yr1 = x ; auto yr2 = transform ( x , []( double x ) { return pow ( x , 2 ); }); plot ( x , yr1 ) -> use_y2 ( true ). color ( gca () -> colororder ()[ 1 ]); plot ( x , yr2 ) -> use_y2 ( true ). color ( gca () -> colororder ()[ 1 ]). line_style ( \"--\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <matplot/matplot.h> int main () { using namespace matplot ; colororder ({ \"b\" , \"m\" }); vector_2d y = {{ 1 , 3 }, { 2 , 4 }}; auto p1 = plot ( y ); p1 [ 0 ] -> color ( \"b\" ); p1 [ 1 ] -> color ( \"b\" ). line_style ( \"--\" ); gca () -> y_axis (). color ( \"b\" ); hold ( on ); vector_2d z = {{ 4 , 2 }, { 3 , 1 }}; auto ps = plot ( z ); ps [ 0 ] -> use_y2 ( true ). color ( \"m\" ); ps [ 1 ] -> use_y2 ( true ). color ( \"m\" ). line_style ( \"--\" ); gca () -> y2_axis (). color ( \"m\" ); legend (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_2d magic = {{ 8 , 3 , 4 }, { 1 , 5 , 9 }, { 6 , 7 , 2 }}; bar ( magic ); auto ax = gca (); ax -> y_axis (). color ( ax -> colororder ()[ 0 ]); hold ( on ); scatter ( std :: vector { 1. , 2. , 3. }, std :: vector { 2. , 5. , 2. }) -> marker_face ( true ) . use_y2 ( true ); scatter ( std :: vector { 1. , 2. , 3. }, std :: vector { 3. , 4. , 1. }) -> marker_face ( true ) . use_y2 ( true ); scatter ( std :: vector { 1. , 2. , 3. }, std :: vector { 4. , 2. , 4. }) -> marker_face ( true ) . use_y2 ( true ); ax -> y2_axis (). color ( ax -> colororder ()[ 1 ]); hold ( off ); legend (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d x = linspace ( 1 , 10 ); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x , transform ( x , []( double x ) { return sin ( x ); })); hold ( on ); plot ( ax1 , x , transform ( x , []( double x ) { return exp ( x ); })) -> use_y2 ( true ); auto ax2 = nexttile (); plot ( ax2 , iota ( 1 , 10 )); show (); return 0 ; }","title":"YY-axis"},{"location":"coding-styles/backends/","text":"Backends This library currently include a GnuPlot backend and an experimental OpenGL backend. Coming up with new backends is a continuous process. See the complete article for a description of the backend interface , a description of the current default backend ( Gnuplot pipe ), and what's involved in possible new backends . See the directory source/matplot/backend for some examples. Also, have a look at this example test/backends/main.cpp . If you're in a hurry, here is a summary of the backends we have and the backends we have been considering or are working on: Gnuplot Pros: It seems to be working for everyone. Cons: Pipes are comparatively slow and unidirectional In practice, this is default backend you'll get right now. OpenGL Pros: Efficient for many FPS. Cons: Blocks the main thread on some operating systems The experimental OpenGL backend already works for some plot categories. see 1 Qt Same as OpenGL see 1 , 2 AGG Pros: Great for vector graphics Cons: Unmaintained, 2D only, and non-interactive by itself see 1 , 2 , 3","title":"Backends"},{"location":"coding-styles/backends/#backends","text":"This library currently include a GnuPlot backend and an experimental OpenGL backend. Coming up with new backends is a continuous process. See the complete article for a description of the backend interface , a description of the current default backend ( Gnuplot pipe ), and what's involved in possible new backends . See the directory source/matplot/backend for some examples. Also, have a look at this example test/backends/main.cpp . If you're in a hurry, here is a summary of the backends we have and the backends we have been considering or are working on: Gnuplot Pros: It seems to be working for everyone. Cons: Pipes are comparatively slow and unidirectional In practice, this is default backend you'll get right now. OpenGL Pros: Efficient for many FPS. Cons: Blocks the main thread on some operating systems The experimental OpenGL backend already works for some plot categories. see 1 Qt Same as OpenGL see 1 , 2 AGG Pros: Great for vector graphics Cons: Unmaintained, 2D only, and non-interactive by itself see 1 , 2 , 3","title":"Backends"},{"location":"coding-styles/common-utilities/","text":"Common Utilities The headers common.h and colors.h include a number of utilities we use in our examples. These include naive functions to: generate and manipulate vectors and strings; handle RGBA color arrays; convert points to and from polar coordinates; read files to strings; write strings to files; calculate gradients; read, write, and manipulate images; and generate vectors with random numbers. Although some of these functions might be helpful, most functions only operate on std::vector<double> and they are not intended to be a library of utilities. The sole purpose of these algorithms is to simplify the examples.","title":"Common Utilities"},{"location":"coding-styles/common-utilities/#common-utilities","text":"The headers common.h and colors.h include a number of utilities we use in our examples. These include naive functions to: generate and manipulate vectors and strings; handle RGBA color arrays; convert points to and from polar coordinates; read files to strings; write strings to files; calculate gradients; read, write, and manipulate images; and generate vectors with random numbers. Although some of these functions might be helpful, most functions only operate on std::vector<double> and they are not intended to be a library of utilities. The sole purpose of these algorithms is to simplify the examples.","title":"Common Utilities"},{"location":"coding-styles/member-vs-free-standing-functions/","text":"Member vs. Free-standing Functions Like in Matplotlib, we support two coding styles: Free-standing functions and an Object-oriented interface. These two examples would generate the same plot: Free-standing functions 1 2 3 auto ax = gca (); plot ( ax , x , y ) -> color ( \"red\" ). line_width ( 2 ); my_function ( ax ); Object-oriented interface 1 2 3 auto ax = gca (); ax -> plot ( x , y ) -> color ( \"red\" ). line_width ( 2 ); my_function ( ax ); Freestanding functions: We call functions to create plots on the current axes The global current axes object is the current axes object in the current figure in the global figure registry For instance, one can use plot(y); to create a line plot on the current axes (or create a new axes object if needed). Also, one can use plot(ax,y); to create a line plot on the axes object ax . This is less verbose for small projects and quick tests. The library looks for existing axes to create the plot. Object-oriented interface: We explicitly create figures and call methods on them For instance, one can use ax->plot(y); to plot on the axes object ax We can create the same line plot on the current axes by auto ax = gca(); ax->plot(y); This is less verbose and provides better control in large projects where we need to pass these objects around The user manages axes handles containing plots. All free-standing functions are templated functions that use meta-programming to call the main function on the current axes object. If the first parameter is not an axes_handle , it will get an axes_handle from the figure registry with gca (Section Axes Object ) and forward all parameters to the function in this axes object. If the first parameter is an axes_handle , the template function will forward all parameters, but the first one, to this axes object. This use of templates for the free-standing functions keeps both coding styles maintainable by the developers. Note that, because the example needs the axes object for the function my_function , we also need to get a reference to the axes object with the free-standing functions. In that case, the free-standing functions are not less verbose than the object-oriented interface. To adhere to free-standing functions, we could create two versions of my_function : one that receives an axes_handle , and a second version that would get an axes_handle from the figure registry and call the first version. If my_function is going to be exposed to other users as a library, this could be a convenience to these users. However, notice that this is only moving the verbosity from the main function to my_function . In fact, this is how the free-standing functions in Matplot++ work.","title":"Member vs. Free-standing Functions"},{"location":"coding-styles/member-vs-free-standing-functions/#member-vs-free-standing-functions","text":"Like in Matplotlib, we support two coding styles: Free-standing functions and an Object-oriented interface. These two examples would generate the same plot: Free-standing functions 1 2 3 auto ax = gca (); plot ( ax , x , y ) -> color ( \"red\" ). line_width ( 2 ); my_function ( ax ); Object-oriented interface 1 2 3 auto ax = gca (); ax -> plot ( x , y ) -> color ( \"red\" ). line_width ( 2 ); my_function ( ax ); Freestanding functions: We call functions to create plots on the current axes The global current axes object is the current axes object in the current figure in the global figure registry For instance, one can use plot(y); to create a line plot on the current axes (or create a new axes object if needed). Also, one can use plot(ax,y); to create a line plot on the axes object ax . This is less verbose for small projects and quick tests. The library looks for existing axes to create the plot. Object-oriented interface: We explicitly create figures and call methods on them For instance, one can use ax->plot(y); to plot on the axes object ax We can create the same line plot on the current axes by auto ax = gca(); ax->plot(y); This is less verbose and provides better control in large projects where we need to pass these objects around The user manages axes handles containing plots. All free-standing functions are templated functions that use meta-programming to call the main function on the current axes object. If the first parameter is not an axes_handle , it will get an axes_handle from the figure registry with gca (Section Axes Object ) and forward all parameters to the function in this axes object. If the first parameter is an axes_handle , the template function will forward all parameters, but the first one, to this axes object. This use of templates for the free-standing functions keeps both coding styles maintainable by the developers. Note that, because the example needs the axes object for the function my_function , we also need to get a reference to the axes object with the free-standing functions. In that case, the free-standing functions are not less verbose than the object-oriented interface. To adhere to free-standing functions, we could create two versions of my_function : one that receives an axes_handle , and a second version that would get an axes_handle from the figure registry and call the first version. If my_function is going to be exposed to other users as a library, this could be a convenience to these users. However, notice that this is only moving the verbosity from the main function to my_function . In fact, this is how the free-standing functions in Matplot++ work.","title":"Member vs. Free-standing Functions"},{"location":"coding-styles/method-chaining/","text":"Method Chaining To support a more compact syntax, the library allows method chaining on plot objects. For instance, we can create a simple line plot and modify its appearance by Object Handle 1 2 3 4 5 6 // Using the line handle auto p = plot ( x , y , \"--gs\" ); p -> line_width ( 2 ); p -> marker_size ( 10 ); p -> marker_color ( \"b\" ); p -> marker_face_color ({ .5 , .5 , .5 }); Method Chaining 1 2 3 4 5 6 // Method chaining plot ( x , y , \"--gs\" ) -> line_width ( 2 ) . marker_size ( 10 ) . marker_color ( \"b\" ) . marker_face_color ({ .5 , .5 , .5 }); The first code snippet works because plot returns a line_handle to the object in the axes . We can use this line handle to modify the line plot. Whenever we modify a property, the setter function calls touch , which will draw the figure again if it is in reactive mode. The second option works because setters return a reference to *this rather than void.","title":"Method Chaining"},{"location":"coding-styles/method-chaining/#method-chaining","text":"To support a more compact syntax, the library allows method chaining on plot objects. For instance, we can create a simple line plot and modify its appearance by Object Handle 1 2 3 4 5 6 // Using the line handle auto p = plot ( x , y , \"--gs\" ); p -> line_width ( 2 ); p -> marker_size ( 10 ); p -> marker_color ( \"b\" ); p -> marker_face_color ({ .5 , .5 , .5 }); Method Chaining 1 2 3 4 5 6 // Method chaining plot ( x , y , \"--gs\" ) -> line_width ( 2 ) . marker_size ( 10 ) . marker_color ( \"b\" ) . marker_face_color ({ .5 , .5 , .5 }); The first code snippet works because plot returns a line_handle to the object in the axes . We can use this line handle to modify the line plot. Whenever we modify a property, the setter function calls touch , which will draw the figure again if it is in reactive mode. The second option works because setters return a reference to *this rather than void.","title":"Method Chaining"},{"location":"coding-styles/motivation-and-details/","text":"Motivation and Details If you are interested in understanding how the library works, you can read the details in the complete article . It describes the relationship between its main objects, the backend interface, how to create new plot categories, its limitations, and compares this library with similar alternatives.","title":"Motivation and Details"},{"location":"coding-styles/motivation-and-details/#motivation-and-details","text":"If you are interested in understanding how the library works, you can read the details in the complete article . It describes the relationship between its main objects, the backend interface, how to create new plot categories, its limitations, and compares this library with similar alternatives.","title":"Motivation and Details"},{"location":"coding-styles/ranges/","text":"Ranges The plotting functions work on any range of elements convertible to double . For instance, we can create a line plot from a set of elements by 1 2 set < int > y = { 6 , 3 , 8 , 2 , 5 }; plot ( y ); Any object that has the functions begin and end are considered iterable ranges. Most axes object subclasses use vector<double> or vector<vector<double>> to store their data. For convenience, the common.h header file includes the aliases vector_1d and vector_2d to these data types. These conversions also work on ranges of ranges: 1 2 vector < set < int >> Y = { { 6 , 3 , 8 , 2 , 5 }, { 6 , 3 , 5 , 8 , 2 } }; plot ( Y ); Unfortunately, because of how templated functions work, one exception is initializer lists. Initializer lists only work for functions that are explicitly defined for them.","title":"Ranges"},{"location":"coding-styles/ranges/#ranges","text":"The plotting functions work on any range of elements convertible to double . For instance, we can create a line plot from a set of elements by 1 2 set < int > y = { 6 , 3 , 8 , 2 , 5 }; plot ( y ); Any object that has the functions begin and end are considered iterable ranges. Most axes object subclasses use vector<double> or vector<vector<double>> to store their data. For convenience, the common.h header file includes the aliases vector_1d and vector_2d to these data types. These conversions also work on ranges of ranges: 1 2 vector < set < int >> Y = { { 6 , 3 , 8 , 2 , 5 }, { 6 , 3 , 5 , 8 , 2 } }; plot ( Y ); Unfortunately, because of how templated functions work, one exception is initializer lists. Initializer lists only work for functions that are explicitly defined for them.","title":"Ranges"},{"location":"coding-styles/reactive-vs-quiet-figures/","text":"Reactive vs. Quiet Figures There are also two modes for figures: reactive (or interactive) mode and quiet mode. Reactive mode 1 2 3 4 5 6 // Reactive mode auto f = figure ( false ); auto ax = f -> gca (); auto p = ax -> plot ( ax , x , y ); // draws once p -> color ( \"red\" ). line_width ( 2 ); // draws twice more show (); // pause console Quiet mode 1 2 3 4 5 6 // Quiet mode auto f = figure ( true ); auto ax = f -> gca (); auto p = ax -> plot ( x , y ); // does not draw p -> color ( \"red\" ). line_width ( 2 ); // does not draw f -> show (); // draw only once and pause console Figures in reactive mode are updated whenever any of their child objects change. This happens through the touch function, that gets called on any child object when it changes its appearance. This creates an interactive mode in which figures are updated as soon as we adjust their properties. If we combine interactive figures with free-standing functions, we have a \"Matlab-like style\" for plots. This is a coding pattern where the figure registry works as a stream for plots. The problem with this coding style is that the user might unnecessarily create useless intermediary plots. Figures in quiet mode are updated by calling the functions draw() or show() (Section Reactive Figures ). Unless these functions are called, nothing changes in the figure. The combination of the object-oriented coding style and quiet mode is the \"OO-Matplotlib-like style\" for plots. This is a coding style in which the user explicitly decides when the plot is shown or updated. This is beneficial to applications that cannot waste computational resources on intermediary figures that might not be valuable to the application. We generally use free-standing functions with reactive mode and the object-oriented interface with quiet mode. By default, new figures are in reactive mode, unless it is using an non-interactive backend. One can turn this reactive mode on and off with: ion() or ioff() free-standing functions reactive(bool) or quiet(bool) function on the figure object figure(true) or figure(false) when explicitly creating a new figure For convenience, the examples in Section Examples use the reactive mode. The show function pauses the console until the user interacts with the plot window. If the backend is based on process pipes, because these are unidirectional, closing the window is not enough to resume. The user needs to use the console to unblock execution. A similar example is quiet mode would be In this example, the figure is only updated once. The user could replace the show function with the draw function, but the window would close as soon as execution completes. It is important to use show() with caution. These functions are meant for some particular executables so that an interactive plot does not close before the user can see it. It is probably unreasonable to call these functions inside a library because the user would have to manually interfere with the execution to continue.","title":"Reactive vs. Quiet Figures"},{"location":"coding-styles/reactive-vs-quiet-figures/#reactive-vs-quiet-figures","text":"There are also two modes for figures: reactive (or interactive) mode and quiet mode. Reactive mode 1 2 3 4 5 6 // Reactive mode auto f = figure ( false ); auto ax = f -> gca (); auto p = ax -> plot ( ax , x , y ); // draws once p -> color ( \"red\" ). line_width ( 2 ); // draws twice more show (); // pause console Quiet mode 1 2 3 4 5 6 // Quiet mode auto f = figure ( true ); auto ax = f -> gca (); auto p = ax -> plot ( x , y ); // does not draw p -> color ( \"red\" ). line_width ( 2 ); // does not draw f -> show (); // draw only once and pause console Figures in reactive mode are updated whenever any of their child objects change. This happens through the touch function, that gets called on any child object when it changes its appearance. This creates an interactive mode in which figures are updated as soon as we adjust their properties. If we combine interactive figures with free-standing functions, we have a \"Matlab-like style\" for plots. This is a coding pattern where the figure registry works as a stream for plots. The problem with this coding style is that the user might unnecessarily create useless intermediary plots. Figures in quiet mode are updated by calling the functions draw() or show() (Section Reactive Figures ). Unless these functions are called, nothing changes in the figure. The combination of the object-oriented coding style and quiet mode is the \"OO-Matplotlib-like style\" for plots. This is a coding style in which the user explicitly decides when the plot is shown or updated. This is beneficial to applications that cannot waste computational resources on intermediary figures that might not be valuable to the application. We generally use free-standing functions with reactive mode and the object-oriented interface with quiet mode. By default, new figures are in reactive mode, unless it is using an non-interactive backend. One can turn this reactive mode on and off with: ion() or ioff() free-standing functions reactive(bool) or quiet(bool) function on the figure object figure(true) or figure(false) when explicitly creating a new figure For convenience, the examples in Section Examples use the reactive mode. The show function pauses the console until the user interacts with the plot window. If the backend is based on process pipes, because these are unidirectional, closing the window is not enough to resume. The user needs to use the console to unblock execution. A similar example is quiet mode would be In this example, the figure is only updated once. The user could replace the show function with the draw function, but the window would close as soon as execution completes. It is important to use show() with caution. These functions are meant for some particular executables so that an interactive plot does not close before the user can see it. It is probably unreasonable to call these functions inside a library because the user would have to manually interfere with the execution to continue.","title":"Reactive vs. Quiet Figures"},{"location":"community/contributing-guidelines/","text":"Contributing Guidelines If contributing with code, please leave the OpenGL backend and pedantic mode ON ( -DBUILD_EXPERIMENTAL_OPENGL_BACKEND=ON -DBUILD_WITH_PEDANTIC_WARNINGS=ON ), use cppcheck , and clang-format . Example: CLion If contributing to the documentation, please edit README.md directly, as the files in ./docs are automatically generated with mdsplit .","title":"Contributing Guidelines"},{"location":"community/contributing-guidelines/#contributing-guidelines","text":"If contributing with code, please leave the OpenGL backend and pedantic mode ON ( -DBUILD_EXPERIMENTAL_OPENGL_BACKEND=ON -DBUILD_WITH_PEDANTIC_WARNINGS=ON ), use cppcheck , and clang-format . Example: CLion If contributing to the documentation, please edit README.md directly, as the files in ./docs are automatically generated with mdsplit .","title":"Contributing Guidelines"},{"location":"community/contributors/","text":"Contributors Alan De Freitas Duncan Ogilvie Luis CC!ceres Actions-user Marcus Asteborg Randy Jones Sammi Alex Dimitrij Mijoski MaBnt Niclas Wall Wennerdal Akash Patel Andrew Kane We would also like to thank The Icculus Microgrant .","title":"Contributors"},{"location":"community/contributors/#contributors","text":"Alan De Freitas Duncan Ogilvie Luis CC!ceres Actions-user Marcus Asteborg Randy Jones Sammi Alex Dimitrij Mijoski MaBnt Niclas Wall Wennerdal Akash Patel Andrew Kane We would also like to thank The Icculus Microgrant .","title":"Contributors"},{"location":"community/get-involved/","text":"Get Involved After getting started with this library, please complete this survey to let us know how we can improve your experience. Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community. If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome. It'd be great to see this library help people write lots and lots of academic papers.","title":"Get Involved"},{"location":"community/get-involved/#get-involved","text":"After getting started with this library, please complete this survey to let us know how we can improve your experience. Discussions are concentrated on our GitHub discussions page. Don't refrain from asking questions and proposing ideas. If this library helps you create something interesting, please divulge it with the community. If you are a programmer with good ideas, please share these ideas with us. Academic collaboration is more than welcome. It'd be great to see this library help people write lots and lots of academic papers.","title":"Get Involved"},{"location":"community/ideas-and-roadmap/","text":"Ideas and Roadmap Feel free to contribute with new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its own conventions might seem intricate at first but please don't let that discourage you from sharing your ideas. There are many ways in which you can contribute to this library: Testing the library in new environments see 1 , 2 , 3 Contributing with interesting examples see 1 Designing new backends see 1 , 2 , 3 , 4 Finding problems in this documentation see 1 Writing algorithms for new plot categories see 1 Finding bugs in general see 1 , 2 , 3 , 4 Whatever idea seems interesting to you The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative \"I removed this feature so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first","title":"Ideas and Roadmap"},{"location":"community/ideas-and-roadmap/#ideas-and-roadmap","text":"Feel free to contribute with new features to this library. For complex features and changes, consider getting feedback from the community first. Contributing to an existing code base with its own conventions might seem intricate at first but please don't let that discourage you from sharing your ideas. There are many ways in which you can contribute to this library: Testing the library in new environments see 1 , 2 , 3 Contributing with interesting examples see 1 Designing new backends see 1 , 2 , 3 , 4 Finding problems in this documentation see 1 Writing algorithms for new plot categories see 1 Finding bugs in general see 1 , 2 , 3 , 4 Whatever idea seems interesting to you The only thing we ask you is to make sure your contribution is not destructive. Some contributions in which we are not interested are: \"I don't like this optional feature so I removed/deprecated it\" \"I removed this feature to support older versions of C++\" but have not provided an equivalent alternative \"I removed this feature so I don't have to install/update ______\" but have not provided an equivalent alternative \"I'm creating this high-cost promise that we'll support _ _ forever\" but I'm not sticking around to keep that promise In doubt, please open a discussion first","title":"Ideas and Roadmap"},{"location":"exporting/saving-manually/","text":"Saving (Manually) The interactive plot window contains a widget to save the current figure. Because this widget uses the same backend as the one used to produce the interactive image, the final image matches closely what the user sees in the window.","title":"Saving (Manually)"},{"location":"exporting/saving-manually/#saving-manually","text":"The interactive plot window contains a widget to save the current figure. Because this widget uses the same backend as the one used to produce the interactive image, the final image matches closely what the user sees in the window.","title":"Saving (Manually)"},{"location":"exporting/saving-programatically/","text":"Saving (Programatically) You can programmatically save the figure in a number of formats with the save function: 1 save ( filename ); or 1 save ( filename , fileformat ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 29 , 17 , 14 , 13 , 12 , 4 , 11 }; bar ( x ); save ( \"img/barchart.svg\" ); save ( \"img/barchart.eps\" ); save ( \"img/barchart.gif\" ); save ( \"img/barchart.jpg\" ); save ( \"img/barchart.html\" ); save ( \"img/barchart.txt\" ); save ( \"img/barchart.tex\" ); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = figure ( true ); std :: vector < double > x = { 2 , 4 , 7 , 2 , 4 , 5 , 2 , 5 , 1 , 4 }; bar ( x ); save ( \"img/barchart_ps\" , \"postscript\" ); save ( \"img/barchart_latex\" , \"epslatex\" ); /* * Add to your latex document: * \\begin{figure} * \\input{Barchart_latex} * \\end{figure} */ save ( \"img/barchart_gif\" , \"gif\" ); save ( \"img/barchart_jpeg\" , \"jpeg\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = figure ( true ); f -> font ( \"Helvetica\" ); std :: vector < double > x = { 2 , 4 , 7 , 2 , 4 , 5 , 2 , 5 , 1 , 4 }; bar ( x ); const auto & m = backend :: gnuplot :: extension_terminal (); for ( const auto & [ extension , format ] : m ) { save ( std :: string ( \"formats/barchart \" ) + std :: string ( format ), std :: string ( format )); } return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); contourf ( x , y , z ); save ( \"img/contour.gif\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = figure ( true ); plot ( rand ( 5 , 5 , 0 , 1 )); save ( \"img/lineplot.eps\" ); save ( \"img/lineplot.jpg\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); textarrow ( 2 , 8 , 5 , 5 , \"y=x\" ); save ( \"img/annotation.eps\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); nexttile (); plot ({ 1. , 2. , 3. }); nexttile (); plot ({ 3. , 2. , 1. }); save ( \"img/layout.eps\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); save ( \"img/peaks.gif\" ); save ( \"img/peaks.eps\" ); show (); return 0 ; } The first option ( save(filename) ) infers the appropriate file format from the filename extension. In both cases ( save(filename) and save(filename,fileformat) ), this function temporarily changes the backend to a non-interactive backend appropriate to draw the figure. A different backend is used for each format and, depending on the format, the final image does not necessarily match what is on the interactive plot window. The reason is that some file formats purposefully do not include the same features. For instance, consider the bar chart generated by 1 2 vector < double > x = { 29 , 17 , 14 , 13 , 12 , 4 , 11 }; bar ( x ); If we export the image with 1 save ( \"barchart.svg\" ); we get the vector graphics See result Exporting the image with 1 save ( \"barchart.txt\" ); generates a representation of the image appropriate for text or markdown files, such as See result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 30 +-----------------------------------------------------------+ | ******* + + + + + + | | * * | 25 |-+ * * +-| | * * | | * * | 20 |-+ * * +-| | * * | | * ******** | 15 |-+ * ** * +-| | * ** * ******* | | * ** * * ******** ******* | | * ** * * ** * * * ******* | 10 |-+ * ** * * ** * * * * * +-| | * ** * * ** * * * * * | | * ** * * ** * * * * * | 5 |-+ * ** * * ** * * ******** * * +-| | * ** * * ** * * ** * * * | | * + ** + * * + ** + * * + ** + * * + * | 0 +-----------------------------------------------------------+ 1 2 3 4 5 6 7 As the last example, saving an image with 1 save ( \"barchart.tex\" ); would save the image in a format appropriate to embed in latex documents, such as See result This exports the image in a format in which the labels are replaced by latex text so that the plot fits the rest of the document.","title":"Saving (Programatically)"},{"location":"exporting/saving-programatically/#saving-programatically","text":"You can programmatically save the figure in a number of formats with the save function: 1 save ( filename ); or 1 save ( filename , fileformat ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 29 , 17 , 14 , 13 , 12 , 4 , 11 }; bar ( x ); save ( \"img/barchart.svg\" ); save ( \"img/barchart.eps\" ); save ( \"img/barchart.gif\" ); save ( \"img/barchart.jpg\" ); save ( \"img/barchart.html\" ); save ( \"img/barchart.txt\" ); save ( \"img/barchart.tex\" ); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = figure ( true ); std :: vector < double > x = { 2 , 4 , 7 , 2 , 4 , 5 , 2 , 5 , 1 , 4 }; bar ( x ); save ( \"img/barchart_ps\" , \"postscript\" ); save ( \"img/barchart_latex\" , \"epslatex\" ); /* * Add to your latex document: * \\begin{figure} * \\input{Barchart_latex} * \\end{figure} */ save ( \"img/barchart_gif\" , \"gif\" ); save ( \"img/barchart_jpeg\" , \"jpeg\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = figure ( true ); f -> font ( \"Helvetica\" ); std :: vector < double > x = { 2 , 4 , 7 , 2 , 4 , 5 , 2 , 5 , 1 , 4 }; bar ( x ); const auto & m = backend :: gnuplot :: extension_terminal (); for ( const auto & [ extension , format ] : m ) { save ( std :: string ( \"formats/barchart \" ) + std :: string ( format ), std :: string ( format )); } return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); contourf ( x , y , z ); save ( \"img/contour.gif\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = figure ( true ); plot ( rand ( 5 , 5 , 0 , 1 )); save ( \"img/lineplot.eps\" ); save ( \"img/lineplot.jpg\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 10 )); textarrow ( 2 , 8 , 5 , 5 , \"y=x\" ); save ( \"img/annotation.eps\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); nexttile (); plot ({ 1. , 2. , 3. }); nexttile (); plot ({ 3. , 2. , 1. }); save ( \"img/layout.eps\" ); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y , z ] = peaks (); surf ( x , y , z ); save ( \"img/peaks.gif\" ); save ( \"img/peaks.eps\" ); show (); return 0 ; } The first option ( save(filename) ) infers the appropriate file format from the filename extension. In both cases ( save(filename) and save(filename,fileformat) ), this function temporarily changes the backend to a non-interactive backend appropriate to draw the figure. A different backend is used for each format and, depending on the format, the final image does not necessarily match what is on the interactive plot window. The reason is that some file formats purposefully do not include the same features. For instance, consider the bar chart generated by 1 2 vector < double > x = { 29 , 17 , 14 , 13 , 12 , 4 , 11 }; bar ( x ); If we export the image with 1 save ( \"barchart.svg\" ); we get the vector graphics See result Exporting the image with 1 save ( \"barchart.txt\" ); generates a representation of the image appropriate for text or markdown files, such as See result 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 30 +-----------------------------------------------------------+ | ******* + + + + + + | | * * | 25 |-+ * * +-| | * * | | * * | 20 |-+ * * +-| | * * | | * ******** | 15 |-+ * ** * +-| | * ** * ******* | | * ** * * ******** ******* | | * ** * * ** * * * ******* | 10 |-+ * ** * * ** * * * * * +-| | * ** * * ** * * * * * | | * ** * * ** * * * * * | 5 |-+ * ** * * ** * * ******** * * +-| | * ** * * ** * * ** * * * | | * + ** + * * + ** + * * + ** + * * + * | 0 +-----------------------------------------------------------+ 1 2 3 4 5 6 7 As the last example, saving an image with 1 save ( \"barchart.tex\" ); would save the image in a format appropriate to embed in latex documents, such as See result This exports the image in a format in which the labels are replaced by latex text so that the plot fits the rest of the document.","title":"Saving (Programatically)"},{"location":"integration/cmake/embed-as-subdirectory/","text":"Embed as subdirectory You can use Matplot++ directly in CMake projects as a subproject, without installing it. This is convenient if you are experimenting with this library for the first time or don't expect your users to have Matplot++ installed on their systems. Check if you have Cmake 3.14+ installed: 1 cmake --version Clone the whole project 1 git clone https://github.com/alandefreitas/matplotplusplus/ and add the subdirectory to your CMake project: 1 add_subdirectory ( matplotplusplus ) When creating your executable, link the library to the targets you want: 1 2 add_executable ( my_target main.cpp ) target_link_libraries ( my_target PUBLIC matplot ) Add this header to your source files: 1 #include <matplot/matplot.h> However, in larger projects, it's always recommended to look for Matplot++ with find_package before including it as a subdirectory to avoid ODR errors .","title":"Embed as subdirectory"},{"location":"integration/cmake/embed-as-subdirectory/#embed-as-subdirectory","text":"You can use Matplot++ directly in CMake projects as a subproject, without installing it. This is convenient if you are experimenting with this library for the first time or don't expect your users to have Matplot++ installed on their systems. Check if you have Cmake 3.14+ installed: 1 cmake --version Clone the whole project 1 git clone https://github.com/alandefreitas/matplotplusplus/ and add the subdirectory to your CMake project: 1 add_subdirectory ( matplotplusplus ) When creating your executable, link the library to the targets you want: 1 2 add_executable ( my_target main.cpp ) target_link_libraries ( my_target PUBLIC matplot ) Add this header to your source files: 1 #include <matplot/matplot.h> However, in larger projects, it's always recommended to look for Matplot++ with find_package before including it as a subdirectory to avoid ODR errors .","title":"Embed as subdirectory"},{"location":"integration/cmake/embed-with-automatic-download/","text":"Embed with automatic download FetchContent is a CMake command that can automatically download the Matplot++ repository. Check if you have Cmake 3.14+ installed: 1 cmake --version Include FetchContent in your CMake build script: 1 include ( FetchContent ) Declare the source for the contents: 1 2 3 FetchContent_Declare ( matplotplusplus GIT_REPOSITORY https://github.com/alandefreitas/matplotplusplus GIT_TAG origin/master # or whatever tag you want Let CMake download the repository and include it as a subdirectory. 1 2 3 4 5 FetchContent_GetProperties ( matplotplusplus ) if ( NOT matplotplusplus_POPULATED ) FetchContent_Populate ( matplotplusplus ) add_subdirectory ( ${ matplotplusplus_SOURCE_DIR } ${ matplotplusplus_BINARY_DIR } EXCLUDE_FROM_ALL ) endif () When creating your executable, link the library to the targets you want: 1 2 add_executable(my_target main.cpp) target_link_libraries(my_target PUBLIC matplot) Then add this header to your source files: 1 #include <matplot/matplot.h> However, in larger projects, it's always recommended to look for Matplot++ with find_package before including it as a subdirectory to avoid ODR errors .","title":"Embed with automatic download"},{"location":"integration/cmake/embed-with-automatic-download/#embed-with-automatic-download","text":"FetchContent is a CMake command that can automatically download the Matplot++ repository. Check if you have Cmake 3.14+ installed: 1 cmake --version Include FetchContent in your CMake build script: 1 include ( FetchContent ) Declare the source for the contents: 1 2 3 FetchContent_Declare ( matplotplusplus GIT_REPOSITORY https://github.com/alandefreitas/matplotplusplus GIT_TAG origin/master # or whatever tag you want Let CMake download the repository and include it as a subdirectory. 1 2 3 4 5 FetchContent_GetProperties ( matplotplusplus ) if ( NOT matplotplusplus_POPULATED ) FetchContent_Populate ( matplotplusplus ) add_subdirectory ( ${ matplotplusplus_SOURCE_DIR } ${ matplotplusplus_BINARY_DIR } EXCLUDE_FROM_ALL ) endif () When creating your executable, link the library to the targets you want: 1 2 add_executable(my_target main.cpp) target_link_libraries(my_target PUBLIC matplot) Then add this header to your source files: 1 #include <matplot/matplot.h> However, in larger projects, it's always recommended to look for Matplot++ with find_package before including it as a subdirectory to avoid ODR errors .","title":"Embed with automatic download"},{"location":"integration/cmake/embed-with-cpmcmake/","text":"Embed with CPM.cmake CPM.cmake is a nice wrapper around the CMake FetchContent function. Check if you have Cmake 3.14+ installed: 1 cmake --version Install CPM.cmake and then use this command to add Matplot++ to your build script: 1 2 3 4 5 6 7 CPMAddPackage ( NAME matplotplusplus GITHUB_REPOSITORY alandefreitas/matplotplusplus GIT_TAG origin/master # or whatever tag you want ) # ... target_link_libraries ( my_target PUBLIC matplot ) Then add this header to your source files: 1 #include <matplot/matplot.h> However, in larger projects, it's always recommended to look for Matplot++ with find_package before including it as a subdirectory to avoid ODR errors . You can use: 1 option ( CPM_USE_LOCAL_PACKAGES \"Try `find_package` before downloading dependencies\" ON ) in your build script to let CPM.cmake do that for you.","title":"Embed with CPM.cmake"},{"location":"integration/cmake/embed-with-cpmcmake/#embed-with-cpmcmake","text":"CPM.cmake is a nice wrapper around the CMake FetchContent function. Check if you have Cmake 3.14+ installed: 1 cmake --version Install CPM.cmake and then use this command to add Matplot++ to your build script: 1 2 3 4 5 6 7 CPMAddPackage ( NAME matplotplusplus GITHUB_REPOSITORY alandefreitas/matplotplusplus GIT_TAG origin/master # or whatever tag you want ) # ... target_link_libraries ( my_target PUBLIC matplot ) Then add this header to your source files: 1 #include <matplot/matplot.h> However, in larger projects, it's always recommended to look for Matplot++ with find_package before including it as a subdirectory to avoid ODR errors . You can use: 1 option ( CPM_USE_LOCAL_PACKAGES \"Try `find_package` before downloading dependencies\" ON ) in your build script to let CPM.cmake do that for you.","title":"Embed with CPM.cmake"},{"location":"integration/cmake/find-as-external-package/","text":"Find as External Package If you have the library installed on your system, you can call find_package() from your CMake build script. 1 find_package ( Matplot++ REQUIRED ) When creating your executable, link the library to the targets you want: 1 2 add_executable ( my_target main.cpp ) target_link_libraries ( my_target PUBLIC Matplot++::matplot ) Then add this header to your source files: 1 #include <matplot/matplot.h> You can see a complete example in test/integration/CMakeLists.txt . CMake should be able to locate the matplot++-config.cmake script automatically if you installed the library under /usr/local/ (Linux / Mac OS). Unfortunately, there is no easy default directory for find_package on Windows. Default directories By default, the library is likely to be in /usr/local/ (Linux / Mac OS) or C:/Program Files/ (Windows). The installer will try to find the directory where you usually keep your libraries but that's not always perfect. Finding packages on Windows Unfortunately, CMake does not have a single default directory for packages on Windows like /usr/local/lib . If CMake cannot find Matplot++ on Windows or if you installed the library outside the default directory on Linux/Mac OS, there are a few options : Environment Variables : The most reliable way to set this default directory is through environment variables. You can create an environment variable MATPLOTPP_DIR and then add $ENV{MATPLOTPP_DIR} to the HINTS section of the find_package command. This tends to be more convenient than requiring the path on the command line every time. Starting with version 3.12, CMake now implicitly considers the <PackageName>_Root environment variable a HINT for every find_package call. Package Registry : CMake offers the Package Registry as an alternative mechanism for finding package locations. CMake maintains a list of package information in the Windows registry under HKEY_CURRENT_USER\\Software\\Kitware\\CMake\\Packages\\ . Append CMAKE_MODULE_PATH : You can append more directories to CMAKE_MODULE_PATH with something like list(APPEND CMAKE_MODULE_PATH \"C:\\\\Program Files\\\\matplotplusplus 1.0.1\") . CMAKE_MODULE_PATH is a list of search paths for CMake modules to be loaded by the include() or find_package() commands. Set the DIR variable directly : Directly set the Matplot++_DIR variable with something like set(Matplot++_DIR \"C:\\\\Program Files\\\\matplotplusplus 1.0.1\\\\lib\\\\cmake\\\\Matplot++\") . This might be good enough for small local projects but it is hard-coding the directory in your build script. When your library gets out of your local environment, you need to choose one of the other options above (better) or make this variable an option and require the user to provide the directory on the command line every time (worse).","title":"Find as External Package"},{"location":"integration/cmake/find-as-external-package/#find-as-external-package","text":"If you have the library installed on your system, you can call find_package() from your CMake build script. 1 find_package ( Matplot++ REQUIRED ) When creating your executable, link the library to the targets you want: 1 2 add_executable ( my_target main.cpp ) target_link_libraries ( my_target PUBLIC Matplot++::matplot ) Then add this header to your source files: 1 #include <matplot/matplot.h> You can see a complete example in test/integration/CMakeLists.txt . CMake should be able to locate the matplot++-config.cmake script automatically if you installed the library under /usr/local/ (Linux / Mac OS). Unfortunately, there is no easy default directory for find_package on Windows. Default directories By default, the library is likely to be in /usr/local/ (Linux / Mac OS) or C:/Program Files/ (Windows). The installer will try to find the directory where you usually keep your libraries but that's not always perfect. Finding packages on Windows Unfortunately, CMake does not have a single default directory for packages on Windows like /usr/local/lib . If CMake cannot find Matplot++ on Windows or if you installed the library outside the default directory on Linux/Mac OS, there are a few options : Environment Variables : The most reliable way to set this default directory is through environment variables. You can create an environment variable MATPLOTPP_DIR and then add $ENV{MATPLOTPP_DIR} to the HINTS section of the find_package command. This tends to be more convenient than requiring the path on the command line every time. Starting with version 3.12, CMake now implicitly considers the <PackageName>_Root environment variable a HINT for every find_package call. Package Registry : CMake offers the Package Registry as an alternative mechanism for finding package locations. CMake maintains a list of package information in the Windows registry under HKEY_CURRENT_USER\\Software\\Kitware\\CMake\\Packages\\ . Append CMAKE_MODULE_PATH : You can append more directories to CMAKE_MODULE_PATH with something like list(APPEND CMAKE_MODULE_PATH \"C:\\\\Program Files\\\\matplotplusplus 1.0.1\") . CMAKE_MODULE_PATH is a list of search paths for CMake modules to be loaded by the include() or find_package() commands. Set the DIR variable directly : Directly set the Matplot++_DIR variable with something like set(Matplot++_DIR \"C:\\\\Program Files\\\\matplotplusplus 1.0.1\\\\lib\\\\cmake\\\\Matplot++\") . This might be good enough for small local projects but it is hard-coding the directory in your build script. When your library gets out of your local environment, you need to choose one of the other options above (better) or make this variable an option and require the user to provide the directory on the command line every time (worse).","title":"Find as External Package"},{"location":"integration/cmake/supporting-both/","text":"Supporting Both It's often useful to let your build script download Matplot++ when find_package fails. If using CPM.cmake, you can set the CPM_USE_LOCAL_PACKAGES option to try to find_package(Matplot++) before download Matplot++. If using FetchContent, you can use the following pattern: 1 2 3 4 find_package ( Matplot++ QUIET ) if ( NOT Matplot++_FOUND ) # Put your FetchContent or CPM.cmake script here endif ()","title":"Supporting Both"},{"location":"integration/cmake/supporting-both/#supporting-both","text":"It's often useful to let your build script download Matplot++ when find_package fails. If using CPM.cmake, you can set the CPM_USE_LOCAL_PACKAGES option to try to find_package(Matplot++) before download Matplot++. If using FetchContent, you can use the following pattern: 1 2 3 4 find_package ( Matplot++ QUIET ) if ( NOT Matplot++_FOUND ) # Put your FetchContent or CPM.cmake script here endif ()","title":"Supporting Both"},{"location":"integration/install/binary-packages/","text":"Binary Packages Get the binary package from the release section . These binaries refer to the last release version of Matplot++. If you need a more recent version of Matplot++, you can download the binary packages from the CI artifacts or build the library from the source files .","title":"Binary Packages"},{"location":"integration/install/binary-packages/#binary-packages","text":"Get the binary package from the release section . These binaries refer to the last release version of Matplot++. If you need a more recent version of Matplot++, you can download the binary packages from the CI artifacts or build the library from the source files .","title":"Binary Packages"},{"location":"integration/install/build-from-source/build-and-install/","text":"Build and install Building Examples This will build the examples in the build/examples directory: Ubuntu + GCC 1 2 3 4 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" sudo cmake --build . --parallel 2 --config Release Mac Os + Clang 1 2 3 4 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" cmake --build . --parallel 2 --config Release Windows + MSVC 1 2 3 4 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"/O2\" cmake --build . --parallel 2 --config Release Parallel Build Replace --parallel 2 with --parallel <number of cores in your machine> Setting C++ Compiler If your C++ compiler that supports C++17 is not your default compiler, make sure you provide CMake with the compiler location with the DCMAKE_C_COMPILER and DCMAKE_CXX_COMPILER options. For instance: 1 cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" -DCMAKE_C_COMPILER = /usr/bin/gcc-8 -DCMAKE_CXX_COMPILER = /usr/bin/g++-8 Installing You can 1) use -DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF to bypass the examples and tests, and then 2) cmake --install . to install Matplot++ on your system: Ubuntu + GCC 1 2 3 4 5 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF sudo cmake --build . --parallel 2 --config Release sudo cmake --install . Mac Os + Clang 1 2 3 4 5 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF cmake --build . --parallel 2 --config Release cmake --install . Windows + MSVC 1 2 3 4 5 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"/O2\" -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF cmake --build . --parallel 2 --config Release cmake --install . Parallel Build Replace --parallel 2 with --parallel <number of cores in your machine> Create packages You can also create the binary packages to install Matplot++ on other systems: Ubuntu + GCC 1 sudo cpack . Mac Os + Clang 1 cpack . Windows + MSVC 1 cpack .","title":"Build and install"},{"location":"integration/install/build-from-source/build-and-install/#build-and-install","text":"Building Examples This will build the examples in the build/examples directory: Ubuntu + GCC 1 2 3 4 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" sudo cmake --build . --parallel 2 --config Release Mac Os + Clang 1 2 3 4 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" cmake --build . --parallel 2 --config Release Windows + MSVC 1 2 3 4 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"/O2\" cmake --build . --parallel 2 --config Release Parallel Build Replace --parallel 2 with --parallel <number of cores in your machine> Setting C++ Compiler If your C++ compiler that supports C++17 is not your default compiler, make sure you provide CMake with the compiler location with the DCMAKE_C_COMPILER and DCMAKE_CXX_COMPILER options. For instance: 1 cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" -DCMAKE_C_COMPILER = /usr/bin/gcc-8 -DCMAKE_CXX_COMPILER = /usr/bin/g++-8 Installing You can 1) use -DBUILD_EXAMPLES=OFF -DBUILD_TESTS=OFF to bypass the examples and tests, and then 2) cmake --install . to install Matplot++ on your system: Ubuntu + GCC 1 2 3 4 5 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF sudo cmake --build . --parallel 2 --config Release sudo cmake --install . Mac Os + Clang 1 2 3 4 5 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"-O2\" -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF cmake --build . --parallel 2 --config Release cmake --install . Windows + MSVC 1 2 3 4 5 mkdir build cd build cmake .. -DCMAKE_BUILD_TYPE = Release -DCMAKE_CXX_FLAGS = \"/O2\" -DBUILD_EXAMPLES = OFF -DBUILD_TESTS = OFF cmake --build . --parallel 2 --config Release cmake --install . Parallel Build Replace --parallel 2 with --parallel <number of cores in your machine> Create packages You can also create the binary packages to install Matplot++ on other systems: Ubuntu + GCC 1 sudo cpack . Mac Os + Clang 1 cpack . Windows + MSVC 1 cpack .","title":"Build and install"},{"location":"integration/install/build-from-source/dependencies/","text":"Dependencies C++17 Make sure your C++ compiler supports C++17: Ubuntu + GCC 1 g++ --version Mac Os + Clang 1 clang --version Windows + MSVC Visit the Visual Studio website Download Git from https://git-scm.com/download/win and install it The output should be something like: Ubuntu + GCC 1 g++-8 (Ubuntu 8.4.0-1ubuntu1~18.04) 8.4.0 Mac Os + Clang 1 Apple clang version 11.0.0 (clang-1100.0.33.8) Windows + MSVC Visit the Visual Studio website Download Git from https://git-scm.com/download/win and install it If you need to update your compiler: Ubuntu + GCC 1 2 3 4 # install GCC-8 sudo apt update sudo apt install gcc-8 sudo apt install g++-8 To update to any other version, like GCC-9 or GCC-10: 1 2 3 4 sudo apt install build-essential sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt install g++-10 Once you installed a newer version of GCC, you can link it to update-alternatives . For instance, if you have GCC-7 and GCC-10, you can link them with: 1 2 3 4 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 7 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 7 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 10 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-10 10 You can now use update-alternatives to set your default gcc and g++ to a more recent version: 1 2 update-alternatives --config g++ update-alternatives --config gcc Mac Os + Clang 1 2 3 4 5 6 7 8 9 10 11 # download clang curl --output clang.tar.xz -L https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/clang+llvm-11.0.0-x86_64-apple-darwin.tar.xz mkdir clang tar -xvJf clang.tar.xz -C clang # copy files to /usr/local cd clang/clang+llvm-11.0.0-x86_64-apple-darwin sudo cp -R * /usr/local/ # update default compiler export CXX = /usr/local/bin/clang++ Windows + MSVC Visit the Visual Studio website Download Git from https://git-scm.com/download/win and install it CMake 3.14+ Also check your CMake version is at least 3.14+: Ubuntu + GCC 1 cmake --version Mac Os + Clang 1 cmake --version Windows + MSVC 1 cmake --version If CMake is not installed or its version is older than CMake 3.14, update it with Ubuntu + GCC 1 sudo apt upgrade cmake Alternatively, download the most recent version from cmake.org . Mac Os + Clang 1 sudo brew upgrade cmake Homebrew If this command fails because you don't have Homebrew on your computer, you can install it with 1 /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \" or you can follow the instructions in https://brew.sh . Alternatively, download the most recent version from cmake.org . Windows + MSVC Download the most recent version from cmake.org . Gnuplot 5.2.6+ Install Gnuplot 5.2.6+ (Required at runtime) Ubuntu + GCC 1 2 sudo apt update sudo apt install gnuplot Or download the latest version from www.gnuplot.info . If you're using an installer, make sure you mark the option \"Add application directory to your PATH environment variable\". Mac Os + Clang 1 sudo brew install gnuplot Or download the latest version from www.gnuplot.info . If you're using an installer, make sure you mark the option \"Add application directory to your PATH environment variable\". Windows + MSVC Download Gnuplot from www.gnuplot.info and install it. If you're using the Gnuplot installer, make sure you mark the option \"Add application directory to your PATH environment variable\" Windows Gnuplot Terminals If the Matplot++ examples don't display without console errors and gnuplot running, try to re-install Gnuplot with the wxt terminal. Optional Dependencies The build script will also look for these optional dependencies for manipulating images: JPEG TIFF ZLIB PNG LAPACK BLAS FFTW OpenCV Embedded dependencies There are two dependencies in source/3rd_party . These dependencies are bundled, so you don't have to worry about them: olvb/nodesoup dtschump/CImg You can define WITH_SYSTEM_NODESOUP=ON or WITH_SYSTEM_CIMG=ON in the cmake command line to use a system-provided version of these dependencies. OpenGL dependencies There's an extra target matplot_opengl with the experimental OpenGL backend . You need to define BUILD_EXPERIMENTAL_OPENGL_BACKEND=ON in the CMake command line to build that target. In that case, the build script will also look for these extra dependencies: OpenGL GLAD GLFW3 If these dependencies are not found, the build script will download them. In any case, you can install these dependencies with: Ubuntu + GCC 1 sudo apt-get install libglfw3-dev Mac Os + Clang Download GLFW3 from https://www.glfw.org Windows + MSVC Download GLFW3 from https://www.glfw.org You can also see all dependencies in source/3rd_party/CMakeLists.txt .","title":"Dependencies"},{"location":"integration/install/build-from-source/dependencies/#dependencies","text":"C++17 Make sure your C++ compiler supports C++17: Ubuntu + GCC 1 g++ --version Mac Os + Clang 1 clang --version Windows + MSVC Visit the Visual Studio website Download Git from https://git-scm.com/download/win and install it The output should be something like: Ubuntu + GCC 1 g++-8 (Ubuntu 8.4.0-1ubuntu1~18.04) 8.4.0 Mac Os + Clang 1 Apple clang version 11.0.0 (clang-1100.0.33.8) Windows + MSVC Visit the Visual Studio website Download Git from https://git-scm.com/download/win and install it If you need to update your compiler: Ubuntu + GCC 1 2 3 4 # install GCC-8 sudo apt update sudo apt install gcc-8 sudo apt install g++-8 To update to any other version, like GCC-9 or GCC-10: 1 2 3 4 sudo apt install build-essential sudo add-apt-repository ppa:ubuntu-toolchain-r/test sudo apt-get update sudo apt install g++-10 Once you installed a newer version of GCC, you can link it to update-alternatives . For instance, if you have GCC-7 and GCC-10, you can link them with: 1 2 3 4 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 7 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 7 sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 10 sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-10 10 You can now use update-alternatives to set your default gcc and g++ to a more recent version: 1 2 update-alternatives --config g++ update-alternatives --config gcc Mac Os + Clang 1 2 3 4 5 6 7 8 9 10 11 # download clang curl --output clang.tar.xz -L https://github.com/llvm/llvm-project/releases/download/llvmorg-11.0.0/clang+llvm-11.0.0-x86_64-apple-darwin.tar.xz mkdir clang tar -xvJf clang.tar.xz -C clang # copy files to /usr/local cd clang/clang+llvm-11.0.0-x86_64-apple-darwin sudo cp -R * /usr/local/ # update default compiler export CXX = /usr/local/bin/clang++ Windows + MSVC Visit the Visual Studio website Download Git from https://git-scm.com/download/win and install it CMake 3.14+ Also check your CMake version is at least 3.14+: Ubuntu + GCC 1 cmake --version Mac Os + Clang 1 cmake --version Windows + MSVC 1 cmake --version If CMake is not installed or its version is older than CMake 3.14, update it with Ubuntu + GCC 1 sudo apt upgrade cmake Alternatively, download the most recent version from cmake.org . Mac Os + Clang 1 sudo brew upgrade cmake Homebrew If this command fails because you don't have Homebrew on your computer, you can install it with 1 /bin/bash -c \" $( curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh ) \" or you can follow the instructions in https://brew.sh . Alternatively, download the most recent version from cmake.org . Windows + MSVC Download the most recent version from cmake.org . Gnuplot 5.2.6+ Install Gnuplot 5.2.6+ (Required at runtime) Ubuntu + GCC 1 2 sudo apt update sudo apt install gnuplot Or download the latest version from www.gnuplot.info . If you're using an installer, make sure you mark the option \"Add application directory to your PATH environment variable\". Mac Os + Clang 1 sudo brew install gnuplot Or download the latest version from www.gnuplot.info . If you're using an installer, make sure you mark the option \"Add application directory to your PATH environment variable\". Windows + MSVC Download Gnuplot from www.gnuplot.info and install it. If you're using the Gnuplot installer, make sure you mark the option \"Add application directory to your PATH environment variable\" Windows Gnuplot Terminals If the Matplot++ examples don't display without console errors and gnuplot running, try to re-install Gnuplot with the wxt terminal. Optional Dependencies The build script will also look for these optional dependencies for manipulating images: JPEG TIFF ZLIB PNG LAPACK BLAS FFTW OpenCV Embedded dependencies There are two dependencies in source/3rd_party . These dependencies are bundled, so you don't have to worry about them: olvb/nodesoup dtschump/CImg You can define WITH_SYSTEM_NODESOUP=ON or WITH_SYSTEM_CIMG=ON in the cmake command line to use a system-provided version of these dependencies. OpenGL dependencies There's an extra target matplot_opengl with the experimental OpenGL backend . You need to define BUILD_EXPERIMENTAL_OPENGL_BACKEND=ON in the CMake command line to build that target. In that case, the build script will also look for these extra dependencies: OpenGL GLAD GLFW3 If these dependencies are not found, the build script will download them. In any case, you can install these dependencies with: Ubuntu + GCC 1 sudo apt-get install libglfw3-dev Mac Os + Clang Download GLFW3 from https://www.glfw.org Windows + MSVC Download GLFW3 from https://www.glfw.org You can also see all dependencies in source/3rd_party/CMakeLists.txt .","title":"Dependencies"},{"location":"integration/install/package-managers/arch-linux/","text":"Arch Linux Matplot++ is available in the Arch User Repository ( AUR ) as matplotplusplus . Note you can manually install the package by following the instructions on the Arch Wiki or use an AUR helper like yay (recommended for ease of install). 1 yay -S matplotplusplus To discuss any issues related to this package refer to the comments section on the AUR page of matplotplusplus here .","title":"Arch Linux"},{"location":"integration/install/package-managers/arch-linux/#arch-linux","text":"Matplot++ is available in the Arch User Repository ( AUR ) as matplotplusplus . Note you can manually install the package by following the instructions on the Arch Wiki or use an AUR helper like yay (recommended for ease of install). 1 yay -S matplotplusplus To discuss any issues related to this package refer to the comments section on the AUR page of matplotplusplus here .","title":"Arch Linux"},{"location":"integration/install/package-managers/homebrew/","text":"Homebrew Mac users can install Matplot++ with Homebrew : 1 brew install matplotplusplus This formula is a contribution to Homebrew by Andrew Kane .","title":"Homebrew"},{"location":"integration/install/package-managers/homebrew/#homebrew","text":"Mac users can install Matplot++ with Homebrew : 1 brew install matplotplusplus This formula is a contribution to Homebrew by Andrew Kane .","title":"Homebrew"},{"location":"plot-types/contour-plots/contour/","text":"Contour 1 contour ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; vector_1d x = linspace ( -2 * pi , 2 * pi ); vector_1d y = linspace ( 0 , 4 * pi ); auto [ X , Y ] = meshgrid ( x , y ); vector_2d Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); contour ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contour ( X , Y , Z , 20 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contour ( X , Y , Z , std :: vector < double > { 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contour ( X , Y , Z , \"--\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d x = iota ( -3 , 0.2 , 3 ); vector_1d y = iota ( -3 , 0.2 , 3 ); auto [ X , Y ] = meshgrid ( x , y ); vector_2d Z = transform ( X , Y , []( double x , double y ) { return x * exp ( - pow ( x , 2. ) - pow ( y , 2. )); }); contour ( X , Y , Z ) -> contour_text ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contour ( X , Y , Z ) -> line_width ( 3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); auto c = contour ( X , Y , Z ); c -> contour_text ( true ); c -> font_size ( 15 ); c -> font_color ( \"blue\" ); c -> font_weight ( \"bold\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); for ( size_t i = 0 ; i < Z . size (); ++ i ) { Z [ i ][ 25 ] = NaN ; } contour ( X , Y , Z ) -> contour_text ( true ); show (); return 0 ; } All these subcategories depend on the contours type. They also depend on lazy evaluation for generating the contour lines. When the function draw is called in the contours class, it preprocesses all contour lines for a three-dimensional function. Although it is relatively simple to show a heatmap with the values for the -axis, calculating contour lines relative to the -axis is more complex than it might seem at first. We provide the function contourc for calculating contour lines. This function uses an adaptation of the algorithm adopted by Matplotlib. The algorithm creates a quad grid defined by the and values. It uses this grid to infer a contour line passing through positions with the same value. The algorithm sweeps through the grid twice to generate these lines. The first sweep looks for lines that start on the boundaries. The second sweep looks for interior closed loops. Filled contours are closed polygons for pairs of contour levels. Some polygons for filled contours might be holes inside other polygons. The algorithm needs to keep track of these relationships so that we can render the polygons in their accurate order. To avoid an extra step that identifies this relationship between the polygons, the sweeping algorithm already identifies which polygons are holes for each level. Once we find the quads with the contour line, the line is generated by interpolating the values around that quad.","title":"Contour"},{"location":"plot-types/contour-plots/contour/#contour","text":"1 contour ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; vector_1d x = linspace ( -2 * pi , 2 * pi ); vector_1d y = linspace ( 0 , 4 * pi ); auto [ X , Y ] = meshgrid ( x , y ); vector_2d Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); contour ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contour ( X , Y , Z , 20 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contour ( X , Y , Z , std :: vector < double > { 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contour ( X , Y , Z , \"--\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; vector_1d x = iota ( -3 , 0.2 , 3 ); vector_1d y = iota ( -3 , 0.2 , 3 ); auto [ X , Y ] = meshgrid ( x , y ); vector_2d Z = transform ( X , Y , []( double x , double y ) { return x * exp ( - pow ( x , 2. ) - pow ( y , 2. )); }); contour ( X , Y , Z ) -> contour_text ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contour ( X , Y , Z ) -> line_width ( 3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); auto c = contour ( X , Y , Z ); c -> contour_text ( true ); c -> font_size ( 15 ); c -> font_color ( \"blue\" ); c -> font_weight ( \"bold\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); for ( size_t i = 0 ; i < Z . size (); ++ i ) { Z [ i ][ 25 ] = NaN ; } contour ( X , Y , Z ) -> contour_text ( true ); show (); return 0 ; } All these subcategories depend on the contours type. They also depend on lazy evaluation for generating the contour lines. When the function draw is called in the contours class, it preprocesses all contour lines for a three-dimensional function. Although it is relatively simple to show a heatmap with the values for the -axis, calculating contour lines relative to the -axis is more complex than it might seem at first. We provide the function contourc for calculating contour lines. This function uses an adaptation of the algorithm adopted by Matplotlib. The algorithm creates a quad grid defined by the and values. It uses this grid to infer a contour line passing through positions with the same value. The algorithm sweeps through the grid twice to generate these lines. The first sweep looks for lines that start on the boundaries. The second sweep looks for interior closed loops. Filled contours are closed polygons for pairs of contour levels. Some polygons for filled contours might be holes inside other polygons. The algorithm needs to keep track of these relationships so that we can render the polygons in their accurate order. To avoid an extra step that identifies this relationship between the polygons, the sweeping algorithm already identifies which polygons are holes for each level. Once we find the quads with the contour line, the line is generated by interpolating the values around that quad.","title":"Contour"},{"location":"plot-types/contour-plots/filled-contour/","text":"Filled Contour 1 contourf ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -2 * pi , 2 * pi ); std :: vector < double > y = linspace ( 0 , 4 * pi ); auto [ X , Y ] = meshgrid ( x , y ); vector_2d Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); contourf ( X , Y , Z , 10 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z , { 2 , 3 }) -> contour_text ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z , { 2 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z , \"--\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z ) -> line_width ( 3 ); show (); return 0 ; }","title":"Filled Contour"},{"location":"plot-types/contour-plots/filled-contour/#filled-contour","text":"1 contourf ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -2 * pi , 2 * pi ); std :: vector < double > y = linspace ( 0 , 4 * pi ); auto [ X , Y ] = meshgrid ( x , y ); vector_2d Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); contourf ( X , Y , Z , 10 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z , { 2 , 3 }) -> contour_text ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z , { 2 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z , \"--\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); contourf ( X , Y , Z ) -> line_width ( 3 ); show (); return 0 ; }","title":"Filled Contour"},{"location":"plot-types/contour-plots/function-contour/","text":"Function Contour 1 fcontour ( f ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = []( double x , double y ) { return sin ( x ) + cos ( y ); }; fcontour ( f ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; fcontour ([]( double x , double y ) { return erf ( x ) + cos ( y ); }, { -5 , 0 , -5 , + 5 }, iota ( -2 , 0.5 , 2 )); hold ( on ); fcontour ([]( double x , double y ) { return sin ( x ) + cos ( y ); }, { 0 , 5 , -5 , + 5 }, iota ( -2 , 0.5 , 2 )); hold ( off ); axis ({ -5 , + 5 , -5 , + 5 }); grid ( on ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = []( double x , double y ) { return pow ( x , 2 ) - pow ( y , 2 ); }; fcontour ( f , \"--\" ) -> line_width ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; fcontour ([]( double x , double y ) { return sin ( x ) + cos ( y ); }); hold ( on ); fcontour ([]( double x , double y ) { return x - y ; }); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = []( double x , double y ) { return exp ( - pow ( x / 3 , 2 ) - pow ( y / 3 , 2 )) + exp ( - pow ( x + 2 , 2 ) - pow ( y + 2 , 2 )); }; fcontour ( f ) -> line_width ( 1 ). line_style ( \"--\" ). levels ({ 1 , 0.9 , 0.8 , 0.2 , 0.1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = []( double x , double y ) { return erf ( pow ( y + 2 , 3 )) - exp ( -0.65 * ( pow ( x - 2 , 2 ) + pow ( y - 2 , 2 ))); }; fcontour ( f ) -> filled ( true ). colormap_line_when_filled ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = []( double x , double y ) { return erf ( pow ( y + 2 , 3 )) - exp ( -0.65 * ( pow ( x - 2 , 2 ) + pow ( y - 2 , 2 ))); }; fcontour ( f , 25 ) -> filled ( true ). colormap_line_when_filled ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; fcontour ([]( double x , double y ) { return sin ( x ) + cos ( y ); }) -> levels ({ -1 , 0 , + 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto rastrigin = []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }; fcontour ( rastrigin ) -> filled ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ackley = []( double x , double y ) { return -20 * exp ( -0.2 * sqrt ( 0.5 * ( pow ( x , 2 ) + pow ( y , 2 )))) - exp ( 0.5 * ( cos ( 2 * pi * x ) + cos ( 2 * pi * y ))) + exp ( 1 ) + 20 ; }; fcontour ( ackley ) -> n_levels ( 50 ). filled ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto rosenbrock = []( double x , double y ) { return 100 * pow ( y - pow ( x , 2. ), 2. ) + pow ( 1. - x , 2. ); }; fcontour ( rosenbrock ) -> n_levels ( 10 ). filled ( true ); show (); return 0 ; } By default, the function fcontour will generate 9 contour lines from a lambda function. The functions contour and contourf , on the other hand, plot contour lines and filled contour lines from a grid of data points for , , and .","title":"Function Contour"},{"location":"plot-types/contour-plots/function-contour/#function-contour","text":"1 fcontour ( f ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = []( double x , double y ) { return sin ( x ) + cos ( y ); }; fcontour ( f ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; fcontour ([]( double x , double y ) { return erf ( x ) + cos ( y ); }, { -5 , 0 , -5 , + 5 }, iota ( -2 , 0.5 , 2 )); hold ( on ); fcontour ([]( double x , double y ) { return sin ( x ) + cos ( y ); }, { 0 , 5 , -5 , + 5 }, iota ( -2 , 0.5 , 2 )); hold ( off ); axis ({ -5 , + 5 , -5 , + 5 }); grid ( on ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = []( double x , double y ) { return pow ( x , 2 ) - pow ( y , 2 ); }; fcontour ( f , \"--\" ) -> line_width ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; fcontour ([]( double x , double y ) { return sin ( x ) + cos ( y ); }); hold ( on ); fcontour ([]( double x , double y ) { return x - y ; }); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = []( double x , double y ) { return exp ( - pow ( x / 3 , 2 ) - pow ( y / 3 , 2 )) + exp ( - pow ( x + 2 , 2 ) - pow ( y + 2 , 2 )); }; fcontour ( f ) -> line_width ( 1 ). line_style ( \"--\" ). levels ({ 1 , 0.9 , 0.8 , 0.2 , 0.1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = []( double x , double y ) { return erf ( pow ( y + 2 , 3 )) - exp ( -0.65 * ( pow ( x - 2 , 2 ) + pow ( y - 2 , 2 ))); }; fcontour ( f ) -> filled ( true ). colormap_line_when_filled ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto f = []( double x , double y ) { return erf ( pow ( y + 2 , 3 )) - exp ( -0.65 * ( pow ( x - 2 , 2 ) + pow ( y - 2 , 2 ))); }; fcontour ( f , 25 ) -> filled ( true ). colormap_line_when_filled ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; fcontour ([]( double x , double y ) { return sin ( x ) + cos ( y ); }) -> levels ({ -1 , 0 , + 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto rastrigin = []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }; fcontour ( rastrigin ) -> filled ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; auto ackley = []( double x , double y ) { return -20 * exp ( -0.2 * sqrt ( 0.5 * ( pow ( x , 2 ) + pow ( y , 2 )))) - exp ( 0.5 * ( cos ( 2 * pi * x ) + cos ( 2 * pi * y ))) + exp ( 1 ) + 20 ; }; fcontour ( ackley ) -> n_levels ( 50 ). filled ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto rosenbrock = []( double x , double y ) { return 100 * pow ( y - pow ( x , 2. ), 2. ) + pow ( 1. - x , 2. ); }; fcontour ( rosenbrock ) -> n_levels ( 10 ). filled ( true ); show (); return 0 ; } By default, the function fcontour will generate 9 contour lines from a lambda function. The functions contour and contourf , on the other hand, plot contour lines and filled contour lines from a grid of data points for , , and .","title":"Function Contour"},{"location":"plot-types/data-distribution/binned-scatter-plots/","text":"Binned Scatter Plots 1 binscatter ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto f = figure (); f -> width ( f -> width () * 2 ); auto x_reduced = randn ( 1000 , 0 , 1 ); auto y_reduced = transform ( x_reduced , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); auto ax1 = subplot ( 1 , 2 , 0 ); scatter ( ax1 , x_reduced , y_reduced ); title ( ax1 , \"Scatter plot (n=1000)\" ); auto x = randn ( 1000000 , 0. , 1. ); auto y = transform ( x , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); auto ax2 = subplot ( 1 , 2 , 1 ); binscatter ( ax2 , x , y ); axis ( tight ); title ( ax2 , \"Binned Scatter plot (n=1000000)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 2 ); f -> height ( f -> height () * 2 ); f -> x_position ( 200 ); f -> y_position ( 100 ); auto x = randn ( 1000000 , 0. , 1. ); auto y = transform ( x , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); std :: vector < double > x_line ( x . begin (), x . begin () + 1000 ); std :: vector < double > y_line ( y . begin (), y . begin () + 1000 ); subplot ( 2 , 3 , 0 ); scatter ( x_line , y_line ); title ( \"Scatter\" ); subplot ( 2 , 3 , 1 ); binscatter ( x , y , bin_scatter_style :: point_size ); title ( \"Bin Scatter: Point size\" ); subplot ( 2 , 3 , 2 ); binscatter ( x , y , bin_scatter_style :: point_alpha ); title ( \"Bin Scatter: Point alpha\" ); subplot ( 2 , 3 , 3 ); binscatter ( x , y , bin_scatter_style :: point_colormap ); title ( \"Bin Scatter: Colormap\" ); subplot ( 2 , 3 , 4 ); binscatter ( x , y , bin_scatter_style :: heatmap ); axis ( tight ); title ( \"Bin Scatter: Heatmap\" ); subplot ( 2 , 3 , 5 ); binscatter ( x , y , bin_scatter_style :: jitter ); title ( \"Bin Scatter: Jitter\" ); f -> show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 2 ); f -> height ( f -> height () * 2 ); f -> x_position ( 200 ); f -> y_position ( 100 ); auto x = randn ( 1000000 , 0. , 1. ); auto y = transform ( x , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); bin_scatter_style b = bin_scatter_style :: automatic ; subplot ( 2 , 3 , 0 ); binscatter ( x , y , histogram :: binning_algorithm :: automatic , b ); axis ( tight ); title ( \"Automatic\" ); subplot ( 2 , 3 , 1 ); binscatter ( x , y , histogram :: binning_algorithm :: integers , b ); axis ( tight ); title ( \"Integers\" ); subplot ( 2 , 3 , 2 ); binscatter ( x , y , histogram :: binning_algorithm :: scott , b ); axis ( tight ); title ( \"Scott's rule\" ); subplot ( 2 , 3 , 3 ); binscatter ( x , y , histogram :: binning_algorithm :: fd , b ); axis ( tight ); title ( \"Freedman-Diaconis rule\" ); subplot ( 2 , 3 , 4 ); binscatter ( x , y , histogram :: binning_algorithm :: sqrt , b ); axis ( tight ); title ( \"Square root rule\" ); subplot ( 2 , 3 , 5 ); binscatter ( x , y , histogram :: binning_algorithm :: sturges , b ); axis ( tight ); title ( \"Sturges' rule\" ); f -> show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 2 ); f -> height ( f -> height () * 2 ); f -> x_position ( 200 ); f -> y_position ( 100 ); auto x = randn ( 1000000 , 0. , 1. ); auto y = transform ( x , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); bin_scatter_style b = bin_scatter_style :: heatmap ; histogram :: binning_algorithm a = histogram :: binning_algorithm :: automatic ; subplot ( 2 , 3 , 0 ); binscatter ( x , y , a , b , histogram :: normalization :: count ); axis ( tight ); title ( \"Normalization: Count\" ); subplot ( 2 , 3 , 1 ); binscatter ( x , y , a , b , histogram :: normalization :: probability ); axis ( tight ); title ( \"Normalization: Probability\" ); subplot ( 2 , 3 , 2 ); binscatter ( x , y , a , b , histogram :: normalization :: cummulative_count ); axis ( tight ); title ( \"Normalization: Cummulative count\" ); subplot ( 2 , 3 , 3 ); binscatter ( x , y , a , b , histogram :: normalization :: count_density ); axis ( tight ); title ( \"Normalization: Count density\" ); subplot ( 2 , 3 , 4 ); binscatter ( x , y , a , b , histogram :: normalization :: pdf ); axis ( tight ); title ( \"Normalization: PDF\" ); subplot ( 2 , 3 , 5 ); binscatter ( x , y , a , b , histogram :: normalization :: cdf ); axis ( tight ); title ( \"Normalization: CDF\" ); f -> show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 2 ); f -> height ( f -> height () * 2 ); f -> x_position ( 200 ); f -> y_position ( 100 ); f -> quiet_mode ( true ); auto x = randn ( 10000 , 0. , 1. ); auto y = randn ( 10000 , 0. , 1. ); subplot ( 2 , 3 , 0 ); scatter ( x , y ); title ( \"Scatter plot\" ); subplot ( 2 , 3 , 1 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: point_size ); title ( \"Binned scatter plot: Point size\" ); subplot ( 2 , 3 , 2 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: point_alpha ); title ( \"Binned scatter plot: Point alpha\" ); subplot ( 2 , 3 , 3 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: jitter ); title ( \"Binned scatter plot: Jitter\" ); subplot ( 2 , 3 , 4 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: point_colormap ); title ( \"Binned scatter plot: Colormap\" ); subplot ( 2 , 3 , 5 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: heatmap ); title ( \"Binned scatter plot: Heatmap\" ); axis ( tight ); f -> draw (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto x = randn ( 100000 , 0. , 1. ); auto y = randn ( 100000 , 0. , 1. ); binscatter ( x , y , bin_scatter_style :: point_colormap ); colormap ( gca (), palette :: parula ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto x = randn ( 100000 , 0. , 1. ); auto y = randn ( 100000 , 0. , 1. ); binscatter ( x , y , 20 , 30 , bin_scatter_style :: heatmap ); axis ( tight ); show (); return 0 ; } Binned scatter plots use variations of the histogram algorithms of the previous section as an extra step to place all the data into two-dimensional bins that can be represented with varying colors or sizes. This is useful when there are so many data points that a scatter plot would be impractical for visualizing the data.","title":"Binned Scatter Plots"},{"location":"plot-types/data-distribution/binned-scatter-plots/#binned-scatter-plots","text":"1 binscatter ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto f = figure (); f -> width ( f -> width () * 2 ); auto x_reduced = randn ( 1000 , 0 , 1 ); auto y_reduced = transform ( x_reduced , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); auto ax1 = subplot ( 1 , 2 , 0 ); scatter ( ax1 , x_reduced , y_reduced ); title ( ax1 , \"Scatter plot (n=1000)\" ); auto x = randn ( 1000000 , 0. , 1. ); auto y = transform ( x , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); auto ax2 = subplot ( 1 , 2 , 1 ); binscatter ( ax2 , x , y ); axis ( tight ); title ( ax2 , \"Binned Scatter plot (n=1000000)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 2 ); f -> height ( f -> height () * 2 ); f -> x_position ( 200 ); f -> y_position ( 100 ); auto x = randn ( 1000000 , 0. , 1. ); auto y = transform ( x , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); std :: vector < double > x_line ( x . begin (), x . begin () + 1000 ); std :: vector < double > y_line ( y . begin (), y . begin () + 1000 ); subplot ( 2 , 3 , 0 ); scatter ( x_line , y_line ); title ( \"Scatter\" ); subplot ( 2 , 3 , 1 ); binscatter ( x , y , bin_scatter_style :: point_size ); title ( \"Bin Scatter: Point size\" ); subplot ( 2 , 3 , 2 ); binscatter ( x , y , bin_scatter_style :: point_alpha ); title ( \"Bin Scatter: Point alpha\" ); subplot ( 2 , 3 , 3 ); binscatter ( x , y , bin_scatter_style :: point_colormap ); title ( \"Bin Scatter: Colormap\" ); subplot ( 2 , 3 , 4 ); binscatter ( x , y , bin_scatter_style :: heatmap ); axis ( tight ); title ( \"Bin Scatter: Heatmap\" ); subplot ( 2 , 3 , 5 ); binscatter ( x , y , bin_scatter_style :: jitter ); title ( \"Bin Scatter: Jitter\" ); f -> show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 2 ); f -> height ( f -> height () * 2 ); f -> x_position ( 200 ); f -> y_position ( 100 ); auto x = randn ( 1000000 , 0. , 1. ); auto y = transform ( x , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); bin_scatter_style b = bin_scatter_style :: automatic ; subplot ( 2 , 3 , 0 ); binscatter ( x , y , histogram :: binning_algorithm :: automatic , b ); axis ( tight ); title ( \"Automatic\" ); subplot ( 2 , 3 , 1 ); binscatter ( x , y , histogram :: binning_algorithm :: integers , b ); axis ( tight ); title ( \"Integers\" ); subplot ( 2 , 3 , 2 ); binscatter ( x , y , histogram :: binning_algorithm :: scott , b ); axis ( tight ); title ( \"Scott's rule\" ); subplot ( 2 , 3 , 3 ); binscatter ( x , y , histogram :: binning_algorithm :: fd , b ); axis ( tight ); title ( \"Freedman-Diaconis rule\" ); subplot ( 2 , 3 , 4 ); binscatter ( x , y , histogram :: binning_algorithm :: sqrt , b ); axis ( tight ); title ( \"Square root rule\" ); subplot ( 2 , 3 , 5 ); binscatter ( x , y , histogram :: binning_algorithm :: sturges , b ); axis ( tight ); title ( \"Sturges' rule\" ); f -> show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 2 ); f -> height ( f -> height () * 2 ); f -> x_position ( 200 ); f -> y_position ( 100 ); auto x = randn ( 1000000 , 0. , 1. ); auto y = transform ( x , []( double x ) { return 2 * x + randn ( 0 , 1 ); }); bin_scatter_style b = bin_scatter_style :: heatmap ; histogram :: binning_algorithm a = histogram :: binning_algorithm :: automatic ; subplot ( 2 , 3 , 0 ); binscatter ( x , y , a , b , histogram :: normalization :: count ); axis ( tight ); title ( \"Normalization: Count\" ); subplot ( 2 , 3 , 1 ); binscatter ( x , y , a , b , histogram :: normalization :: probability ); axis ( tight ); title ( \"Normalization: Probability\" ); subplot ( 2 , 3 , 2 ); binscatter ( x , y , a , b , histogram :: normalization :: cummulative_count ); axis ( tight ); title ( \"Normalization: Cummulative count\" ); subplot ( 2 , 3 , 3 ); binscatter ( x , y , a , b , histogram :: normalization :: count_density ); axis ( tight ); title ( \"Normalization: Count density\" ); subplot ( 2 , 3 , 4 ); binscatter ( x , y , a , b , histogram :: normalization :: pdf ); axis ( tight ); title ( \"Normalization: PDF\" ); subplot ( 2 , 3 , 5 ); binscatter ( x , y , a , b , histogram :: normalization :: cdf ); axis ( tight ); title ( \"Normalization: CDF\" ); f -> show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 2 ); f -> height ( f -> height () * 2 ); f -> x_position ( 200 ); f -> y_position ( 100 ); f -> quiet_mode ( true ); auto x = randn ( 10000 , 0. , 1. ); auto y = randn ( 10000 , 0. , 1. ); subplot ( 2 , 3 , 0 ); scatter ( x , y ); title ( \"Scatter plot\" ); subplot ( 2 , 3 , 1 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: point_size ); title ( \"Binned scatter plot: Point size\" ); subplot ( 2 , 3 , 2 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: point_alpha ); title ( \"Binned scatter plot: Point alpha\" ); subplot ( 2 , 3 , 3 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: jitter ); title ( \"Binned scatter plot: Jitter\" ); subplot ( 2 , 3 , 4 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: point_colormap ); title ( \"Binned scatter plot: Colormap\" ); subplot ( 2 , 3 , 5 ); binscatter ( x , y , 30 , 10 , bin_scatter_style :: heatmap ); title ( \"Binned scatter plot: Heatmap\" ); axis ( tight ); f -> draw (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto x = randn ( 100000 , 0. , 1. ); auto y = randn ( 100000 , 0. , 1. ); binscatter ( x , y , bin_scatter_style :: point_colormap ); colormap ( gca (), palette :: parula ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto x = randn ( 100000 , 0. , 1. ); auto y = randn ( 100000 , 0. , 1. ); binscatter ( x , y , 20 , 30 , bin_scatter_style :: heatmap ); axis ( tight ); show (); return 0 ; } Binned scatter plots use variations of the histogram algorithms of the previous section as an extra step to place all the data into two-dimensional bins that can be represented with varying colors or sizes. This is useful when there are so many data points that a scatter plot would be impractical for visualizing the data.","title":"Binned Scatter Plots"},{"location":"plot-types/data-distribution/boxplot/","text":"Boxplot 1 boxplot ( data ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > mpg = { 18 , 15 , 18 , 16 , 17 , 15 , 14 , 14 , 14 , 15 , 15 , 14 , 15 , 14 , 24 , 22 , 18 , 21 , 27 , 26 , 25 , 24 , 25 , 26 , 21 , 10 , 10 , 11 , 9 , 28 , 25 , 25 , 26 , 27 , 17.5 , 16 , 15.5 , 14.5 , 22 , 22 , 24 , 22.5 , 29 , 24.5 , 29 , 33 , 20 , 18 , 18.5 , 17.5 , 29.5 , 32 , 28 , 26.5 , 20 , 13 , 19 , 19 , 16.5 , 16.5 , 13 , 13 , 13 , 28 , 27 , 34 , 31 , 29 , 27 , 24 , 23 , 36 , 37 , 31 , 38 , 36 , 36 , 36 , 34 , 38 , 32 , 38 , 25 , 38 , 26 , 22 , 32 , 36 , 27 , 27 , 44 , 32 , 28 , 31 }; boxplot ( mpg ); xlabel ( \"All Vehicles\" ); ylabel ( \"Miles per Gallon (MPG)\" ); title ( \"Miles per Gallon for All Vehicles\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > mpg = { 18 , 15 , 18 , 16 , 17 , 15 , 14 , 14 , 14 , 15 , 15 , 14 , 15 , 14 , 24 , 22 , 18 , 21 , 27 , 26 , 25 , 24 , 25 , 26 , 21 , 10 , 10 , 11 , 9 , 28 , 25 , 25 , 26 , 27 , 17.5 , 16 , 15.5 , 14.5 , 22 , 22 , 24 , 22.5 , 29 , 24.5 , 29 , 33 , 20 , 18 , 18.5 , 17.5 , 29.5 , 32 , 28 , 26.5 , 20 , 13 , 19 , 19 , 16.5 , 16.5 , 13 , 13 , 13 , 28 , 27 , 34 , 31 , 29 , 27 , 24 , 23 , 36 , 37 , 31 , 38 , 36 , 36 , 36 , 34 , 38 , 32 , 38 , 25 , 38 , 26 , 22 , 32 , 36 , 27 , 27 , 44 , 32 , 28 , 31 }; std :: vector < std :: string > origin = { \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Japan\" , \"USA\" , \"USA\" , \"USA\" , \"Japan\" , \"Germany\" , \"France\" , \"Germany\" , \"Sweden\" , \"Germany\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Italy\" , \"Germany\" , \"USA\" , \"USA\" , \"France\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Germany\" , \"Japan\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Germany\" , \"Japan\" , \"Japan\" , \"USA\" , \"Sweden\" , \"USA\" , \"France\" , \"Japan\" , \"Germany\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Germany\" , \"Japan\" , \"Japan\" , \"USA\" , \"USA\" , \"Japan\" , \"Japan\" , \"Japan\" , \"Japan\" , \"Japan\" , \"Japan\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Japan\" , \"USA\" , \"USA\" , \"USA\" , \"Germany\" , \"USA\" , \"USA\" , \"USA\" }; boxplot ( mpg , origin ); xlabel ( \"All Vehicles\" ); ylabel ( \"Miles per Gallon (MPG)\" ); title ( \"Miles per Gallon for All Vehicles\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> x ( 25 ); for ( auto & xi : x ) { xi = randn ( 100 , 0 , 1 ); } subplot ( 2 , 1 , 0 ); boxplot ( x ); subplot ( 2 , 1 , 1 ); boxplot ( x ) -> box_style ( box_chart :: box_style_option :: outline ); show (); return 0 ; }","title":"Boxplot"},{"location":"plot-types/data-distribution/boxplot/#boxplot","text":"1 boxplot ( data ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > mpg = { 18 , 15 , 18 , 16 , 17 , 15 , 14 , 14 , 14 , 15 , 15 , 14 , 15 , 14 , 24 , 22 , 18 , 21 , 27 , 26 , 25 , 24 , 25 , 26 , 21 , 10 , 10 , 11 , 9 , 28 , 25 , 25 , 26 , 27 , 17.5 , 16 , 15.5 , 14.5 , 22 , 22 , 24 , 22.5 , 29 , 24.5 , 29 , 33 , 20 , 18 , 18.5 , 17.5 , 29.5 , 32 , 28 , 26.5 , 20 , 13 , 19 , 19 , 16.5 , 16.5 , 13 , 13 , 13 , 28 , 27 , 34 , 31 , 29 , 27 , 24 , 23 , 36 , 37 , 31 , 38 , 36 , 36 , 36 , 34 , 38 , 32 , 38 , 25 , 38 , 26 , 22 , 32 , 36 , 27 , 27 , 44 , 32 , 28 , 31 }; boxplot ( mpg ); xlabel ( \"All Vehicles\" ); ylabel ( \"Miles per Gallon (MPG)\" ); title ( \"Miles per Gallon for All Vehicles\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > mpg = { 18 , 15 , 18 , 16 , 17 , 15 , 14 , 14 , 14 , 15 , 15 , 14 , 15 , 14 , 24 , 22 , 18 , 21 , 27 , 26 , 25 , 24 , 25 , 26 , 21 , 10 , 10 , 11 , 9 , 28 , 25 , 25 , 26 , 27 , 17.5 , 16 , 15.5 , 14.5 , 22 , 22 , 24 , 22.5 , 29 , 24.5 , 29 , 33 , 20 , 18 , 18.5 , 17.5 , 29.5 , 32 , 28 , 26.5 , 20 , 13 , 19 , 19 , 16.5 , 16.5 , 13 , 13 , 13 , 28 , 27 , 34 , 31 , 29 , 27 , 24 , 23 , 36 , 37 , 31 , 38 , 36 , 36 , 36 , 34 , 38 , 32 , 38 , 25 , 38 , 26 , 22 , 32 , 36 , 27 , 27 , 44 , 32 , 28 , 31 }; std :: vector < std :: string > origin = { \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Japan\" , \"USA\" , \"USA\" , \"USA\" , \"Japan\" , \"Germany\" , \"France\" , \"Germany\" , \"Sweden\" , \"Germany\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Italy\" , \"Germany\" , \"USA\" , \"USA\" , \"France\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Germany\" , \"Japan\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Germany\" , \"Japan\" , \"Japan\" , \"USA\" , \"Sweden\" , \"USA\" , \"France\" , \"Japan\" , \"Germany\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Germany\" , \"Japan\" , \"Japan\" , \"USA\" , \"USA\" , \"Japan\" , \"Japan\" , \"Japan\" , \"Japan\" , \"Japan\" , \"Japan\" , \"USA\" , \"USA\" , \"USA\" , \"USA\" , \"Japan\" , \"USA\" , \"USA\" , \"USA\" , \"Germany\" , \"USA\" , \"USA\" , \"USA\" }; boxplot ( mpg , origin ); xlabel ( \"All Vehicles\" ); ylabel ( \"Miles per Gallon (MPG)\" ); title ( \"Miles per Gallon for All Vehicles\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> x ( 25 ); for ( auto & xi : x ) { xi = randn ( 100 , 0 , 1 ); } subplot ( 2 , 1 , 0 ); boxplot ( x ); subplot ( 2 , 1 , 1 ); boxplot ( x ) -> box_style ( box_chart :: box_style_option :: outline ); show (); return 0 ; }","title":"Boxplot"},{"location":"plot-types/data-distribution/heatmap/","text":"Heatmap 1 heatmap ( data ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 45 , 60 , 32 }, { 43 , 54 , 76 }, { 32 , 94 , 68 }, { 23 , 95 , 58 }}; heatmap ( data ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 24 , 10 }, { 10 , 5 }, { 24 , 16 }, { 8 , 3 }}; heatmap ( data ); title ( \"Count of SelfAssessedHealthStatus vs. Smoker\" ); auto ax = gca (); ax -> x_axis (). ticklabels ({ \"false\" , \"true\" }); ax -> y_axis (). ticklabels ({ \"Excellent\" , \"Fair\" , \"Good\" , \"Poor\" }); xlabel ( ax , \"Smoker\" ); ylabel ( ax , \"SelfAssessedHealthStatus\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 38.46 , 39 }, { 39.7 , 36.2 }, { 38.13 , 38.88 }, { 33.88 , 43 }}; heatmap ( data ); title ( \"Mean of Age\" ); auto ax = gca (); ax -> x_axis (). ticklabels ({ \"false\" , \"true\" }); ax -> y_axis (). ticklabels ({ \"Excellent\" , \"Fair\" , \"Good\" , \"Poor\" }); xlabel ( ax , \"Smoker\" ); ylabel ( ax , \"SelfAssessedHealthStatus\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 45 , 60 , 32 }, { 43 , 54 , 76 }, { 32 , 94 , 68 }, { 23 , 95 , 58 }}; heatmap ( data ); title ( \"T-Shirt Orders\" ); auto ax = gca (); ax -> x_axis (). ticklabels ({ \"Small\" , \"Medium\" , \"Large\" }); ax -> y_axis (). ticklabels ({ \"Green\" , \"Red\" , \"Blue\" , \"Gray\" }); xlabel ( ax , \"Sizes\" ); ylabel ( ax , \"Colors\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 12 , 135 , 20 , 0 , 127 }, { 0 , 1 , 0 , 0 , 1 }, { 19 , 31 , 81 , 8 , 49 }, { 9 , 18 , 42 , 2 , 85 }, { 0 , 5 , 3 , 0 , 17 }, { 31 , 143 , 135 , 6 , 23 }, { 32 , 102 , 54 , 6 , 7 }, { 5 , 11 , 4 , 0 , 4 }, { 16 , 41 , 13 , 3 , 22 }, { 18 , 70 , 37 , 1 , 19 }}; heatmap ( data ); title ( \"Count of Cause vs. Region\" ); auto ax = gca (); ax -> x_axis (). ticklabels ( { \"MidWest\" , \"NorthEast\" , \"SouthEast\" , \"SouthWest\" , \"West\" }); ax -> y_axis (). ticklabels ( { \"Attack\" , \"Earthquake\" , \"Energy emergency\" , \"Equipment fault\" , \"Fire\" , \"Severe Storm\" , \"Thunder Storm\" , \"Unknown\" , \"Wind\" , \"Winter Storm\" }); xlabel ( ax , \"Region\" ); ylabel ( ax , \"Cause\" ); float w = ax -> width (); ax -> width ( w * 0.85f ); ax -> x_origin ( ax -> x_origin () + w * 0.1f ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 12 , 135 , 20 , 0 , 127 }, { 0 , 1 , 0 , 0 , 1 }, { 19 , 31 , 81 , 8 , 49 }, { 9 , 18 , 42 , 2 , 85 }, { 0 , 5 , 3 , 0 , 17 }, { 31 , 143 , 135 , 6 , 23 }, { 32 , 102 , 54 , 6 , 7 }, { 5 , 11 , 4 , 0 , 4 }, { 16 , 41 , 13 , 3 , 22 }, { 18 , 70 , 37 , 1 , 19 }}; heatmap ( data ) -> normalization ( matrix :: color_normalization :: columns ); title ( \"Count of Cause vs. Region\" ); auto ax = gca (); ax -> x_axis (). ticklabels ( { \"MidWest\" , \"NorthEast\" , \"SouthEast\" , \"SouthWest\" , \"West\" }); ax -> y_axis (). ticklabels ( { \"Attack\" , \"Earthquake\" , \"Energy emergency\" , \"Equipment fault\" , \"Fire\" , \"Severe Storm\" , \"Thunder Storm\" , \"Unknown\" , \"Wind\" , \"Winter Storm\" }); xlabel ( ax , \"Region\" ); ylabel ( ax , \"Cause\" ); float w = ax -> width (); ax -> width ( w * 0.85f ); ax -> x_origin ( ax -> x_origin () + w * 0.1f ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 12 , 135 , 20 , 0 , 127 }, { 0 , 1 , 0 , 0 , 1 }, { 19 , 31 , 81 , 8 , 49 }, { 9 , 18 , 42 , 2 , 85 }, { 0 , 5 , 3 , 0 , 17 }, { 31 , 143 , 135 , 6 , 23 }, { 32 , 102 , 54 , 6 , 7 }, { 5 , 11 , 4 , 0 , 4 }, { 16 , 41 , 13 , 3 , 22 }, { 18 , 70 , 37 , 1 , 19 }}; heatmap ( data ) -> normalization ( matrix :: color_normalization :: rows ); title ( \"Count of Cause vs. Region\" ); auto ax = gca (); ax -> x_axis (). ticklabels ( { \"MidWest\" , \"NorthEast\" , \"SouthEast\" , \"SouthWest\" , \"West\" }); ax -> y_axis (). ticklabels ( { \"Attack\" , \"Earthquake\" , \"Energy emergency\" , \"Equipment fault\" , \"Fire\" , \"Severe Storm\" , \"Thunder Storm\" , \"Unknown\" , \"Wind\" , \"Winter Storm\" }); xlabel ( ax , \"Region\" ); ylabel ( ax , \"Cause\" ); float w = ax -> width (); ax -> width ( w * 0.85f ); ax -> x_origin ( ax -> x_origin () + w * 0.1f ); show (); return 0 ; }","title":"Heatmap"},{"location":"plot-types/data-distribution/heatmap/#heatmap","text":"1 heatmap ( data ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 45 , 60 , 32 }, { 43 , 54 , 76 }, { 32 , 94 , 68 }, { 23 , 95 , 58 }}; heatmap ( data ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 24 , 10 }, { 10 , 5 }, { 24 , 16 }, { 8 , 3 }}; heatmap ( data ); title ( \"Count of SelfAssessedHealthStatus vs. Smoker\" ); auto ax = gca (); ax -> x_axis (). ticklabels ({ \"false\" , \"true\" }); ax -> y_axis (). ticklabels ({ \"Excellent\" , \"Fair\" , \"Good\" , \"Poor\" }); xlabel ( ax , \"Smoker\" ); ylabel ( ax , \"SelfAssessedHealthStatus\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 38.46 , 39 }, { 39.7 , 36.2 }, { 38.13 , 38.88 }, { 33.88 , 43 }}; heatmap ( data ); title ( \"Mean of Age\" ); auto ax = gca (); ax -> x_axis (). ticklabels ({ \"false\" , \"true\" }); ax -> y_axis (). ticklabels ({ \"Excellent\" , \"Fair\" , \"Good\" , \"Poor\" }); xlabel ( ax , \"Smoker\" ); ylabel ( ax , \"SelfAssessedHealthStatus\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 45 , 60 , 32 }, { 43 , 54 , 76 }, { 32 , 94 , 68 }, { 23 , 95 , 58 }}; heatmap ( data ); title ( \"T-Shirt Orders\" ); auto ax = gca (); ax -> x_axis (). ticklabels ({ \"Small\" , \"Medium\" , \"Large\" }); ax -> y_axis (). ticklabels ({ \"Green\" , \"Red\" , \"Blue\" , \"Gray\" }); xlabel ( ax , \"Sizes\" ); ylabel ( ax , \"Colors\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 12 , 135 , 20 , 0 , 127 }, { 0 , 1 , 0 , 0 , 1 }, { 19 , 31 , 81 , 8 , 49 }, { 9 , 18 , 42 , 2 , 85 }, { 0 , 5 , 3 , 0 , 17 }, { 31 , 143 , 135 , 6 , 23 }, { 32 , 102 , 54 , 6 , 7 }, { 5 , 11 , 4 , 0 , 4 }, { 16 , 41 , 13 , 3 , 22 }, { 18 , 70 , 37 , 1 , 19 }}; heatmap ( data ); title ( \"Count of Cause vs. Region\" ); auto ax = gca (); ax -> x_axis (). ticklabels ( { \"MidWest\" , \"NorthEast\" , \"SouthEast\" , \"SouthWest\" , \"West\" }); ax -> y_axis (). ticklabels ( { \"Attack\" , \"Earthquake\" , \"Energy emergency\" , \"Equipment fault\" , \"Fire\" , \"Severe Storm\" , \"Thunder Storm\" , \"Unknown\" , \"Wind\" , \"Winter Storm\" }); xlabel ( ax , \"Region\" ); ylabel ( ax , \"Cause\" ); float w = ax -> width (); ax -> width ( w * 0.85f ); ax -> x_origin ( ax -> x_origin () + w * 0.1f ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 12 , 135 , 20 , 0 , 127 }, { 0 , 1 , 0 , 0 , 1 }, { 19 , 31 , 81 , 8 , 49 }, { 9 , 18 , 42 , 2 , 85 }, { 0 , 5 , 3 , 0 , 17 }, { 31 , 143 , 135 , 6 , 23 }, { 32 , 102 , 54 , 6 , 7 }, { 5 , 11 , 4 , 0 , 4 }, { 16 , 41 , 13 , 3 , 22 }, { 18 , 70 , 37 , 1 , 19 }}; heatmap ( data ) -> normalization ( matrix :: color_normalization :: columns ); title ( \"Count of Cause vs. Region\" ); auto ax = gca (); ax -> x_axis (). ticklabels ( { \"MidWest\" , \"NorthEast\" , \"SouthEast\" , \"SouthWest\" , \"West\" }); ax -> y_axis (). ticklabels ( { \"Attack\" , \"Earthquake\" , \"Energy emergency\" , \"Equipment fault\" , \"Fire\" , \"Severe Storm\" , \"Thunder Storm\" , \"Unknown\" , \"Wind\" , \"Winter Storm\" }); xlabel ( ax , \"Region\" ); ylabel ( ax , \"Cause\" ); float w = ax -> width (); ax -> width ( w * 0.85f ); ax -> x_origin ( ax -> x_origin () + w * 0.1f ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> data = { { 12 , 135 , 20 , 0 , 127 }, { 0 , 1 , 0 , 0 , 1 }, { 19 , 31 , 81 , 8 , 49 }, { 9 , 18 , 42 , 2 , 85 }, { 0 , 5 , 3 , 0 , 17 }, { 31 , 143 , 135 , 6 , 23 }, { 32 , 102 , 54 , 6 , 7 }, { 5 , 11 , 4 , 0 , 4 }, { 16 , 41 , 13 , 3 , 22 }, { 18 , 70 , 37 , 1 , 19 }}; heatmap ( data ) -> normalization ( matrix :: color_normalization :: rows ); title ( \"Count of Cause vs. Region\" ); auto ax = gca (); ax -> x_axis (). ticklabels ( { \"MidWest\" , \"NorthEast\" , \"SouthEast\" , \"SouthWest\" , \"West\" }); ax -> y_axis (). ticklabels ( { \"Attack\" , \"Earthquake\" , \"Energy emergency\" , \"Equipment fault\" , \"Fire\" , \"Severe Storm\" , \"Thunder Storm\" , \"Unknown\" , \"Wind\" , \"Winter Storm\" }); xlabel ( ax , \"Region\" ); ylabel ( ax , \"Cause\" ); float w = ax -> width (); ax -> width ( w * 0.85f ); ax -> x_origin ( ax -> x_origin () + w * 0.1f ); show (); return 0 ; }","title":"Heatmap"},{"location":"plot-types/data-distribution/histogram/","text":"Histogram The histogram object creates the histogram edges and bins when the draw function is called for the first time with lazy evaluation. Lazy evaluation avoids calculating edges unnecessarily in case the user changes the object parameters before calling draw . This object includes several algorithms for automatically delimiting the edges and bins for the histograms. 1 hist ( data ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); auto h = hist ( x ); std :: cout << \"Histogram with \" << h -> num_bins () << \" bins\" << std :: endl ; show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); subplot ( 2 , 3 , 0 ); hist ( x , histogram :: binning_algorithm :: automatic ); title ( \"Automatic binning\" ); subplot ( 2 , 3 , 1 ); hist ( x , histogram :: binning_algorithm :: scott ); title ( \"Scott's rule\" ); subplot ( 2 , 3 , 2 ); hist ( x , histogram :: binning_algorithm :: fd ); title ( \"Freedman-Diaconis rule\" ); subplot ( 2 , 3 , 3 ); hist ( x , histogram :: binning_algorithm :: integers ); title ( \"Integers rule\" ); subplot ( 2 , 3 , 4 ); hist ( x , histogram :: binning_algorithm :: sturges ); title ( \"Sturges' rule\" ); subplot ( 2 , 3 , 5 ); hist ( x , histogram :: binning_algorithm :: sqrt ); title ( \"Square root rule\" ); save ( \"histogram_2.svg\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); subplot ( 2 , 3 , 0 ); auto a = histogram :: binning_algorithm :: automatic ; hist ( x , a , histogram :: normalization :: count ); title ( \"Count (c_i)\" ); subplot ( 2 , 3 , 1 ); hist ( x , a , histogram :: normalization :: probability ); title ( \"Probability (c_i/N)\" ); subplot ( 2 , 3 , 2 ); hist ( x , a , histogram :: normalization :: cummulative_count ); title ( \"Cummulative count (\u2211_{j=1}^i c_j)\" ); subplot ( 2 , 3 , 3 ); hist ( x , a , histogram :: normalization :: count_density ); title ( \"Count density (c_i/w_i)\" ); subplot ( 2 , 3 , 4 ); hist ( x , a , histogram :: normalization :: pdf ); title ( \"PDF (c_i/(N w_i))\" ); subplot ( 2 , 3 , 5 ); hist ( x , a , histogram :: normalization :: cdf ); title ( \"CDF (\u2211_{j=1}^i c_j/N)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = randn ( 1000 , 0 , 1 ); size_t num_bins = 25 ; auto h = hist ( x , num_bins ); auto v_it = h -> values (). begin (); auto e_it = h -> bin_edges (). begin (); while ( v_it != h -> values (). end ()) { std :: cout << \"[\" << * e_it << \";\" << * std :: next ( e_it ) << \"] - count: \" << * v_it << std :: endl ; ++ v_it ; ++ e_it ; } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 1000 , 0 , 1 ); auto h = hist ( x ); title ( num2str ( h -> num_bins ()) + \" bins\" ); for ( size_t i = 0 ; i < 5 ; ++ i ) { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 3 )); size_t n_bins = morebins ( h ); title ( num2str ( h -> num_bins ()) + \" bins\" ); } h -> num_bins ( 50 ); title ( num2str ( h -> num_bins ()) + \" bins\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); std :: vector < double > edges = { -10.0000 , -2.0000 , -1.7500 , -1.5000 , -1.2500 , -1.0000 , -0.7500 , -0.5000 , -0.2500 , 0 , 0.2500 , 0.5000 , 0.7500 , 1.0000 , 1.2500 , 1.5000 , 1.7500 , 2.0000 , 10.0000 }; hist ( x , edges ) -> normalization ( histogram :: normalization :: count_density ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < std :: string > categories = { \"no\" , \"no\" , \"yes\" , \"yes\" , \"yes\" , \"no\" , \"no\" , \"no\" , \"no\" , \"undecided\" , \"undecided\" , \"yes\" , \"no\" , \"no\" , \"no\" , \"yes\" , \"no\" , \"yes\" , \"no\" , \"yes\" , \"no\" , \"no\" , \"no\" , \"yes\" , \"yes\" , \"yes\" , \"yes\" }; hist ( categories ) -> bar_width ( 0.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); auto h = hist ( x , histogram :: normalization :: probability ); std :: cout << \"Sum of bar heights: \" << std :: accumulate ( h -> values (). begin (), h -> values (). end (), 0.0 ) << std :: endl ; show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 2000 , 0 , 1 ); std :: vector < double > y = randn ( 5000 , 1 , 1 ); auto h1 = hist ( x ); hold ( on ); auto h2 = hist ( y ); h1 -> normalization ( histogram :: normalization :: probability ); h1 -> bin_width ( 0.25 ); h2 -> normalization ( histogram :: normalization :: probability ); h2 -> bin_width ( 0.25 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 1000 , 0 , 1 ); auto h = hist ( x ); h -> num_bins ( 15 ); h -> bin_edges ( iota ( -3 , 3 )); h -> face_color ({ 0. , 0. , 0.5 , 0.5 }); h -> edge_color ( \"r\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 5000 , 5 , 2 ); auto h = hist ( x ); h -> normalization ( histogram :: normalization :: pdf ); hold ( on ); double mu = 5 ; double sigma = 2 ; auto f = [ & ]( double y ) { return exp ( - pow (( y - mu ), 2. ) / ( 2. * pow ( sigma , 2. ))) / ( sigma * sqrt ( 2. * pi )); }; fplot ( f , std :: array < double , 2 > { -5 , 15 }) -> line_width ( 1.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 1000 , 0 , 1 ); auto h = hist ( x ); title ( num2str ( h -> num_bins ()) + \" bins\" ); for ( size_t i = 0 ; i < 5 ; ++ i ) { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 3 )); size_t n_bins = fewerbins ( h ); title ( num2str ( h -> num_bins ()) + \" bins\" ); } h -> num_bins ( 5 ); title ( num2str ( h -> num_bins ()) + \" bins\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 #include <iostream> #include <matplot/matplot.h> #include <random> constexpr size_t DEFAULT_BOOTSTRAP_REPLICATES = 1000000 ; std :: vector < double > bootstrap ( std :: function < double () > statistic , size_t replicates = DEFAULT_BOOTSTRAP_REPLICATES ) { std :: vector < double > data ( replicates ); std :: generate ( data . begin (), data . end (), statistic ); return data ; } std :: vector < double > bootstrap ( std :: function < double ( std :: vector < double > ) > statistic , std :: function < double () > data_source , size_t sample_size , size_t replicates = DEFAULT_BOOTSTRAP_REPLICATES ) { std :: vector < double > data ( replicates ); return bootstrap ( [ & ]() { std :: vector < double > data ( sample_size ); std :: generate ( data . begin (), data . end (), data_source ); return statistic ( data ); }, replicates ); } template < typename NUMBER > double mean ( const std :: vector < NUMBER > & v ) { double sum = 0.0 ; for ( const auto & item : v ) { sum += static_cast < double > ( item ); } return sum / static_cast < double > ( v . size ()); } int main () { // Example bootstraping from many distributions. // Distributions: // https://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/ using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 3 ); f -> height ( f -> height () * 2 ); f -> x_position ( 10 ); f -> y_position ( 10 ); enum histogram :: normalization norm = histogram :: normalization :: probability ; enum histogram :: binning_algorithm alg = histogram :: binning_algorithm :: automatic ; const size_t n_bins = 200 ; const double hist_alpha = 0.7 ; std :: default_random_engine r ; std :: mt19937 generator ( r ()); std :: cout << \"Averages - Normal\" << std :: endl ; subplot ( 2 , 3 , 0 ); title ( \"Average - Normal / Gaussian - mean(x)= {\u2211 x_i}/{n} - x_i = N(0,1)\" ); xlim ({ -4 , 4 }); legend (); std :: normal_distribution < double > d ( 0 , 1 ); std :: function < double () > normal_data_source = [ & ]() { return d ( generator ); }; hist ( bootstrap ( mean < double > , normal_data_source , 1 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , normal_data_source , 2 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , normal_data_source , 5 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , normal_data_source , 10 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , normal_data_source , 30 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Averages - Uniform\" << std :: endl ; subplot ( 2 , 3 , 1 ); title ( \"Average - Uniform - mean(x)= {\u2211 x_i}/{n} - x_i = U(-1;+1)\" ); xlim ({ -1 , 1 }); legend (); std :: uniform_real_distribution < double > u ( -1.0 , 1.0 ); std :: function < double () > uniform_data_source = [ & ]() { return u ( generator ); }; hist ( bootstrap ( mean < double > , uniform_data_source , 1 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , uniform_data_source , 2 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , uniform_data_source , 5 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , uniform_data_source , 10 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , uniform_data_source , 30 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Sum of squares - Chi-squared distribution\" << std :: endl ; subplot ( 2 , 3 , 2 ); title ( \"Sum of Squares - Chi-Squared - \u2211 (x_i - mean(x))^2\" ); xlim ({ 0 , 5 }); legend (); double m = 0 ; auto chi2_data_source = [ & ]() { return pow ( normal_data_source () - m , 2.0 ); }; hist ( bootstrap ( mean < double > , chi2_data_source , 1 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , chi2_data_source , 2 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi2_data_source , 5 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi2_data_source , 10 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi2_data_source , 30 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); // xlim({0,50}); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Square root of sum of squares (Chi distribution)\" << std :: endl ; subplot ( 2 , 3 , 3 ); title ( \"Square Root of Sum of Squares - Chi - \u221a{\u2211 (x_i - mean(x))^2}\" ); xlim ({ 0 , 4 }); legend (); auto chi_data_source = [ & ]() { return sqrt ( chi2_data_source ()); }; hist ( bootstrap ( mean < double > , chi_data_source , 1 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , chi_data_source , 2 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi_data_source , 5 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi_data_source , 10 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi_data_source , 30 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Ratio of scaled sums of squares / variance (F distribution)\" << std :: endl ; subplot ( 2 , 3 , 4 ); title ( \"Variance ratio - F - \u03c3_1 / \u03c3_2\" ); legend (); m = 0.0 ; auto ratio_ss = [ & ]() { return chi2_data_source () / chi2_data_source (); }; xlim ({ 0 , 5 }); std :: vector < double > edges = linspace ( 0 , 10 , n_bins ); hist ( bootstrap ( mean < double > , ratio_ss , 1 ), edges ) -> bin_limits_min ( 0 ) . bin_limits_max ( 5 ) . normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , ratio_ss , 2 ), edges ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , ratio_ss , 5 ), edges ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , ratio_ss , 10 ), edges ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , ratio_ss , 30 ), edges ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Averages - Bernoulli\" << std :: endl ; subplot ( 2 , 3 , 5 ); title ( \"Average - Bernoulli - mean(x)= {\u2211 x_i}/{n} - x_i = B(1/6)\" ); xlim ({ 0 , 1 }); legend (); std :: bernoulli_distribution b ( 1. / 6. ); std :: function < double () > bernoulli_data_source = [ & ]() { return static_cast < double > ( b ( generator )); }; hist ( bootstrap ( mean < double > , bernoulli_data_source , 1 ), 4 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , bernoulli_data_source , 5 ), 6 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , bernoulli_data_source , 30 ), 10 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , bernoulli_data_source , 300 , 100000 ), 50 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"300 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , bernoulli_data_source , 3000 , 10000 ), 50 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"3000 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); // save(\"distributions.png\"); // save(\"distributions.pdf\"); // save(\"distributions.eps\"); // save(\"distributions.gif\"); // save(\"distributions.jpg\"); show (); return 0 ; }","title":"Histogram"},{"location":"plot-types/data-distribution/histogram/#histogram","text":"The histogram object creates the histogram edges and bins when the draw function is called for the first time with lazy evaluation. Lazy evaluation avoids calculating edges unnecessarily in case the user changes the object parameters before calling draw . This object includes several algorithms for automatically delimiting the edges and bins for the histograms. 1 hist ( data ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); auto h = hist ( x ); std :: cout << \"Histogram with \" << h -> num_bins () << \" bins\" << std :: endl ; show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); subplot ( 2 , 3 , 0 ); hist ( x , histogram :: binning_algorithm :: automatic ); title ( \"Automatic binning\" ); subplot ( 2 , 3 , 1 ); hist ( x , histogram :: binning_algorithm :: scott ); title ( \"Scott's rule\" ); subplot ( 2 , 3 , 2 ); hist ( x , histogram :: binning_algorithm :: fd ); title ( \"Freedman-Diaconis rule\" ); subplot ( 2 , 3 , 3 ); hist ( x , histogram :: binning_algorithm :: integers ); title ( \"Integers rule\" ); subplot ( 2 , 3 , 4 ); hist ( x , histogram :: binning_algorithm :: sturges ); title ( \"Sturges' rule\" ); subplot ( 2 , 3 , 5 ); hist ( x , histogram :: binning_algorithm :: sqrt ); title ( \"Square root rule\" ); save ( \"histogram_2.svg\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); subplot ( 2 , 3 , 0 ); auto a = histogram :: binning_algorithm :: automatic ; hist ( x , a , histogram :: normalization :: count ); title ( \"Count (c_i)\" ); subplot ( 2 , 3 , 1 ); hist ( x , a , histogram :: normalization :: probability ); title ( \"Probability (c_i/N)\" ); subplot ( 2 , 3 , 2 ); hist ( x , a , histogram :: normalization :: cummulative_count ); title ( \"Cummulative count (\u2211_{j=1}^i c_j)\" ); subplot ( 2 , 3 , 3 ); hist ( x , a , histogram :: normalization :: count_density ); title ( \"Count density (c_i/w_i)\" ); subplot ( 2 , 3 , 4 ); hist ( x , a , histogram :: normalization :: pdf ); title ( \"PDF (c_i/(N w_i))\" ); subplot ( 2 , 3 , 5 ); hist ( x , a , histogram :: normalization :: cdf ); title ( \"CDF (\u2211_{j=1}^i c_j/N)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = randn ( 1000 , 0 , 1 ); size_t num_bins = 25 ; auto h = hist ( x , num_bins ); auto v_it = h -> values (). begin (); auto e_it = h -> bin_edges (). begin (); while ( v_it != h -> values (). end ()) { std :: cout << \"[\" << * e_it << \";\" << * std :: next ( e_it ) << \"] - count: \" << * v_it << std :: endl ; ++ v_it ; ++ e_it ; } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 1000 , 0 , 1 ); auto h = hist ( x ); title ( num2str ( h -> num_bins ()) + \" bins\" ); for ( size_t i = 0 ; i < 5 ; ++ i ) { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 3 )); size_t n_bins = morebins ( h ); title ( num2str ( h -> num_bins ()) + \" bins\" ); } h -> num_bins ( 50 ); title ( num2str ( h -> num_bins ()) + \" bins\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); std :: vector < double > edges = { -10.0000 , -2.0000 , -1.7500 , -1.5000 , -1.2500 , -1.0000 , -0.7500 , -0.5000 , -0.2500 , 0 , 0.2500 , 0.5000 , 0.7500 , 1.0000 , 1.2500 , 1.5000 , 1.7500 , 2.0000 , 10.0000 }; hist ( x , edges ) -> normalization ( histogram :: normalization :: count_density ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < std :: string > categories = { \"no\" , \"no\" , \"yes\" , \"yes\" , \"yes\" , \"no\" , \"no\" , \"no\" , \"no\" , \"undecided\" , \"undecided\" , \"yes\" , \"no\" , \"no\" , \"no\" , \"yes\" , \"no\" , \"yes\" , \"no\" , \"yes\" , \"no\" , \"no\" , \"no\" , \"yes\" , \"yes\" , \"yes\" , \"yes\" }; hist ( categories ) -> bar_width ( 0.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 10000 , 0 , 1 ); auto h = hist ( x , histogram :: normalization :: probability ); std :: cout << \"Sum of bar heights: \" << std :: accumulate ( h -> values (). begin (), h -> values (). end (), 0.0 ) << std :: endl ; show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 2000 , 0 , 1 ); std :: vector < double > y = randn ( 5000 , 1 , 1 ); auto h1 = hist ( x ); hold ( on ); auto h2 = hist ( y ); h1 -> normalization ( histogram :: normalization :: probability ); h1 -> bin_width ( 0.25 ); h2 -> normalization ( histogram :: normalization :: probability ); h2 -> bin_width ( 0.25 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 1000 , 0 , 1 ); auto h = hist ( x ); h -> num_bins ( 15 ); h -> bin_edges ( iota ( -3 , 3 )); h -> face_color ({ 0. , 0. , 0.5 , 0.5 }); h -> edge_color ( \"r\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 5000 , 5 , 2 ); auto h = hist ( x ); h -> normalization ( histogram :: normalization :: pdf ); hold ( on ); double mu = 5 ; double sigma = 2 ; auto f = [ & ]( double y ) { return exp ( - pow (( y - mu ), 2. ) / ( 2. * pow ( sigma , 2. ))) / ( sigma * sqrt ( 2. * pi )); }; fplot ( f , std :: array < double , 2 > { -5 , 15 }) -> line_width ( 1.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> #include <random> #include <thread> int main () { using namespace matplot ; std :: vector < double > x = randn ( 1000 , 0 , 1 ); auto h = hist ( x ); title ( num2str ( h -> num_bins ()) + \" bins\" ); for ( size_t i = 0 ; i < 5 ; ++ i ) { std :: this_thread :: sleep_for ( std :: chrono :: seconds ( 3 )); size_t n_bins = fewerbins ( h ); title ( num2str ( h -> num_bins ()) + \" bins\" ); } h -> num_bins ( 5 ); title ( num2str ( h -> num_bins ()) + \" bins\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 #include <iostream> #include <matplot/matplot.h> #include <random> constexpr size_t DEFAULT_BOOTSTRAP_REPLICATES = 1000000 ; std :: vector < double > bootstrap ( std :: function < double () > statistic , size_t replicates = DEFAULT_BOOTSTRAP_REPLICATES ) { std :: vector < double > data ( replicates ); std :: generate ( data . begin (), data . end (), statistic ); return data ; } std :: vector < double > bootstrap ( std :: function < double ( std :: vector < double > ) > statistic , std :: function < double () > data_source , size_t sample_size , size_t replicates = DEFAULT_BOOTSTRAP_REPLICATES ) { std :: vector < double > data ( replicates ); return bootstrap ( [ & ]() { std :: vector < double > data ( sample_size ); std :: generate ( data . begin (), data . end (), data_source ); return statistic ( data ); }, replicates ); } template < typename NUMBER > double mean ( const std :: vector < NUMBER > & v ) { double sum = 0.0 ; for ( const auto & item : v ) { sum += static_cast < double > ( item ); } return sum / static_cast < double > ( v . size ()); } int main () { // Example bootstraping from many distributions. // Distributions: // https://blog.cloudera.com/blog/2015/12/common-probability-distributions-the-data-scientists-crib-sheet/ using namespace matplot ; auto f = figure ( true ); f -> width ( f -> width () * 3 ); f -> height ( f -> height () * 2 ); f -> x_position ( 10 ); f -> y_position ( 10 ); enum histogram :: normalization norm = histogram :: normalization :: probability ; enum histogram :: binning_algorithm alg = histogram :: binning_algorithm :: automatic ; const size_t n_bins = 200 ; const double hist_alpha = 0.7 ; std :: default_random_engine r ; std :: mt19937 generator ( r ()); std :: cout << \"Averages - Normal\" << std :: endl ; subplot ( 2 , 3 , 0 ); title ( \"Average - Normal / Gaussian - mean(x)= {\u2211 x_i}/{n} - x_i = N(0,1)\" ); xlim ({ -4 , 4 }); legend (); std :: normal_distribution < double > d ( 0 , 1 ); std :: function < double () > normal_data_source = [ & ]() { return d ( generator ); }; hist ( bootstrap ( mean < double > , normal_data_source , 1 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , normal_data_source , 2 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , normal_data_source , 5 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , normal_data_source , 10 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , normal_data_source , 30 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Averages - Uniform\" << std :: endl ; subplot ( 2 , 3 , 1 ); title ( \"Average - Uniform - mean(x)= {\u2211 x_i}/{n} - x_i = U(-1;+1)\" ); xlim ({ -1 , 1 }); legend (); std :: uniform_real_distribution < double > u ( -1.0 , 1.0 ); std :: function < double () > uniform_data_source = [ & ]() { return u ( generator ); }; hist ( bootstrap ( mean < double > , uniform_data_source , 1 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , uniform_data_source , 2 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , uniform_data_source , 5 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , uniform_data_source , 10 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , uniform_data_source , 30 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Sum of squares - Chi-squared distribution\" << std :: endl ; subplot ( 2 , 3 , 2 ); title ( \"Sum of Squares - Chi-Squared - \u2211 (x_i - mean(x))^2\" ); xlim ({ 0 , 5 }); legend (); double m = 0 ; auto chi2_data_source = [ & ]() { return pow ( normal_data_source () - m , 2.0 ); }; hist ( bootstrap ( mean < double > , chi2_data_source , 1 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , chi2_data_source , 2 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi2_data_source , 5 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi2_data_source , 10 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi2_data_source , 30 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); // xlim({0,50}); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Square root of sum of squares (Chi distribution)\" << std :: endl ; subplot ( 2 , 3 , 3 ); title ( \"Square Root of Sum of Squares - Chi - \u221a{\u2211 (x_i - mean(x))^2}\" ); xlim ({ 0 , 4 }); legend (); auto chi_data_source = [ & ]() { return sqrt ( chi2_data_source ()); }; hist ( bootstrap ( mean < double > , chi_data_source , 1 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , chi_data_source , 2 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi_data_source , 5 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi_data_source , 10 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , chi_data_source , 30 ), n_bins ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Ratio of scaled sums of squares / variance (F distribution)\" << std :: endl ; subplot ( 2 , 3 , 4 ); title ( \"Variance ratio - F - \u03c3_1 / \u03c3_2\" ); legend (); m = 0.0 ; auto ratio_ss = [ & ]() { return chi2_data_source () / chi2_data_source (); }; xlim ({ 0 , 5 }); std :: vector < double > edges = linspace ( 0 , 10 , n_bins ); hist ( bootstrap ( mean < double > , ratio_ss , 1 ), edges ) -> bin_limits_min ( 0 ) . bin_limits_max ( 5 ) . normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , ratio_ss , 2 ), edges ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"2 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , ratio_ss , 5 ), edges ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , ratio_ss , 10 ), edges ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"10 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , ratio_ss , 30 ), edges ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); std :: cout << \"Averages - Bernoulli\" << std :: endl ; subplot ( 2 , 3 , 5 ); title ( \"Average - Bernoulli - mean(x)= {\u2211 x_i}/{n} - x_i = B(1/6)\" ); xlim ({ 0 , 1 }); legend (); std :: bernoulli_distribution b ( 1. / 6. ); std :: function < double () > bernoulli_data_source = [ & ]() { return static_cast < double > ( b ( generator )); }; hist ( bootstrap ( mean < double > , bernoulli_data_source , 1 ), 4 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"1 sample\" ); f -> draw (); hold ( on ); hist ( bootstrap ( mean < double > , bernoulli_data_source , 5 ), 6 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"5 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , bernoulli_data_source , 30 ), 10 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"30 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , bernoulli_data_source , 300 , 100000 ), 50 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"300 samples\" ); f -> draw (); hist ( bootstrap ( mean < double > , bernoulli_data_source , 3000 , 10000 ), 50 ) -> normalization ( norm ) . algorithm ( alg ) . edge_alpha ( 1.0 ) . face_alpha ( hist_alpha ) . display_name ( \"3000 samples\" ); f -> draw (); xlabel ( \"Value\" ); ylabel ( \"Frequency\" ); // save(\"distributions.png\"); // save(\"distributions.pdf\"); // save(\"distributions.eps\"); // save(\"distributions.gif\"); // save(\"distributions.jpg\"); show (); return 0 ; }","title":"Histogram"},{"location":"plot-types/data-distribution/parallel-coordinates/","text":"Parallel Coordinates 1 parallelplot ( X ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X ( 3 ); X [ 0 ] = concat ( rand ( 50 , 78 , 100 ), rand ( 50 , 65 , 91 )); X [ 1 ] = concat ( std :: vector < double > ( 50 , 1 ), std :: vector < double > ( 50 , 0 )); X [ 2 ] = concat ( rand ( 50 , 122 , 140 ), rand ( 50 , 105 , 131 )); auto p = parallelplot ( X ); gca () -> x_axis (). tick_values ({ 1 , 2 , 3 }); gca () -> x_axis (). ticklabels ({ \"f_1\" , \"f_2\" , \"f_3\" }); p -> axis ()[ 1 ]. tick_values ({ 0 , 1 }); p -> axis ()[ 1 ]. ticklabels ({ \"false\" , \"true\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X ( 4 ); X [ 0 ] = concat ( rand ( 50 , 78 , 200 ), rand ( 50 , 65 , 91 )); X [ 1 ] = concat ( std :: vector < double > ( 50 , 1 ), std :: vector < double > ( 50 , 0 )); X [ 2 ] = concat ( rand ( 50 , 122 , 140 ), rand ( 50 , 105 , 131 )); X [ 3 ] = concat ( concat ( std :: vector < double > ( 25 , 3 ), std :: vector < double > ( 50 , 1 )), std :: vector < double > ( 25 , 2 )); auto p = parallelplot ( X , X [ 3 ]); gca () -> x_axis (). tick_values ({ 1 , 2 , 3 , 4 }); gca () -> x_axis (). ticklabels ({ \"f_1\" , \"f_2\" , \"f_3\" , \"f_4\" }); p -> axis ()[ 1 ]. tick_values ({ 0 , 1 }); p -> axis ()[ 1 ]. ticklabels ({ \"false\" , \"true\" }); p -> axis ()[ 3 ]. tick_values ({ 1 , 2 , 3 }); p -> axis ()[ 3 ]. ticklabels ({ \"low\" , \"medium\" , \"high\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X ( 4 ); X [ 0 ] = randn ( 100 , 50 , 200 ); X [ 1 ] = transform ( X [ 0 ], []( double x ) { return x + rand ( -30 , + 30 ); }); X [ 2 ] = transform ( X [ 0 ], []( double x ) { return x > 50 ? + 1. : -1. ; }); X [ 3 ] = transform ( X [ 0 ], []( double x ) { return cos ( rand ( -30 , + 30 )); }); auto colors = X [ 2 ]; parallelplot ( X , colors ); show (); return 0 ; } The function parallelplot creates a plot with Parallel Coordinates. In this type of plot, a parallel lines object stores an arbitrary set of axis objects to represent multi-dimensional data.","title":"Parallel Coordinates"},{"location":"plot-types/data-distribution/parallel-coordinates/#parallel-coordinates","text":"1 parallelplot ( X ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X ( 3 ); X [ 0 ] = concat ( rand ( 50 , 78 , 100 ), rand ( 50 , 65 , 91 )); X [ 1 ] = concat ( std :: vector < double > ( 50 , 1 ), std :: vector < double > ( 50 , 0 )); X [ 2 ] = concat ( rand ( 50 , 122 , 140 ), rand ( 50 , 105 , 131 )); auto p = parallelplot ( X ); gca () -> x_axis (). tick_values ({ 1 , 2 , 3 }); gca () -> x_axis (). ticklabels ({ \"f_1\" , \"f_2\" , \"f_3\" }); p -> axis ()[ 1 ]. tick_values ({ 0 , 1 }); p -> axis ()[ 1 ]. ticklabels ({ \"false\" , \"true\" }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X ( 4 ); X [ 0 ] = concat ( rand ( 50 , 78 , 200 ), rand ( 50 , 65 , 91 )); X [ 1 ] = concat ( std :: vector < double > ( 50 , 1 ), std :: vector < double > ( 50 , 0 )); X [ 2 ] = concat ( rand ( 50 , 122 , 140 ), rand ( 50 , 105 , 131 )); X [ 3 ] = concat ( concat ( std :: vector < double > ( 25 , 3 ), std :: vector < double > ( 50 , 1 )), std :: vector < double > ( 25 , 2 )); auto p = parallelplot ( X , X [ 3 ]); gca () -> x_axis (). tick_values ({ 1 , 2 , 3 , 4 }); gca () -> x_axis (). ticklabels ({ \"f_1\" , \"f_2\" , \"f_3\" , \"f_4\" }); p -> axis ()[ 1 ]. tick_values ({ 0 , 1 }); p -> axis ()[ 1 ]. ticklabels ({ \"false\" , \"true\" }); p -> axis ()[ 3 ]. tick_values ({ 1 , 2 , 3 }); p -> axis ()[ 3 ]. ticklabels ({ \"low\" , \"medium\" , \"high\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X ( 4 ); X [ 0 ] = randn ( 100 , 50 , 200 ); X [ 1 ] = transform ( X [ 0 ], []( double x ) { return x + rand ( -30 , + 30 ); }); X [ 2 ] = transform ( X [ 0 ], []( double x ) { return x > 50 ? + 1. : -1. ; }); X [ 3 ] = transform ( X [ 0 ], []( double x ) { return cos ( rand ( -30 , + 30 )); }); auto colors = X [ 2 ]; parallelplot ( X , colors ); show (); return 0 ; } The function parallelplot creates a plot with Parallel Coordinates. In this type of plot, a parallel lines object stores an arbitrary set of axis objects to represent multi-dimensional data.","title":"Parallel Coordinates"},{"location":"plot-types/data-distribution/pie-chart/","text":"Pie Chart 1 pie ( x ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 1 , 3 , 0.5 , 2.5 , 2 }; pie ( x ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 1 , 3 , 0.5 , 2.5 , 2 }; std :: vector < double > explode = { 0 , 1 , 0 , 1 , 0 }; pie ( x , explode ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 1 , 3 ); std :: vector < std :: string > labels = { \"Taxes\" , \"Expenses\" , \"Profit\" }; pie ( x , labels ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 0.19 , 0.22 , 0.41 }; pie ( x ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > y2010 = { 50 , 0 , 100 , 95 }; std :: vector < double > y2011 = { 65 , 22 , 97 , 120 }; std :: vector < std :: string > labels = { \"Investments\" , \"Cash\" , \"Operations\" , \"Sales\" }; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); pie ( ax1 , y2010 ); title ( \"2010\" ); auto ax2 = nexttile (); pie ( ax2 , y2011 ); title ( \"2011\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 17 , 33 , 33 , 17 }; std :: vector < double > explode = { 0 , 1 , 1 , 0 }; std :: vector < std :: string > labels = { \"East (17%)\" , \"North (33%)\" , \"South (33%)\" , \"West (17%)\" }; pie ( x , explode , labels ); show (); return 0 ; }","title":"Pie Chart"},{"location":"plot-types/data-distribution/pie-chart/#pie-chart","text":"1 pie ( x ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 1 , 3 , 0.5 , 2.5 , 2 }; pie ( x ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 1 , 3 , 0.5 , 2.5 , 2 }; std :: vector < double > explode = { 0 , 1 , 0 , 1 , 0 }; pie ( x , explode ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 1 , 3 ); std :: vector < std :: string > labels = { \"Taxes\" , \"Expenses\" , \"Profit\" }; pie ( x , labels ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 0.19 , 0.22 , 0.41 }; pie ( x ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > y2010 = { 50 , 0 , 100 , 95 }; std :: vector < double > y2011 = { 65 , 22 , 97 , 120 }; std :: vector < std :: string > labels = { \"Investments\" , \"Cash\" , \"Operations\" , \"Sales\" }; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); pie ( ax1 , y2010 ); title ( \"2010\" ); auto ax2 = nexttile (); pie ( ax2 , y2011 ); title ( \"2011\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 17 , 33 , 33 , 17 }; std :: vector < double > explode = { 0 , 1 , 1 , 0 }; std :: vector < std :: string > labels = { \"East (17%)\" , \"North (33%)\" , \"South (33%)\" , \"West (17%)\" }; pie ( x , explode , labels ); show (); return 0 ; }","title":"Pie Chart"},{"location":"plot-types/data-distribution/plot-matrix/","text":"Plot Matrix 1 plotmatrix ( X ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X = { randn ( 50 , 0 , 1 ), randn ( 50 , 0 , 1 ), randn ( 50 , 0 , 1 )}; std :: vector < std :: vector < double >> Y = { iota ( 1 , 50 ), iota ( 51 , 100 ), iota ( 101 , 150 )}; plotmatrix ( X , Y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X = { randn ( 200 , 0 , 1 ), randn ( 200 , 0 , 1 ), randn ( 200 , 0 , 1 )}; plotmatrix ( X ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X = { randn ( 200 , 0 , 1 ), randn ( 200 , 0 , 1 ), randn ( 200 , 0 , 1 )}; plotmatrix ( X , \"*r\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X = { randn ( 100 , 0 , 1 ), randn ( 100 , 0 , 1 ), randn ( 100 , 0 , 1 )}; auto [ S , H , axs ] = plotmatrix ( X ); S [ 2 ][ 0 ] -> color ( \"g\" ); S [ 2 ][ 0 ] -> marker ( \"*\" ); H [ 2 ] -> edge_color ( \"k\" ); H [ 2 ] -> face_color ( \"g\" ); axs [ 0 ][ 1 ] -> title ( \"A Comparison of Data Sets\" ); show (); return 0 ; } The Plot Matrix subcategory is a combination of histograms and scatter plots. It creates a matrix of axes objects on the figure and creates a scatter plot for each pair of data sets.","title":"Plot Matrix"},{"location":"plot-types/data-distribution/plot-matrix/#plot-matrix","text":"1 plotmatrix ( X ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X = { randn ( 50 , 0 , 1 ), randn ( 50 , 0 , 1 ), randn ( 50 , 0 , 1 )}; std :: vector < std :: vector < double >> Y = { iota ( 1 , 50 ), iota ( 51 , 100 ), iota ( 101 , 150 )}; plotmatrix ( X , Y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X = { randn ( 200 , 0 , 1 ), randn ( 200 , 0 , 1 ), randn ( 200 , 0 , 1 )}; plotmatrix ( X ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X = { randn ( 200 , 0 , 1 ), randn ( 200 , 0 , 1 ), randn ( 200 , 0 , 1 )}; plotmatrix ( X , \"*r\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; std :: vector < std :: vector < double >> X = { randn ( 100 , 0 , 1 ), randn ( 100 , 0 , 1 ), randn ( 100 , 0 , 1 )}; auto [ S , H , axs ] = plotmatrix ( X ); S [ 2 ][ 0 ] -> color ( \"g\" ); S [ 2 ][ 0 ] -> marker ( \"*\" ); H [ 2 ] -> edge_color ( \"k\" ); H [ 2 ] -> face_color ( \"g\" ); axs [ 0 ][ 1 ] -> title ( \"A Comparison of Data Sets\" ); show (); return 0 ; } The Plot Matrix subcategory is a combination of histograms and scatter plots. It creates a matrix of axes objects on the figure and creates a scatter plot for each pair of data sets.","title":"Plot Matrix"},{"location":"plot-types/data-distribution/scatter-plot-3d/","text":"Scatter Plot 3D 1 scatter ( x , y , z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include <matplot/matplot.h> #include <random> #include <tuple> std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data (); int main () { using namespace matplot ; auto [ x , y , z ] = generate_data (); scatter3 ( x , y , z ); show (); return 0 ; } std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data () { using namespace matplot ; int n = 16 ; auto r = iota ( static_cast < double > ( - n ), 2. , static_cast < double > ( n )); auto theta = transform ( r , [ n ]( double x ) { return x / n * pi ; }); auto phi = transform ( r , [ n ]( double x ) { return x / n * pi / 2. ; }); auto sinphi = transform ( phi , []( double x ) { return sin ( x ); }); auto cosphi = transform ( phi , []( double x ) { return cos ( x ); }); cosphi . front () = 0 ; cosphi . back () = 0 ; auto sintheta = transform ( theta , []( double x ) { return sin ( x ); }); sintheta . front () = 0 ; sintheta . back () = 0 ; auto costheta = transform ( theta , []( double x ) { return cos ( x ); }); std :: vector < std :: vector < double >> X ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Y ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Z ( 17 , std :: vector < double > ( 17 , 0. )); for ( int i = 0 ; i < n + 1 ; ++ i ) { for ( int j = 0 ; j < n + 1 ; ++ j ) { X [ i ][ j ] = cosphi [ i ] * costheta [ j ]; Y [ i ][ j ] = cosphi [ i ] * sintheta [ j ]; Z [ i ][ j ] = sinphi [ i ]; } } auto X1d = reshape ( X ); auto Y1d = reshape ( Y ); auto Z1d = reshape ( Z ); std :: vector < double > x = concat ( concat ( transform ( X1d , []( double x ) { return x * 0.5 ; }), transform ( X1d , []( double x ) { return x * 0.75 ; })), X1d ); std :: vector < double > y = concat ( concat ( transform ( Y1d , []( double y ) { return y * 0.5 ; }), transform ( Y1d , []( double y ) { return y * 0.75 ; })), Y1d ); std :: vector < double > z = concat ( concat ( transform ( Z1d , []( double z ) { return z * 0.5 ; }), transform ( Z1d , []( double z ) { return z * 0.75 ; })), Z1d ); return std :: make_tuple ( x , y , z ); } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <matplot/matplot.h> #include <random> #include <tuple> std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data (); int main () { using namespace matplot ; auto [ x , y , z ] = generate_data (); std :: vector < double > sizes ( x . size () / 3 , 16 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 8 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 2 ); scatter3 ( x , y , z , sizes ); view ( 40 , 35 ); show (); return 0 ; } std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data () { using namespace matplot ; int n = 16 ; auto r = iota ( - n , 2. , n ); auto theta = transform ( r , [ n ]( double x ) { return x / n * pi ; }); auto phi = transform ( r , [ n ]( double x ) { return x / n * pi / 2. ; }); auto sinphi = transform ( phi , []( double x ) { return sin ( x ); }); auto cosphi = transform ( phi , []( double x ) { return cos ( x ); }); cosphi . front () = 0 ; cosphi . back () = 0 ; auto sintheta = transform ( theta , [ n ]( double x ) { return sin ( x ); }); sintheta . front () = 0 ; sintheta . back () = 0 ; auto costheta = transform ( theta , [ n ]( double x ) { return cos ( x ); }); std :: vector < std :: vector < double >> X ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Y ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Z ( 17 , std :: vector < double > ( 17 , 0. )); for ( int i = 0 ; i < n + 1 ; ++ i ) { for ( int j = 0 ; j < n + 1 ; ++ j ) { X [ i ][ j ] = cosphi [ i ] * costheta [ j ]; Y [ i ][ j ] = cosphi [ i ] * sintheta [ j ]; Z [ i ][ j ] = sinphi [ i ]; } } auto X1d = reshape ( X ); auto Y1d = reshape ( Y ); auto Z1d = reshape ( Z ); std :: vector < double > x = concat ( concat ( transform ( X1d , []( double x ) { return x * 0.5 ; }), transform ( X1d , []( double x ) { return x * 0.75 ; })), X1d ); std :: vector < double > y = concat ( concat ( transform ( Y1d , []( double y ) { return y * 0.5 ; }), transform ( Y1d , []( double y ) { return y * 0.75 ; })), Y1d ); std :: vector < double > z = concat ( concat ( transform ( Z1d , []( double z ) { return z * 0.5 ; }), transform ( Z1d , []( double z ) { return z * 0.75 ; })), Z1d ); return std :: make_tuple ( x , y , z ); } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include <matplot/matplot.h> #include <random> #include <tuple> std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data (); int main () { using namespace matplot ; auto [ x , y , z ] = generate_data (); std :: vector < double > sizes ( x . size () / 3 , 16 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 8 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 2 ); std :: vector < double > colors ( x . size () / 3 , 1 ); std :: fill_n ( std :: back_inserter ( colors ), x . size () / 3 , 2 ); std :: fill_n ( std :: back_inserter ( colors ), x . size () / 3 , 3 ); scatter3 ( x , y , z , sizes , colors ); view ( 40 , 35 ); show (); return 0 ; } std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data () { using namespace matplot ; int n = 16 ; auto r = iota ( - n , 2. , n ); auto theta = transform ( r , [ n ]( double x ) { return x / n * pi ; }); auto phi = transform ( r , [ n ]( double x ) { return x / n * pi / 2. ; }); auto sinphi = transform ( phi , []( double x ) { return sin ( x ); }); auto cosphi = transform ( phi , []( double x ) { return cos ( x ); }); cosphi . front () = 0 ; cosphi . back () = 0 ; auto sintheta = transform ( theta , [ n ]( double x ) { return sin ( x ); }); sintheta . front () = 0 ; sintheta . back () = 0 ; auto costheta = transform ( theta , [ n ]( double x ) { return cos ( x ); }); std :: vector < std :: vector < double >> X ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Y ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Z ( 17 , std :: vector < double > ( 17 , 0. )); for ( int i = 0 ; i < n + 1 ; ++ i ) { for ( int j = 0 ; j < n + 1 ; ++ j ) { X [ i ][ j ] = cosphi [ i ] * costheta [ j ]; Y [ i ][ j ] = cosphi [ i ] * sintheta [ j ]; Z [ i ][ j ] = sinphi [ i ]; } } auto X1d = reshape ( X ); auto Y1d = reshape ( Y ); auto Z1d = reshape ( Z ); std :: vector < double > x = concat ( concat ( transform ( X1d , []( double x ) { return x * 0.5 ; }), transform ( X1d , []( double x ) { return x * 0.75 ; })), X1d ); std :: vector < double > y = concat ( concat ( transform ( Y1d , []( double y ) { return y * 0.5 ; }), transform ( Y1d , []( double y ) { return y * 0.75 ; })), Y1d ); std :: vector < double > z = concat ( concat ( transform ( Z1d , []( double z ) { return z * 0.5 ; }), transform ( Z1d , []( double z ) { return z * 0.75 ; })), Z1d ); return std :: make_tuple ( x , y , z ); } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto z = linspace ( 0 , 4 * pi , 250 ); auto x = transform ( z , []( double z ) { return 2 * cos ( z ) + rand ( 0 , 1 ); }); auto y = transform ( z , []( double z ) { return 2 * sin ( z ) + rand ( 0 , 1 ); }); scatter3 ( x , y , z , \"filled\" ); view ( -30 , 10 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto z = linspace ( 0 , 4 * pi , 250 ); auto x = transform ( z , []( double z ) { return 2 * cos ( z ) + rand ( 0 , 1 ); }); auto y = transform ( z , []( double z ) { return 2 * sin ( z ) + rand ( 0 , 1 ); }); scatter3 ( x , y , z , \"*\" ); view ( -30 , 10 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include <matplot/matplot.h> #include <random> #include <tuple> std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data (); int main () { using namespace matplot ; auto [ x , y , z ] = generate_data (); std :: vector < double > sizes ( x . size () / 3 , 16 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 8 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 2 ); std :: vector < double > colors ( x . size () / 3 , 1 ); std :: fill_n ( std :: back_inserter ( colors ), x . size () / 3 , 2 ); std :: fill_n ( std :: back_inserter ( colors ), x . size () / 3 , 3 ); scatter3 ( x , y , z , sizes , colors ) -> marker_face_color ({ 0 , .5 , .5 }); show (); return 0 ; } std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data () { using namespace matplot ; int n = 16 ; auto r = iota ( - n , 2. , n ); auto theta = transform ( r , [ n ]( double x ) { return x / n * pi ; }); auto phi = transform ( r , [ n ]( double x ) { return x / n * pi / 2. ; }); auto sinphi = transform ( phi , []( double x ) { return sin ( x ); }); auto cosphi = transform ( phi , []( double x ) { return cos ( x ); }); cosphi . front () = 0 ; cosphi . back () = 0 ; auto sintheta = transform ( theta , [ n ]( double x ) { return sin ( x ); }); sintheta . front () = 0 ; sintheta . back () = 0 ; auto costheta = transform ( theta , [ n ]( double x ) { return cos ( x ); }); std :: vector < std :: vector < double >> X ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Y ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Z ( 17 , std :: vector < double > ( 17 , 0. )); for ( int i = 0 ; i < n + 1 ; ++ i ) { for ( int j = 0 ; j < n + 1 ; ++ j ) { X [ i ][ j ] = cosphi [ i ] * costheta [ j ]; Y [ i ][ j ] = cosphi [ i ] * sintheta [ j ]; Z [ i ][ j ] = sinphi [ i ]; } } auto X1d = reshape ( X ); auto Y1d = reshape ( Y ); auto Z1d = reshape ( Z ); std :: vector < double > x = concat ( concat ( transform ( X1d , []( double x ) { return x * 0.5 ; }), transform ( X1d , []( double x ) { return x * 0.75 ; })), X1d ); std :: vector < double > y = concat ( concat ( transform ( Y1d , []( double y ) { return y * 0.5 ; }), transform ( Y1d , []( double y ) { return y * 0.75 ; })), Y1d ); std :: vector < double > z = concat ( concat ( transform ( Z1d , []( double z ) { return z * 0.5 ; }), transform ( Z1d , []( double z ) { return z * 0.75 ; })), Z1d ); return std :: make_tuple ( x , y , z ); }","title":"Scatter Plot 3D"},{"location":"plot-types/data-distribution/scatter-plot-3d/#scatter-plot-3d","text":"1 scatter ( x , y , z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include <matplot/matplot.h> #include <random> #include <tuple> std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data (); int main () { using namespace matplot ; auto [ x , y , z ] = generate_data (); scatter3 ( x , y , z ); show (); return 0 ; } std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data () { using namespace matplot ; int n = 16 ; auto r = iota ( static_cast < double > ( - n ), 2. , static_cast < double > ( n )); auto theta = transform ( r , [ n ]( double x ) { return x / n * pi ; }); auto phi = transform ( r , [ n ]( double x ) { return x / n * pi / 2. ; }); auto sinphi = transform ( phi , []( double x ) { return sin ( x ); }); auto cosphi = transform ( phi , []( double x ) { return cos ( x ); }); cosphi . front () = 0 ; cosphi . back () = 0 ; auto sintheta = transform ( theta , []( double x ) { return sin ( x ); }); sintheta . front () = 0 ; sintheta . back () = 0 ; auto costheta = transform ( theta , []( double x ) { return cos ( x ); }); std :: vector < std :: vector < double >> X ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Y ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Z ( 17 , std :: vector < double > ( 17 , 0. )); for ( int i = 0 ; i < n + 1 ; ++ i ) { for ( int j = 0 ; j < n + 1 ; ++ j ) { X [ i ][ j ] = cosphi [ i ] * costheta [ j ]; Y [ i ][ j ] = cosphi [ i ] * sintheta [ j ]; Z [ i ][ j ] = sinphi [ i ]; } } auto X1d = reshape ( X ); auto Y1d = reshape ( Y ); auto Z1d = reshape ( Z ); std :: vector < double > x = concat ( concat ( transform ( X1d , []( double x ) { return x * 0.5 ; }), transform ( X1d , []( double x ) { return x * 0.75 ; })), X1d ); std :: vector < double > y = concat ( concat ( transform ( Y1d , []( double y ) { return y * 0.5 ; }), transform ( Y1d , []( double y ) { return y * 0.75 ; })), Y1d ); std :: vector < double > z = concat ( concat ( transform ( Z1d , []( double z ) { return z * 0.5 ; }), transform ( Z1d , []( double z ) { return z * 0.75 ; })), Z1d ); return std :: make_tuple ( x , y , z ); } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <matplot/matplot.h> #include <random> #include <tuple> std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data (); int main () { using namespace matplot ; auto [ x , y , z ] = generate_data (); std :: vector < double > sizes ( x . size () / 3 , 16 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 8 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 2 ); scatter3 ( x , y , z , sizes ); view ( 40 , 35 ); show (); return 0 ; } std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data () { using namespace matplot ; int n = 16 ; auto r = iota ( - n , 2. , n ); auto theta = transform ( r , [ n ]( double x ) { return x / n * pi ; }); auto phi = transform ( r , [ n ]( double x ) { return x / n * pi / 2. ; }); auto sinphi = transform ( phi , []( double x ) { return sin ( x ); }); auto cosphi = transform ( phi , []( double x ) { return cos ( x ); }); cosphi . front () = 0 ; cosphi . back () = 0 ; auto sintheta = transform ( theta , [ n ]( double x ) { return sin ( x ); }); sintheta . front () = 0 ; sintheta . back () = 0 ; auto costheta = transform ( theta , [ n ]( double x ) { return cos ( x ); }); std :: vector < std :: vector < double >> X ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Y ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Z ( 17 , std :: vector < double > ( 17 , 0. )); for ( int i = 0 ; i < n + 1 ; ++ i ) { for ( int j = 0 ; j < n + 1 ; ++ j ) { X [ i ][ j ] = cosphi [ i ] * costheta [ j ]; Y [ i ][ j ] = cosphi [ i ] * sintheta [ j ]; Z [ i ][ j ] = sinphi [ i ]; } } auto X1d = reshape ( X ); auto Y1d = reshape ( Y ); auto Z1d = reshape ( Z ); std :: vector < double > x = concat ( concat ( transform ( X1d , []( double x ) { return x * 0.5 ; }), transform ( X1d , []( double x ) { return x * 0.75 ; })), X1d ); std :: vector < double > y = concat ( concat ( transform ( Y1d , []( double y ) { return y * 0.5 ; }), transform ( Y1d , []( double y ) { return y * 0.75 ; })), Y1d ); std :: vector < double > z = concat ( concat ( transform ( Z1d , []( double z ) { return z * 0.5 ; }), transform ( Z1d , []( double z ) { return z * 0.75 ; })), Z1d ); return std :: make_tuple ( x , y , z ); } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include <matplot/matplot.h> #include <random> #include <tuple> std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data (); int main () { using namespace matplot ; auto [ x , y , z ] = generate_data (); std :: vector < double > sizes ( x . size () / 3 , 16 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 8 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 2 ); std :: vector < double > colors ( x . size () / 3 , 1 ); std :: fill_n ( std :: back_inserter ( colors ), x . size () / 3 , 2 ); std :: fill_n ( std :: back_inserter ( colors ), x . size () / 3 , 3 ); scatter3 ( x , y , z , sizes , colors ); view ( 40 , 35 ); show (); return 0 ; } std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data () { using namespace matplot ; int n = 16 ; auto r = iota ( - n , 2. , n ); auto theta = transform ( r , [ n ]( double x ) { return x / n * pi ; }); auto phi = transform ( r , [ n ]( double x ) { return x / n * pi / 2. ; }); auto sinphi = transform ( phi , []( double x ) { return sin ( x ); }); auto cosphi = transform ( phi , []( double x ) { return cos ( x ); }); cosphi . front () = 0 ; cosphi . back () = 0 ; auto sintheta = transform ( theta , [ n ]( double x ) { return sin ( x ); }); sintheta . front () = 0 ; sintheta . back () = 0 ; auto costheta = transform ( theta , [ n ]( double x ) { return cos ( x ); }); std :: vector < std :: vector < double >> X ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Y ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Z ( 17 , std :: vector < double > ( 17 , 0. )); for ( int i = 0 ; i < n + 1 ; ++ i ) { for ( int j = 0 ; j < n + 1 ; ++ j ) { X [ i ][ j ] = cosphi [ i ] * costheta [ j ]; Y [ i ][ j ] = cosphi [ i ] * sintheta [ j ]; Z [ i ][ j ] = sinphi [ i ]; } } auto X1d = reshape ( X ); auto Y1d = reshape ( Y ); auto Z1d = reshape ( Z ); std :: vector < double > x = concat ( concat ( transform ( X1d , []( double x ) { return x * 0.5 ; }), transform ( X1d , []( double x ) { return x * 0.75 ; })), X1d ); std :: vector < double > y = concat ( concat ( transform ( Y1d , []( double y ) { return y * 0.5 ; }), transform ( Y1d , []( double y ) { return y * 0.75 ; })), Y1d ); std :: vector < double > z = concat ( concat ( transform ( Z1d , []( double z ) { return z * 0.5 ; }), transform ( Z1d , []( double z ) { return z * 0.75 ; })), Z1d ); return std :: make_tuple ( x , y , z ); } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto z = linspace ( 0 , 4 * pi , 250 ); auto x = transform ( z , []( double z ) { return 2 * cos ( z ) + rand ( 0 , 1 ); }); auto y = transform ( z , []( double z ) { return 2 * sin ( z ) + rand ( 0 , 1 ); }); scatter3 ( x , y , z , \"filled\" ); view ( -30 , 10 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> #include <random> #include <tuple> int main () { using namespace matplot ; auto z = linspace ( 0 , 4 * pi , 250 ); auto x = transform ( z , []( double z ) { return 2 * cos ( z ) + rand ( 0 , 1 ); }); auto y = transform ( z , []( double z ) { return 2 * sin ( z ) + rand ( 0 , 1 ); }); scatter3 ( x , y , z , \"*\" ); view ( -30 , 10 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 #include <matplot/matplot.h> #include <random> #include <tuple> std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data (); int main () { using namespace matplot ; auto [ x , y , z ] = generate_data (); std :: vector < double > sizes ( x . size () / 3 , 16 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 8 ); std :: fill_n ( std :: back_inserter ( sizes ), x . size () / 3 , 2 ); std :: vector < double > colors ( x . size () / 3 , 1 ); std :: fill_n ( std :: back_inserter ( colors ), x . size () / 3 , 2 ); std :: fill_n ( std :: back_inserter ( colors ), x . size () / 3 , 3 ); scatter3 ( x , y , z , sizes , colors ) -> marker_face_color ({ 0 , .5 , .5 }); show (); return 0 ; } std :: tuple < std :: vector < double > , std :: vector < double > , std :: vector < double >> generate_data () { using namespace matplot ; int n = 16 ; auto r = iota ( - n , 2. , n ); auto theta = transform ( r , [ n ]( double x ) { return x / n * pi ; }); auto phi = transform ( r , [ n ]( double x ) { return x / n * pi / 2. ; }); auto sinphi = transform ( phi , []( double x ) { return sin ( x ); }); auto cosphi = transform ( phi , []( double x ) { return cos ( x ); }); cosphi . front () = 0 ; cosphi . back () = 0 ; auto sintheta = transform ( theta , [ n ]( double x ) { return sin ( x ); }); sintheta . front () = 0 ; sintheta . back () = 0 ; auto costheta = transform ( theta , [ n ]( double x ) { return cos ( x ); }); std :: vector < std :: vector < double >> X ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Y ( 17 , std :: vector < double > ( 17 , 0. )); std :: vector < std :: vector < double >> Z ( 17 , std :: vector < double > ( 17 , 0. )); for ( int i = 0 ; i < n + 1 ; ++ i ) { for ( int j = 0 ; j < n + 1 ; ++ j ) { X [ i ][ j ] = cosphi [ i ] * costheta [ j ]; Y [ i ][ j ] = cosphi [ i ] * sintheta [ j ]; Z [ i ][ j ] = sinphi [ i ]; } } auto X1d = reshape ( X ); auto Y1d = reshape ( Y ); auto Z1d = reshape ( Z ); std :: vector < double > x = concat ( concat ( transform ( X1d , []( double x ) { return x * 0.5 ; }), transform ( X1d , []( double x ) { return x * 0.75 ; })), X1d ); std :: vector < double > y = concat ( concat ( transform ( Y1d , []( double y ) { return y * 0.5 ; }), transform ( Y1d , []( double y ) { return y * 0.75 ; })), Y1d ); std :: vector < double > z = concat ( concat ( transform ( Z1d , []( double z ) { return z * 0.5 ; }), transform ( Z1d , []( double z ) { return z * 0.75 ; })), Z1d ); return std :: make_tuple ( x , y , z ); }","title":"Scatter Plot 3D"},{"location":"plot-types/data-distribution/scatter-plot/","text":"Scatter Plot 1 scatter ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); scatter ( x , y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); auto c = linspace ( 1 , 10 , x . size ()); scatter ( x , y , c ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); auto c = linspace ( 1 , 10 , x . size ()); scatter ( x , y , std :: vector < double > {}, c ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); auto c = linspace ( 1 , 10 , x . size ()); auto l = scatter ( x , y , 6 , c ); l -> marker_face ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto theta = linspace ( 0 , 2 * pi , 150 ); auto x = transform ( theta , [ & ]( double t ) { return sin ( t ) + 0.75 * rand ( 0 , 1 ); }); auto y = transform ( theta , [ & ]( double t ) { return cos ( t ) + 0.75 * rand ( 0 , 1 ); }); double sz = 23 ; auto l = scatter ( x , y , sz ); l -> marker_style ( line_spec :: marker_style :: diamond ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto theta = linspace ( 0 , 2 * pi , 300 ); auto x = transform ( theta , [ & ]( double t ) { return sin ( t ) + 0.75 * rand ( 0 , 1 ); }); auto y = transform ( theta , [ & ]( double t ) { return cos ( t ) + 0.75 * rand ( 0 , 1 ); }); double sz = 6 ; auto l = scatter ( x , y , sz ); l -> marker_color ({ 0 , .5 , .5 }); l -> marker_face_color ({ 0 , .7 , .7 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); scatter ( ax1 , x , y ); auto ax2 = nexttile (); auto l = scatter ( ax2 , x , y ); l -> marker_face ( true ); l -> marker_style ( line_spec :: marker_style :: diamond ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto theta = linspace ( 0 , 1 , 500 ); auto x = transform ( theta , [ & ]( double theta ) { return exp ( theta ) * sin ( 100 * theta ); }); auto y = transform ( theta , [ & ]( double theta ) { return exp ( theta ) * cos ( 100 * theta ); }); auto s = scatter ( x , y ); s -> marker_color ( \"b\" ); s -> marker_face_color ({ 0 , .5 , .5 }); show (); return 0 ; } Scatter plots also depend on the line object. As the line object can represent lines with markers, the scatter function simply creates markers without the lines.","title":"Scatter Plot"},{"location":"plot-types/data-distribution/scatter-plot/#scatter-plot","text":"1 scatter ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); scatter ( x , y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); auto c = linspace ( 1 , 10 , x . size ()); scatter ( x , y , c ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); auto c = linspace ( 1 , 10 , x . size ()); scatter ( x , y , std :: vector < double > {}, c ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); auto c = linspace ( 1 , 10 , x . size ()); auto l = scatter ( x , y , 6 , c ); l -> marker_face ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto theta = linspace ( 0 , 2 * pi , 150 ); auto x = transform ( theta , [ & ]( double t ) { return sin ( t ) + 0.75 * rand ( 0 , 1 ); }); auto y = transform ( theta , [ & ]( double t ) { return cos ( t ) + 0.75 * rand ( 0 , 1 ); }); double sz = 23 ; auto l = scatter ( x , y , sz ); l -> marker_style ( line_spec :: marker_style :: diamond ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto theta = linspace ( 0 , 2 * pi , 300 ); auto x = transform ( theta , [ & ]( double t ) { return sin ( t ) + 0.75 * rand ( 0 , 1 ); }); auto y = transform ( theta , [ & ]( double t ) { return cos ( t ) + 0.75 * rand ( 0 , 1 ); }); double sz = 6 ; auto l = scatter ( x , y , sz ); l -> marker_color ({ 0 , .5 , .5 }); l -> marker_face_color ({ 0 , .7 , .7 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto x = linspace ( 0 , 3 * pi , 200 ); auto y = transform ( x , [ & ]( double x ) { return cos ( x ) + rand ( 0 , 1 ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); scatter ( ax1 , x , y ); auto ax2 = nexttile (); auto l = scatter ( ax2 , x , y ); l -> marker_face ( true ); l -> marker_style ( line_spec :: marker_style :: diamond ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto theta = linspace ( 0 , 1 , 500 ); auto x = transform ( theta , [ & ]( double theta ) { return exp ( theta ) * sin ( 100 * theta ); }); auto y = transform ( theta , [ & ]( double theta ) { return exp ( theta ) * cos ( 100 * theta ); }); auto s = scatter ( x , y ); s -> marker_color ( \"b\" ); s -> marker_face_color ({ 0 , .5 , .5 }); show (); return 0 ; } Scatter plots also depend on the line object. As the line object can represent lines with markers, the scatter function simply creates markers without the lines.","title":"Scatter Plot"},{"location":"plot-types/data-distribution/word-cloud/","text":"Word Cloud 1 wordcloud ( text , black_list ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: string text = fileread ( \"shakespeare_sonnets.txt\" ); std :: transform ( text . begin (), text . end (), text . begin (), :: tolower ); std :: vector < std :: string > black_list = tokenize ( fileread ( \"en_blacklist.txt\" )); wordcloud ( text , black_list ); title ( \"Shakespeare's sonnets\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: string text = fileread ( \"shakespeare_sonnets.txt\" ); std :: transform ( text . begin (), text . end (), text . begin (), :: tolower ); std :: vector < std :: string > black_list = tokenize ( fileread ( \"en_blacklist.txt\" )); std :: vector < std :: string > text_tokens = tokenize ( text ); auto it = std :: remove_if ( text_tokens . begin (), text_tokens . end (), []( const std :: string & s ) { return s . size () < 5 ; }); text_tokens . erase ( it , text_tokens . end ()); auto [ tokens , count ] = wordcount ( text_tokens , black_list ); wordcloud ( tokens , count ); title ( \"Shakespeare's sonnets - Big words\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: string text = fileread ( \"shakespeare_sonnets.txt\" ); std :: transform ( text . begin (), text . end (), text . begin (), :: tolower ); std :: vector < std :: string > black_list = tokenize ( fileread ( \"en_blacklist.txt\" )); auto [ tokens , count ] = wordcount ( text , black_list ); std :: vector < double > custom_colors = rand ( tokens . size (), 0. , 100. ); wordcloud ( tokens , count , custom_colors ); title ( \"Shakespeare's sonnets - Random colors\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: string text = fileread ( \"shakespeare_sonnets.txt\" ); std :: transform ( text . begin (), text . end (), text . begin (), :: tolower ); std :: vector < std :: string > black_list = tokenize ( fileread ( \"en_blacklist.txt\" )); auto [ tokens , count ] = wordcount ( text , black_list ); std :: vector < double > custom_colors = rand ( tokens . size (), 0. , 100. ); wordcloud ( tokens , count , custom_colors ); title ( \"Shakespeare's sonnets - Random colors\" ); show (); return 0 ; } Word clouds are generated from text or pairs of words and their frequency. After attributing a size proportional to each word frequency, the algorithm to position the labels iterates words from the largest to the smallest. For each word, it spins the word in polar coordinates converted to Cartesian coordinates until it does not overlap with any other word. By default, the colors and the sizes depend on the word frequencies. We can customize the colors by passing a third parameter to the wordcloud function.","title":"Word Cloud"},{"location":"plot-types/data-distribution/word-cloud/#word-cloud","text":"1 wordcloud ( text , black_list ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: string text = fileread ( \"shakespeare_sonnets.txt\" ); std :: transform ( text . begin (), text . end (), text . begin (), :: tolower ); std :: vector < std :: string > black_list = tokenize ( fileread ( \"en_blacklist.txt\" )); wordcloud ( text , black_list ); title ( \"Shakespeare's sonnets\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: string text = fileread ( \"shakespeare_sonnets.txt\" ); std :: transform ( text . begin (), text . end (), text . begin (), :: tolower ); std :: vector < std :: string > black_list = tokenize ( fileread ( \"en_blacklist.txt\" )); std :: vector < std :: string > text_tokens = tokenize ( text ); auto it = std :: remove_if ( text_tokens . begin (), text_tokens . end (), []( const std :: string & s ) { return s . size () < 5 ; }); text_tokens . erase ( it , text_tokens . end ()); auto [ tokens , count ] = wordcount ( text_tokens , black_list ); wordcloud ( tokens , count ); title ( \"Shakespeare's sonnets - Big words\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: string text = fileread ( \"shakespeare_sonnets.txt\" ); std :: transform ( text . begin (), text . end (), text . begin (), :: tolower ); std :: vector < std :: string > black_list = tokenize ( fileread ( \"en_blacklist.txt\" )); auto [ tokens , count ] = wordcount ( text , black_list ); std :: vector < double > custom_colors = rand ( tokens . size (), 0. , 100. ); wordcloud ( tokens , count , custom_colors ); title ( \"Shakespeare's sonnets - Random colors\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: string text = fileread ( \"shakespeare_sonnets.txt\" ); std :: transform ( text . begin (), text . end (), text . begin (), :: tolower ); std :: vector < std :: string > black_list = tokenize ( fileread ( \"en_blacklist.txt\" )); auto [ tokens , count ] = wordcount ( text , black_list ); std :: vector < double > custom_colors = rand ( tokens . size (), 0. , 100. ); wordcloud ( tokens , count , custom_colors ); title ( \"Shakespeare's sonnets - Random colors\" ); show (); return 0 ; } Word clouds are generated from text or pairs of words and their frequency. After attributing a size proportional to each word frequency, the algorithm to position the labels iterates words from the largest to the smallest. For each word, it spins the word in polar coordinates converted to Cartesian coordinates until it does not overlap with any other word. By default, the colors and the sizes depend on the word frequencies. We can customize the colors by passing a third parameter to the wordcloud function.","title":"Word Cloud"},{"location":"plot-types/discrete-data/bar-plot/","text":"Bar Plot 1 bar ( y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = iota ( 1900 , 10 , 2000 ); std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( x , y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( y , 0.4 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 2 , 2 , 2 , 2 }, { 2 , 5 , 8 , 11 }, { 3 , 6 , 9 , 12 }}; bar ( Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 2 , 2 , 2 , 2 }, { 2 , 5 , 8 , 11 }, { 3 , 6 , 9 , 12 }}; barstacked ( Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = { 1980 , 1990 , 2000 }; std :: vector < std :: vector < double >> Y = { { 15 , 10 , -10 }, { 20 , -17 , 5 }, { -5 , 21 , 15 }}; barstacked ( x , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 10 , 21 , 33 , 52 }; bar ( y ); gca () -> x_axis (). ticklabels ({ \"Small\" , \"Medium\" , \"Large\" , \"Extra Large\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = { 1 , 2 , 3 }; std :: vector < std :: vector < double >> y = {{ 2 , 3 , 6 }, { 11 , 23 , 26 }}; auto b = bar ( x , y ); std :: vector < double > label_x ; std :: vector < double > label_y ; std :: vector < std :: string > labels ; for ( size_t i = 0 ; i < y . size (); ++ i ) { for ( size_t j = 0 ; j < x . size (); ++ j ) { label_x . emplace_back ( b -> x_end_point ( i , j )); label_y . emplace_back ( y [ i ][ j ] + 1 ); labels . emplace_back ( num2str ( y [ i ][ j ])); } } hold ( on ); text ( label_x , label_y , labels ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> y = {{ 1 , 4 }, { 2 , 5 }, { 3 , 6 }}; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); bar ( ax1 , y ); auto ax2 = nexttile (); barstacked ( ax2 , y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( y ) -> face_color ( \"r\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( y ) -> face_color ({ 0 , .5 , .5 }). edge_color ({ 0 , .9 , .9 }). line_width ( 1.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x1 = concat ({ 1 }, iota ( 3 , 10 )); bar ( x1 , rand ( 9 , 0 , 1 )); hold ( on ); bar ( std :: vector < double > { 2 }, rand ( 1 , 0 , 1 )); gca () -> x_axis (). tick_values ( iota ( 1 , 10 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> y = { { 10 , 30 , 50 }, { 15 , 35 , 55 }, { 20 , 40 , 62 }}; auto b = bar ( y ); b -> face_colors ()[ 2 ] = { 0. , .2 , .6 , .5 }; gcf () -> draw (); show (); return 0 ; }","title":"Bar Plot"},{"location":"plot-types/discrete-data/bar-plot/#bar-plot","text":"1 bar ( y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = iota ( 1900 , 10 , 2000 ); std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( x , y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( y , 0.4 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 2 , 2 , 2 , 2 }, { 2 , 5 , 8 , 11 }, { 3 , 6 , 9 , 12 }}; bar ( Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 2 , 2 , 2 , 2 }, { 2 , 5 , 8 , 11 }, { 3 , 6 , 9 , 12 }}; barstacked ( Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = { 1980 , 1990 , 2000 }; std :: vector < std :: vector < double >> Y = { { 15 , 10 , -10 }, { 20 , -17 , 5 }, { -5 , 21 , 15 }}; barstacked ( x , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 10 , 21 , 33 , 52 }; bar ( y ); gca () -> x_axis (). ticklabels ({ \"Small\" , \"Medium\" , \"Large\" , \"Extra Large\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x = { 1 , 2 , 3 }; std :: vector < std :: vector < double >> y = {{ 2 , 3 , 6 }, { 11 , 23 , 26 }}; auto b = bar ( x , y ); std :: vector < double > label_x ; std :: vector < double > label_y ; std :: vector < std :: string > labels ; for ( size_t i = 0 ; i < y . size (); ++ i ) { for ( size_t j = 0 ; j < x . size (); ++ j ) { label_x . emplace_back ( b -> x_end_point ( i , j )); label_y . emplace_back ( y [ i ][ j ] + 1 ); labels . emplace_back ( num2str ( y [ i ][ j ])); } } hold ( on ); text ( label_x , label_y , labels ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> y = {{ 1 , 4 }, { 2 , 5 }, { 3 , 6 }}; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); bar ( ax1 , y ); auto ax2 = nexttile (); barstacked ( ax2 , y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( y ) -> face_color ( \"r\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 75 , 91 , 105 , 123.5 , 131 , 150 , 179 , 203 , 226 , 249 , 281.5 }; bar ( y ) -> face_color ({ 0 , .5 , .5 }). edge_color ({ 0 , .9 , .9 }). line_width ( 1.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > x1 = concat ({ 1 }, iota ( 3 , 10 )); bar ( x1 , rand ( 9 , 0 , 1 )); hold ( on ); bar ( std :: vector < double > { 2 }, rand ( 1 , 0 , 1 )); gca () -> x_axis (). tick_values ( iota ( 1 , 10 )); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < std :: vector < double >> y = { { 10 , 30 , 50 }, { 15 , 35 , 55 }, { 20 , 40 , 62 }}; auto b = bar ( y ); b -> face_colors ()[ 2 ] = { 0. , .2 , .6 , .5 }; gcf () -> draw (); show (); return 0 ; }","title":"Bar Plot"},{"location":"plot-types/discrete-data/pareto-chart/","text":"Pareto Chart 1 pareto ( y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 90 , 75 , 30 , 60 , 5 , 40 , 40 , 5 }; pareto ( y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > codelines = { 200 , 120 , 555 , 608 , 1024 , 101 , 57 , 687 }; std :: vector < std :: string > coders = { \"Fred\" , \"Ginger\" , \"Norman\" , \"Max\" , \"Julia\" , \"Wally\" , \"Heidi\" , \"Pat\" }; pareto ( codelines , coders ); title ( \"Lines of Code by Programmer\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > votes = { 35 , 50 , 30 , 5 , 80 }; std :: vector < std :: string > pies = { \"Chocolate\" , \"Apple\" , \"Pecan\" , \"Cherry\" , \"Pumpkin\" }; pareto ( votes , pies , 1.0 ); ylabel ( \"Votes\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 10 , 23 , 7 , 16 , 3 }; pareto ( y ); show (); return 0 ; } Pareto Charts are a type of chart that uses both axes. The axis is used to represent bars with the data values in descending order. The axis is used to represent the cumulative distribution function of the data in the axis. By default, a Pareto Chart includes up to 10 items or as many items as needed to represent 95% of the cumulative distribution. If you need Pareto fronts rather than Pareto charts , we refer to Scatter Plots for two-dimensional fronts, Plot matrices for three-dimensional fronts, or Parallel Coordinate Plots for many-objective fronts. These plot subcategories are described in Section Data Distribution . If you also need a tool to calculate these fronts efficiently, we refer to the Pareto Front Library .","title":"Pareto Chart"},{"location":"plot-types/discrete-data/pareto-chart/#pareto-chart","text":"1 pareto ( y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 90 , 75 , 30 , 60 , 5 , 40 , 40 , 5 }; pareto ( y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > codelines = { 200 , 120 , 555 , 608 , 1024 , 101 , 57 , 687 }; std :: vector < std :: string > coders = { \"Fred\" , \"Ginger\" , \"Norman\" , \"Max\" , \"Julia\" , \"Wally\" , \"Heidi\" , \"Pat\" }; pareto ( codelines , coders ); title ( \"Lines of Code by Programmer\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > votes = { 35 , 50 , 30 , 5 , 80 }; std :: vector < std :: string > pies = { \"Chocolate\" , \"Apple\" , \"Pecan\" , \"Cherry\" , \"Pumpkin\" }; pareto ( votes , pies , 1.0 ); ylabel ( \"Votes\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: vector < double > y = { 10 , 23 , 7 , 16 , 3 }; pareto ( y ); show (); return 0 ; } Pareto Charts are a type of chart that uses both axes. The axis is used to represent bars with the data values in descending order. The axis is used to represent the cumulative distribution function of the data in the axis. By default, a Pareto Chart includes up to 10 items or as many items as needed to represent 95% of the cumulative distribution. If you need Pareto fronts rather than Pareto charts , we refer to Scatter Plots for two-dimensional fronts, Plot matrices for three-dimensional fronts, or Parallel Coordinate Plots for many-objective fronts. These plot subcategories are described in Section Data Distribution . If you also need a tool to calculate these fronts efficiently, we refer to the Pareto Front Library .","title":"Pareto Chart"},{"location":"plot-types/discrete-data/stem-plot-3d/","text":"Stem Plot 3D 1 stem3 ( z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi / 2 , pi / 2 , 40 ); auto z = transform ( x , []( auto x ) { return cos ( x ); }); stem3 ( z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x ( 40 , 1. ); std :: vector < double > y = linspace ( - pi / 2 , pi / 2 , 40 ); auto z = transform ( y , []( auto x ) { return cos ( x ); }); stem3 ( x , y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi / 2 , pi / 2 , 40 ); std :: vector < std :: vector < double >> Z ( 2 ); Z [ 0 ] = transform ( x , []( auto x ) { return sin ( x ); }); Z [ 1 ] = transform ( x , []( auto x ) { return cos ( x ); }); stem3 ( Z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -5 , + 5 , 60 ); std :: vector < double > y = transform ( x , []( double x ) { return cos ( x ); }); std :: vector < double > z = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem3 ( x , y , z ); view ( -8 , 30 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > grid_ticks = iota ( 0 , .1 , 1 ); std :: vector < double > x ; std :: vector < double > y ; std :: vector < double > z ; for ( const auto & x_i : grid_ticks ) { for ( const auto & y_i : grid_ticks ) { x . emplace_back ( x_i ); y . emplace_back ( y_i ); z . emplace_back ( exp ( x_i + y_i )); } } stem3 ( x , y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi , pi , 40 ); std :: vector < double > z = transform ( x , []( double x ) { return cos ( x ); }); stem3 ( z , \"filled\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi , pi , 40 ); std :: vector < double > z = transform ( x , []( double x ) { return cos ( x ); }); stem3 ( z , \"--*m\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi ); std :: vector < double > x = transform ( theta , []( double t ) { return cos ( t ); }); std :: vector < double > y = transform ( theta , []( double t ) { return sin ( t ); }); std :: vector < double > z = theta ; stem3 ( x , y , z , \":*m\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi , pi , 40 ); std :: vector < double > z = transform ( x , []( double x ) { return cos ( x ); }); stem3 ( z ) -> marker ( \"s\" ). marker_color ( \"m\" ). marker_face_color ( \"g\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -2 , + 2 , 50 ); std :: vector < double > y = transform ( x , []( double x ) { return pow ( x , 3 ); }); std :: vector < double > z = transform ( x , []( double x ) { return exp ( x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); stem ( ax1 , x , z ); auto ax2 = nexttile (); stem3 ( ax2 , x , y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , + 2 ); std :: vector < double > y = transform ( x , []( double x ) { return pow ( x , 3 ); }); std :: vector < double > z = transform ( x , y , []( double x , double y ) { return exp ( x ) * cos ( y ); }); stem3 ( x , y , z , \"filled\" ) -> color ( \"m\" ). marker_face_color ( \"y\" ); view ( -10 , 35 ); show (); return 0 ; }","title":"Stem Plot 3D"},{"location":"plot-types/discrete-data/stem-plot-3d/#stem-plot-3d","text":"1 stem3 ( z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi / 2 , pi / 2 , 40 ); auto z = transform ( x , []( auto x ) { return cos ( x ); }); stem3 ( z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x ( 40 , 1. ); std :: vector < double > y = linspace ( - pi / 2 , pi / 2 , 40 ); auto z = transform ( y , []( auto x ) { return cos ( x ); }); stem3 ( x , y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi / 2 , pi / 2 , 40 ); std :: vector < std :: vector < double >> Z ( 2 ); Z [ 0 ] = transform ( x , []( auto x ) { return sin ( x ); }); Z [ 1 ] = transform ( x , []( auto x ) { return cos ( x ); }); stem3 ( Z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -5 , + 5 , 60 ); std :: vector < double > y = transform ( x , []( double x ) { return cos ( x ); }); std :: vector < double > z = transform ( x , []( double x ) { return pow ( x , 2 ); }); stem3 ( x , y , z ); view ( -8 , 30 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > grid_ticks = iota ( 0 , .1 , 1 ); std :: vector < double > x ; std :: vector < double > y ; std :: vector < double > z ; for ( const auto & x_i : grid_ticks ) { for ( const auto & y_i : grid_ticks ) { x . emplace_back ( x_i ); y . emplace_back ( y_i ); z . emplace_back ( exp ( x_i + y_i )); } } stem3 ( x , y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi , pi , 40 ); std :: vector < double > z = transform ( x , []( double x ) { return cos ( x ); }); stem3 ( z , \"filled\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi , pi , 40 ); std :: vector < double > z = transform ( x , []( double x ) { return cos ( x ); }); stem3 ( z , \"--*m\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi ); std :: vector < double > x = transform ( theta , []( double t ) { return cos ( t ); }); std :: vector < double > y = transform ( theta , []( double t ) { return sin ( t ); }); std :: vector < double > z = theta ; stem3 ( x , y , z , \":*m\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi , pi , 40 ); std :: vector < double > z = transform ( x , []( double x ) { return cos ( x ); }); stem3 ( z ) -> marker ( \"s\" ). marker_color ( \"m\" ). marker_face_color ( \"g\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -2 , + 2 , 50 ); std :: vector < double > y = transform ( x , []( double x ) { return pow ( x , 3 ); }); std :: vector < double > z = transform ( x , []( double x ) { return exp ( x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); stem ( ax1 , x , z ); auto ax2 = nexttile (); stem3 ( ax2 , x , y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , + 2 ); std :: vector < double > y = transform ( x , []( double x ) { return pow ( x , 3 ); }); std :: vector < double > z = transform ( x , y , []( double x , double y ) { return exp ( x ) * cos ( y ); }); stem3 ( x , y , z , \"filled\" ) -> color ( \"m\" ). marker_face_color ( \"y\" ); view ( -10 , 35 ); show (); return 0 ; }","title":"Stem Plot 3D"},{"location":"plot-types/discrete-data/stem-plot/","text":"Stem Plot 1 stem ( Y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( x , []( auto x ) { return cos ( x ); }); Y [ 1 ] = transform ( x , []( auto x ) { return 0.5 * sin ( x ); }); stem ( Y , \"-o\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < double > y = transform ( x , []( auto x ) { return cos ( x ); }); stem ( x , y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( x , []( auto x ) { return cos ( x ); }); Y [ 1 ] = transform ( x , []( auto x ) { return 0.5 * sin ( x ); }); stem ( x , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x1 = linspace ( 0 , 2 * pi , 50 ); std :: vector < double > y1 = transform ( x1 , []( auto x ) { return cos ( x ); }); std :: vector < double > x2 = linspace ( pi , 3 * pi , 50 ); std :: vector < double > y2 = transform ( x2 , []( auto x ) { return 0.5 * sin ( x ); }); stem ( x1 , y1 ); hold ( on ); stem ( x2 , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 , 20 ); std :: vector < double > y = transform ( x , []( auto x ) { return exp ( 0.25 * x ); }); stem ( x , y , \"filled\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < double > y = transform ( x , []( auto x ) { return exp ( x ) * sin ( x ); }); stem ( x , y , \":dr\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 25 ); std :: vector < double > y = transform ( x , []( auto x ) { return cos ( 2 * x ); }); auto s = stem ( x , y ) -> line_style ( \"-.\" ). marker_face_color ( \"red\" ). marker_color ( \"green\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 25 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return exp ( 0.1 * x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return - exp ( 0.05 * x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); stem ( ax1 , x , y1 ); auto ax2 = nexttile (); stem ( ax2 , x , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < double > y = transform ( x , []( auto x ) { return exp ( 0.3 * x ) * sin ( 3 * x ); }); stem ( x , y ); gca () -> x_axis (). zero_axis ( false ); show (); return 0 ; }","title":"Stem Plot"},{"location":"plot-types/discrete-data/stem-plot/#stem-plot","text":"1 stem ( Y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( x , []( auto x ) { return cos ( x ); }); Y [ 1 ] = transform ( x , []( auto x ) { return 0.5 * sin ( x ); }); stem ( Y , \"-o\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < double > y = transform ( x , []( auto x ) { return cos ( x ); }); stem ( x , y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( x , []( auto x ) { return cos ( x ); }); Y [ 1 ] = transform ( x , []( auto x ) { return 0.5 * sin ( x ); }); stem ( x , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x1 = linspace ( 0 , 2 * pi , 50 ); std :: vector < double > y1 = transform ( x1 , []( auto x ) { return cos ( x ); }); std :: vector < double > x2 = linspace ( pi , 3 * pi , 50 ); std :: vector < double > y2 = transform ( x2 , []( auto x ) { return 0.5 * sin ( x ); }); stem ( x1 , y1 ); hold ( on ); stem ( x2 , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 , 20 ); std :: vector < double > y = transform ( x , []( auto x ) { return exp ( 0.25 * x ); }); stem ( x , y , \"filled\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < double > y = transform ( x , []( auto x ) { return exp ( x ) * sin ( x ); }); stem ( x , y , \":dr\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 25 ); std :: vector < double > y = transform ( x , []( auto x ) { return cos ( 2 * x ); }); auto s = stem ( x , y ) -> line_style ( \"-.\" ). marker_face_color ( \"red\" ). marker_color ( \"green\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 25 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return exp ( 0.1 * x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return - exp ( 0.05 * x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); stem ( ax1 , x , y1 ); auto ax2 = nexttile (); stem ( ax2 , x , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi , 50 ); std :: vector < double > y = transform ( x , []( auto x ) { return exp ( 0.3 * x ) * sin ( 3 * x ); }); stem ( x , y ); gca () -> x_axis (). zero_axis ( false ); show (); return 0 ; }","title":"Stem Plot"},{"location":"plot-types/geography/geobubble/","text":"Geobubble 1 geobubble ( lat , lon , sizes ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > tsunami_lon = { 128.3 , -156 , 157.95 , 143.85 , -155 , -82.4 , 159.5 , 156.5 , 147.4 , 178.2 , 141.7 , -86.883 , -32.283 , -72 , 23 , -175.629 , 137 , -99 , -79.5 , 104 , -136.52 , 148.54 , 148.8 , 159.8 , 156 , -111.215 , -72.75 , 143.4 , 143.7 , -74.5 , -80.7 , 147.9 , 168.5 , 160.5 , 142.8 , 22.05 , 149.54 , 150.1 , -176.6 , -147.5 , 139.2 , 178.55 , 22.4 , 167.2 , 167.6 , 160.8 , -78.8 , -70.6 , 166.5 , 164.8 , 166.8 , 97.3 , -79.8 , 24.9 , 132.5 , 143.2 , 143.1 , 119.8 , -92.6 , 118.9 , 147.9 , 163.6 , 121.7 , -78.8 , 145.5 , -71.2 , 153.9 , 153.2 , 141.2 , 146.6 , 147 , -103 , 156.6 , 145.8 , 155.9 , 155.6 , -77.79 , -128.633 , -17.649 , 147.734 , 155.054 , 125.993 , -155.024 , 124.023 , 118.464 , -78.52 , 142.03 , -96.591 , -101.276 , 136.04 , 7.25 , -79.358 , -122.18 , 142.361 , 127.924 , 139.102 , 139.099 , 72.11 , -71.871 , 114.185 , 152.828 , -102.533 , -101.647 , -174.776 , 147.689 , 14.97 , 121.013 , -83.073 , -124.316 , -87.34 , 121.896 , 139.197 , 144.801 , 127.733 , 112.835 , 112.892 , 133.366 , 152.214 , 147.321 , 127.98 , -135.3 , 121.067 , 143.419 , 125.127 , -70.294 , -104.205 , 130.175 , 130.148 , 149.3 , 119.931 , 22.083 , 159.318 , 136.952 , -79.587 , 131.468 , 166.676 , 162.035 , 162.035 , -62.18 , 141.926 , 124.891 , -62.18 , 29.864 , 168.214 , 120.15 , 123.573 , -120.65 , 152.169 , -73.641 , 167.856 , 124.249 , 142.945 , 134.297 , 3.634 , -62.18 , 143.91 , 95.982 , 97.108 , 127.214 , -62.18 , 107.411 , 153.266 }; std :: vector < double > tsunami_lat = { -3.8 , 19.5 , -9.02 , 42.15 , 19.1 , 43.1 , 52.75 , 50 , -2.4 , -18.3 , 34 , 41.7 , 67.8 , -30 , 39.5 , 51.292 , -1.5 , 16.5 , 1.2 , -4.5 , 58.34 , 44.53 , 44.2 , 53.4 , -7.5 , 44.712 , -15.75 , 39.8 , 39.4 , -39.5 , -6.8 , 43.2 , -18.5 , -9.9 , 38 , 38.42 , 44.81 , 44.1 , -24.8 , 61.1 , 38.65 , 51.29 , 38.4 , -15.8 , -15.9 , -10.3 , -10.7 , -25.5 , -11.8 , -11.3 , -11.8 , 5.5 , -10.6 , 39.4 , 32.3 , 40.8 , 39.4 , 0.2 , 15.6 , -3.1 , 43.6 , 57.7 , 15.8 , -9.2 , -4.9 , -32.5 , -5.5 , -4.9 , 46.5 , -6.5 , -6.7 , 18.48 , 50.5 , 43.2 , -7.5 , -7.4 , -12.27 , 54.083 , 35.997 , 43.024 , -6.59 , 12.54 , 19.334 , 6.262 , -11.085 , -10.233 , 38.19 , 16.01 , 17.813 , -1.679 , 43.7 , 1.598 , 46.2 , 42.158 , -4.056 , 40.462 , 41.346 , -6.852 , -33.135 , -9.245 , -4.439 , 18.19 , 17.802 , 51.52 , -6.088 , 38.41 , 18.606 , 9.685 , 40.368 , 11.742 , -8.48 , 42.851 , 12.982 , 1.015 , -10.477 , -10.362 , -10.777 , -4.238 , 43.773 , -1.258 , 59.5 , 13.525 , 40.525 , -8.378 , -23.34 , 19.055 , 27.929 , 28.094 , 44.663 , 0.729 , 38.367 , 54.45 , -0.891 , -9.593 , 31.885 , -12.584 , 54.841 , 54.841 , 16.72 , -2.961 , -2.071 , 16.722 , 40.748 , -16.423 , 5.1 , -1.105 , 34.5 , -3.98 , -16.265 , -17.6 , 6.033 , -3.302 , -1.757 , 36.964 , 16.722 , 41.815 , 3.295 , 2.085 , -3.595 , 16.722 , -9.254 , 46.592 }; std :: vector < double > tsunami_height = { 2.8 , 3.6 , 6 , 6.5 , 1 , 1.52 , 18 , 1.5 , 1.4 , 3 , 3 , 3 , 18.28 , 1 , 1.2 , 15.24 , 1.8 , 2.5 , 1 , 1 , 524.26 , 5 , 1 , 2 , 2.4 , 1 , 5.7 , 1 , 1.5 , 25 , 9 , 1 , 1.5 , 1 , 1 , 3 , 4.5 , 15 , 1 , 67 , 5.8 , 10.7 , 3 , 7 , 2 , 1.4 , 3 , 1 , 2 , 1.5 , 2 , 2 , 2 , 1.2 , 2.4 , 6 , 3 , 10 , 2 , 4 , 5 , 15 , 2 , 1.8 , 3 , 1.2 , 3 , 3 , 2 , 1.8 , 1.5 , 1.16 , 1.5 , 4.5 , 1.5 , 4.5 , 1.8 , 8.2 , 2.1 , 5.5 , 2 , 4 , 14.3 , 4.48 , 15 , 1.2 , 1 , 1.5 , 1.3 , 2 , 10 , 6 , 250 , 1.3 , 3 , 14.5 , 1 , 1.5 , 3 , 2 , 1.3 , 3 , 2.5 , 1.4 , 1.5 , 5.5 , 1.03 , 3 , 1.8 , 10 , 26.2 , 31.7 , 2.1 , 2 , 13 , 3.7 , 3 , 1.2 , 11 , 3 , 7.62 , 7.3 , 1.1 , 4 , 3 , 5.1 , 2.6 , 1.5 , 1.1 , 3.4 , 2 , 30 , 7.7 , 5.1 , 1.1 , 3 , 1.5 , 8 , 3 , 15 , 2.75 , 2 , 2.52 , 6 , 20 , 6 , 7 , 1 , 7 , 3 , 3 , 4 , 5 , 2 , 4 , 4 , 50 , 3 , 3.5 , 1 , 10 , 1.8 }; auto log_tsunami_height = transform ( tsunami_height , []( double x ) { return log ( x + 2 ); }); geobubble ( tsunami_lat , tsunami_lon , log_tsunami_height ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > tsunami_lon = { 128.3 , -156 , 157.95 , 143.85 , -155 , -82.4 , 159.5 , 156.5 , 147.4 , 178.2 , 141.7 , -86.883 , -32.283 , -72 , 23 , -175.629 , 137 , -99 , -79.5 , 104 , -136.52 , 148.54 , 148.8 , 159.8 , 156 , -111.215 , -72.75 , 143.4 , 143.7 , -74.5 , -80.7 , 147.9 , 168.5 , 160.5 , 142.8 , 22.05 , 149.54 , 150.1 , -176.6 , -147.5 , 139.2 , 178.55 , 22.4 , 167.2 , 167.6 , 160.8 , -78.8 , -70.6 , 166.5 , 164.8 , 166.8 , 97.3 , -79.8 , 24.9 , 132.5 , 143.2 , 143.1 , 119.8 , -92.6 , 118.9 , 147.9 , 163.6 , 121.7 , -78.8 , 145.5 , -71.2 , 153.9 , 153.2 , 141.2 , 146.6 , 147 , -103 , 156.6 , 145.8 , 155.9 , 155.6 , -77.79 , -128.633 , -17.649 , 147.734 , 155.054 , 125.993 , -155.024 , 124.023 , 118.464 , -78.52 , 142.03 , -96.591 , -101.276 , 136.04 , 7.25 , -79.358 , -122.18 , 142.361 , 127.924 , 139.102 , 139.099 , 72.11 , -71.871 , 114.185 , 152.828 , -102.533 , -101.647 , -174.776 , 147.689 , 14.97 , 121.013 , -83.073 , -124.316 , -87.34 , 121.896 , 139.197 , 144.801 , 127.733 , 112.835 , 112.892 , 133.366 , 152.214 , 147.321 , 127.98 , -135.3 , 121.067 , 143.419 , 125.127 , -70.294 , -104.205 , 130.175 , 130.148 , 149.3 , 119.931 , 22.083 , 159.318 , 136.952 , -79.587 , 131.468 , 166.676 , 162.035 , 162.035 , -62.18 , 141.926 , 124.891 , -62.18 , 29.864 , 168.214 , 120.15 , 123.573 , -120.65 , 152.169 , -73.641 , 167.856 , 124.249 , 142.945 , 134.297 , 3.634 , -62.18 , 143.91 , 95.982 , 97.108 , 127.214 , -62.18 , 107.411 , 153.266 }; std :: vector < double > tsunami_lat = { -3.8 , 19.5 , -9.02 , 42.15 , 19.1 , 43.1 , 52.75 , 50 , -2.4 , -18.3 , 34 , 41.7 , 67.8 , -30 , 39.5 , 51.292 , -1.5 , 16.5 , 1.2 , -4.5 , 58.34 , 44.53 , 44.2 , 53.4 , -7.5 , 44.712 , -15.75 , 39.8 , 39.4 , -39.5 , -6.8 , 43.2 , -18.5 , -9.9 , 38 , 38.42 , 44.81 , 44.1 , -24.8 , 61.1 , 38.65 , 51.29 , 38.4 , -15.8 , -15.9 , -10.3 , -10.7 , -25.5 , -11.8 , -11.3 , -11.8 , 5.5 , -10.6 , 39.4 , 32.3 , 40.8 , 39.4 , 0.2 , 15.6 , -3.1 , 43.6 , 57.7 , 15.8 , -9.2 , -4.9 , -32.5 , -5.5 , -4.9 , 46.5 , -6.5 , -6.7 , 18.48 , 50.5 , 43.2 , -7.5 , -7.4 , -12.27 , 54.083 , 35.997 , 43.024 , -6.59 , 12.54 , 19.334 , 6.262 , -11.085 , -10.233 , 38.19 , 16.01 , 17.813 , -1.679 , 43.7 , 1.598 , 46.2 , 42.158 , -4.056 , 40.462 , 41.346 , -6.852 , -33.135 , -9.245 , -4.439 , 18.19 , 17.802 , 51.52 , -6.088 , 38.41 , 18.606 , 9.685 , 40.368 , 11.742 , -8.48 , 42.851 , 12.982 , 1.015 , -10.477 , -10.362 , -10.777 , -4.238 , 43.773 , -1.258 , 59.5 , 13.525 , 40.525 , -8.378 , -23.34 , 19.055 , 27.929 , 28.094 , 44.663 , 0.729 , 38.367 , 54.45 , -0.891 , -9.593 , 31.885 , -12.584 , 54.841 , 54.841 , 16.72 , -2.961 , -2.071 , 16.722 , 40.748 , -16.423 , 5.1 , -1.105 , 34.5 , -3.98 , -16.265 , -17.6 , 6.033 , -3.302 , -1.757 , 36.964 , 16.722 , 41.815 , 3.295 , 2.085 , -3.595 , 16.722 , -9.254 , 46.592 }; std :: vector < double > tsunami_height = { 2.8 , 3.6 , 6 , 6.5 , 1 , 1.52 , 18 , 1.5 , 1.4 , 3 , 3 , 3 , 18.28 , 1 , 1.2 , 15.24 , 1.8 , 2.5 , 1 , 1 , 524.26 , 5 , 1 , 2 , 2.4 , 1 , 5.7 , 1 , 1.5 , 25 , 9 , 1 , 1.5 , 1 , 1 , 3 , 4.5 , 15 , 1 , 67 , 5.8 , 10.7 , 3 , 7 , 2 , 1.4 , 3 , 1 , 2 , 1.5 , 2 , 2 , 2 , 1.2 , 2.4 , 6 , 3 , 10 , 2 , 4 , 5 , 15 , 2 , 1.8 , 3 , 1.2 , 3 , 3 , 2 , 1.8 , 1.5 , 1.16 , 1.5 , 4.5 , 1.5 , 4.5 , 1.8 , 8.2 , 2.1 , 5.5 , 2 , 4 , 14.3 , 4.48 , 15 , 1.2 , 1 , 1.5 , 1.3 , 2 , 10 , 6 , 250 , 1.3 , 3 , 14.5 , 1 , 1.5 , 3 , 2 , 1.3 , 3 , 2.5 , 1.4 , 1.5 , 5.5 , 1.03 , 3 , 1.8 , 10 , 26.2 , 31.7 , 2.1 , 2 , 13 , 3.7 , 3 , 1.2 , 11 , 3 , 7.62 , 7.3 , 1.1 , 4 , 3 , 5.1 , 2.6 , 1.5 , 1.1 , 3.4 , 2 , 30 , 7.7 , 5.1 , 1.1 , 3 , 1.5 , 8 , 3 , 15 , 2.75 , 2 , 2.52 , 6 , 20 , 6 , 7 , 1 , 7 , 3 , 3 , 4 , 5 , 2 , 4 , 4 , 50 , 3 , 3.5 , 1 , 10 , 1.8 }; auto log_tsunami_height = transform ( tsunami_height , []( double x ) { return log ( x + 2 ); }); std :: vector < double > tsunami_cause = { 1 , 1 , 6 , 1 , 1 , 4 , 1 , 1 , 6 , 2 , 1 , 4 , 5 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 5 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , NaN , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 6 , 1 , 1 , 3 , 1 , 1 , 2 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 6 , 1 , 1 , 1 , 1 , 1 , 3 , 7 , 2 , 1 , 6 , 1 , 1 , 4 , 1 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 6 , 1 , 1 , 1 , 1 , 6 , 1 , 1 }; geobubble ( tsunami_lat , tsunami_lon , log_tsunami_height , tsunami_cause ); show (); return 0 ; }","title":"Geobubble"},{"location":"plot-types/geography/geobubble/#geobubble","text":"1 geobubble ( lat , lon , sizes ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > tsunami_lon = { 128.3 , -156 , 157.95 , 143.85 , -155 , -82.4 , 159.5 , 156.5 , 147.4 , 178.2 , 141.7 , -86.883 , -32.283 , -72 , 23 , -175.629 , 137 , -99 , -79.5 , 104 , -136.52 , 148.54 , 148.8 , 159.8 , 156 , -111.215 , -72.75 , 143.4 , 143.7 , -74.5 , -80.7 , 147.9 , 168.5 , 160.5 , 142.8 , 22.05 , 149.54 , 150.1 , -176.6 , -147.5 , 139.2 , 178.55 , 22.4 , 167.2 , 167.6 , 160.8 , -78.8 , -70.6 , 166.5 , 164.8 , 166.8 , 97.3 , -79.8 , 24.9 , 132.5 , 143.2 , 143.1 , 119.8 , -92.6 , 118.9 , 147.9 , 163.6 , 121.7 , -78.8 , 145.5 , -71.2 , 153.9 , 153.2 , 141.2 , 146.6 , 147 , -103 , 156.6 , 145.8 , 155.9 , 155.6 , -77.79 , -128.633 , -17.649 , 147.734 , 155.054 , 125.993 , -155.024 , 124.023 , 118.464 , -78.52 , 142.03 , -96.591 , -101.276 , 136.04 , 7.25 , -79.358 , -122.18 , 142.361 , 127.924 , 139.102 , 139.099 , 72.11 , -71.871 , 114.185 , 152.828 , -102.533 , -101.647 , -174.776 , 147.689 , 14.97 , 121.013 , -83.073 , -124.316 , -87.34 , 121.896 , 139.197 , 144.801 , 127.733 , 112.835 , 112.892 , 133.366 , 152.214 , 147.321 , 127.98 , -135.3 , 121.067 , 143.419 , 125.127 , -70.294 , -104.205 , 130.175 , 130.148 , 149.3 , 119.931 , 22.083 , 159.318 , 136.952 , -79.587 , 131.468 , 166.676 , 162.035 , 162.035 , -62.18 , 141.926 , 124.891 , -62.18 , 29.864 , 168.214 , 120.15 , 123.573 , -120.65 , 152.169 , -73.641 , 167.856 , 124.249 , 142.945 , 134.297 , 3.634 , -62.18 , 143.91 , 95.982 , 97.108 , 127.214 , -62.18 , 107.411 , 153.266 }; std :: vector < double > tsunami_lat = { -3.8 , 19.5 , -9.02 , 42.15 , 19.1 , 43.1 , 52.75 , 50 , -2.4 , -18.3 , 34 , 41.7 , 67.8 , -30 , 39.5 , 51.292 , -1.5 , 16.5 , 1.2 , -4.5 , 58.34 , 44.53 , 44.2 , 53.4 , -7.5 , 44.712 , -15.75 , 39.8 , 39.4 , -39.5 , -6.8 , 43.2 , -18.5 , -9.9 , 38 , 38.42 , 44.81 , 44.1 , -24.8 , 61.1 , 38.65 , 51.29 , 38.4 , -15.8 , -15.9 , -10.3 , -10.7 , -25.5 , -11.8 , -11.3 , -11.8 , 5.5 , -10.6 , 39.4 , 32.3 , 40.8 , 39.4 , 0.2 , 15.6 , -3.1 , 43.6 , 57.7 , 15.8 , -9.2 , -4.9 , -32.5 , -5.5 , -4.9 , 46.5 , -6.5 , -6.7 , 18.48 , 50.5 , 43.2 , -7.5 , -7.4 , -12.27 , 54.083 , 35.997 , 43.024 , -6.59 , 12.54 , 19.334 , 6.262 , -11.085 , -10.233 , 38.19 , 16.01 , 17.813 , -1.679 , 43.7 , 1.598 , 46.2 , 42.158 , -4.056 , 40.462 , 41.346 , -6.852 , -33.135 , -9.245 , -4.439 , 18.19 , 17.802 , 51.52 , -6.088 , 38.41 , 18.606 , 9.685 , 40.368 , 11.742 , -8.48 , 42.851 , 12.982 , 1.015 , -10.477 , -10.362 , -10.777 , -4.238 , 43.773 , -1.258 , 59.5 , 13.525 , 40.525 , -8.378 , -23.34 , 19.055 , 27.929 , 28.094 , 44.663 , 0.729 , 38.367 , 54.45 , -0.891 , -9.593 , 31.885 , -12.584 , 54.841 , 54.841 , 16.72 , -2.961 , -2.071 , 16.722 , 40.748 , -16.423 , 5.1 , -1.105 , 34.5 , -3.98 , -16.265 , -17.6 , 6.033 , -3.302 , -1.757 , 36.964 , 16.722 , 41.815 , 3.295 , 2.085 , -3.595 , 16.722 , -9.254 , 46.592 }; std :: vector < double > tsunami_height = { 2.8 , 3.6 , 6 , 6.5 , 1 , 1.52 , 18 , 1.5 , 1.4 , 3 , 3 , 3 , 18.28 , 1 , 1.2 , 15.24 , 1.8 , 2.5 , 1 , 1 , 524.26 , 5 , 1 , 2 , 2.4 , 1 , 5.7 , 1 , 1.5 , 25 , 9 , 1 , 1.5 , 1 , 1 , 3 , 4.5 , 15 , 1 , 67 , 5.8 , 10.7 , 3 , 7 , 2 , 1.4 , 3 , 1 , 2 , 1.5 , 2 , 2 , 2 , 1.2 , 2.4 , 6 , 3 , 10 , 2 , 4 , 5 , 15 , 2 , 1.8 , 3 , 1.2 , 3 , 3 , 2 , 1.8 , 1.5 , 1.16 , 1.5 , 4.5 , 1.5 , 4.5 , 1.8 , 8.2 , 2.1 , 5.5 , 2 , 4 , 14.3 , 4.48 , 15 , 1.2 , 1 , 1.5 , 1.3 , 2 , 10 , 6 , 250 , 1.3 , 3 , 14.5 , 1 , 1.5 , 3 , 2 , 1.3 , 3 , 2.5 , 1.4 , 1.5 , 5.5 , 1.03 , 3 , 1.8 , 10 , 26.2 , 31.7 , 2.1 , 2 , 13 , 3.7 , 3 , 1.2 , 11 , 3 , 7.62 , 7.3 , 1.1 , 4 , 3 , 5.1 , 2.6 , 1.5 , 1.1 , 3.4 , 2 , 30 , 7.7 , 5.1 , 1.1 , 3 , 1.5 , 8 , 3 , 15 , 2.75 , 2 , 2.52 , 6 , 20 , 6 , 7 , 1 , 7 , 3 , 3 , 4 , 5 , 2 , 4 , 4 , 50 , 3 , 3.5 , 1 , 10 , 1.8 }; auto log_tsunami_height = transform ( tsunami_height , []( double x ) { return log ( x + 2 ); }); geobubble ( tsunami_lat , tsunami_lon , log_tsunami_height ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > tsunami_lon = { 128.3 , -156 , 157.95 , 143.85 , -155 , -82.4 , 159.5 , 156.5 , 147.4 , 178.2 , 141.7 , -86.883 , -32.283 , -72 , 23 , -175.629 , 137 , -99 , -79.5 , 104 , -136.52 , 148.54 , 148.8 , 159.8 , 156 , -111.215 , -72.75 , 143.4 , 143.7 , -74.5 , -80.7 , 147.9 , 168.5 , 160.5 , 142.8 , 22.05 , 149.54 , 150.1 , -176.6 , -147.5 , 139.2 , 178.55 , 22.4 , 167.2 , 167.6 , 160.8 , -78.8 , -70.6 , 166.5 , 164.8 , 166.8 , 97.3 , -79.8 , 24.9 , 132.5 , 143.2 , 143.1 , 119.8 , -92.6 , 118.9 , 147.9 , 163.6 , 121.7 , -78.8 , 145.5 , -71.2 , 153.9 , 153.2 , 141.2 , 146.6 , 147 , -103 , 156.6 , 145.8 , 155.9 , 155.6 , -77.79 , -128.633 , -17.649 , 147.734 , 155.054 , 125.993 , -155.024 , 124.023 , 118.464 , -78.52 , 142.03 , -96.591 , -101.276 , 136.04 , 7.25 , -79.358 , -122.18 , 142.361 , 127.924 , 139.102 , 139.099 , 72.11 , -71.871 , 114.185 , 152.828 , -102.533 , -101.647 , -174.776 , 147.689 , 14.97 , 121.013 , -83.073 , -124.316 , -87.34 , 121.896 , 139.197 , 144.801 , 127.733 , 112.835 , 112.892 , 133.366 , 152.214 , 147.321 , 127.98 , -135.3 , 121.067 , 143.419 , 125.127 , -70.294 , -104.205 , 130.175 , 130.148 , 149.3 , 119.931 , 22.083 , 159.318 , 136.952 , -79.587 , 131.468 , 166.676 , 162.035 , 162.035 , -62.18 , 141.926 , 124.891 , -62.18 , 29.864 , 168.214 , 120.15 , 123.573 , -120.65 , 152.169 , -73.641 , 167.856 , 124.249 , 142.945 , 134.297 , 3.634 , -62.18 , 143.91 , 95.982 , 97.108 , 127.214 , -62.18 , 107.411 , 153.266 }; std :: vector < double > tsunami_lat = { -3.8 , 19.5 , -9.02 , 42.15 , 19.1 , 43.1 , 52.75 , 50 , -2.4 , -18.3 , 34 , 41.7 , 67.8 , -30 , 39.5 , 51.292 , -1.5 , 16.5 , 1.2 , -4.5 , 58.34 , 44.53 , 44.2 , 53.4 , -7.5 , 44.712 , -15.75 , 39.8 , 39.4 , -39.5 , -6.8 , 43.2 , -18.5 , -9.9 , 38 , 38.42 , 44.81 , 44.1 , -24.8 , 61.1 , 38.65 , 51.29 , 38.4 , -15.8 , -15.9 , -10.3 , -10.7 , -25.5 , -11.8 , -11.3 , -11.8 , 5.5 , -10.6 , 39.4 , 32.3 , 40.8 , 39.4 , 0.2 , 15.6 , -3.1 , 43.6 , 57.7 , 15.8 , -9.2 , -4.9 , -32.5 , -5.5 , -4.9 , 46.5 , -6.5 , -6.7 , 18.48 , 50.5 , 43.2 , -7.5 , -7.4 , -12.27 , 54.083 , 35.997 , 43.024 , -6.59 , 12.54 , 19.334 , 6.262 , -11.085 , -10.233 , 38.19 , 16.01 , 17.813 , -1.679 , 43.7 , 1.598 , 46.2 , 42.158 , -4.056 , 40.462 , 41.346 , -6.852 , -33.135 , -9.245 , -4.439 , 18.19 , 17.802 , 51.52 , -6.088 , 38.41 , 18.606 , 9.685 , 40.368 , 11.742 , -8.48 , 42.851 , 12.982 , 1.015 , -10.477 , -10.362 , -10.777 , -4.238 , 43.773 , -1.258 , 59.5 , 13.525 , 40.525 , -8.378 , -23.34 , 19.055 , 27.929 , 28.094 , 44.663 , 0.729 , 38.367 , 54.45 , -0.891 , -9.593 , 31.885 , -12.584 , 54.841 , 54.841 , 16.72 , -2.961 , -2.071 , 16.722 , 40.748 , -16.423 , 5.1 , -1.105 , 34.5 , -3.98 , -16.265 , -17.6 , 6.033 , -3.302 , -1.757 , 36.964 , 16.722 , 41.815 , 3.295 , 2.085 , -3.595 , 16.722 , -9.254 , 46.592 }; std :: vector < double > tsunami_height = { 2.8 , 3.6 , 6 , 6.5 , 1 , 1.52 , 18 , 1.5 , 1.4 , 3 , 3 , 3 , 18.28 , 1 , 1.2 , 15.24 , 1.8 , 2.5 , 1 , 1 , 524.26 , 5 , 1 , 2 , 2.4 , 1 , 5.7 , 1 , 1.5 , 25 , 9 , 1 , 1.5 , 1 , 1 , 3 , 4.5 , 15 , 1 , 67 , 5.8 , 10.7 , 3 , 7 , 2 , 1.4 , 3 , 1 , 2 , 1.5 , 2 , 2 , 2 , 1.2 , 2.4 , 6 , 3 , 10 , 2 , 4 , 5 , 15 , 2 , 1.8 , 3 , 1.2 , 3 , 3 , 2 , 1.8 , 1.5 , 1.16 , 1.5 , 4.5 , 1.5 , 4.5 , 1.8 , 8.2 , 2.1 , 5.5 , 2 , 4 , 14.3 , 4.48 , 15 , 1.2 , 1 , 1.5 , 1.3 , 2 , 10 , 6 , 250 , 1.3 , 3 , 14.5 , 1 , 1.5 , 3 , 2 , 1.3 , 3 , 2.5 , 1.4 , 1.5 , 5.5 , 1.03 , 3 , 1.8 , 10 , 26.2 , 31.7 , 2.1 , 2 , 13 , 3.7 , 3 , 1.2 , 11 , 3 , 7.62 , 7.3 , 1.1 , 4 , 3 , 5.1 , 2.6 , 1.5 , 1.1 , 3.4 , 2 , 30 , 7.7 , 5.1 , 1.1 , 3 , 1.5 , 8 , 3 , 15 , 2.75 , 2 , 2.52 , 6 , 20 , 6 , 7 , 1 , 7 , 3 , 3 , 4 , 5 , 2 , 4 , 4 , 50 , 3 , 3.5 , 1 , 10 , 1.8 }; auto log_tsunami_height = transform ( tsunami_height , []( double x ) { return log ( x + 2 ); }); std :: vector < double > tsunami_cause = { 1 , 1 , 6 , 1 , 1 , 4 , 1 , 1 , 6 , 2 , 1 , 4 , 5 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 5 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , NaN , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 2 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 1 , 2 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 6 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 6 , 1 , 1 , 3 , 1 , 1 , 2 , 1 , 1 , 1 , 2 , 1 , 1 , 3 , 6 , 1 , 1 , 1 , 1 , 1 , 3 , 7 , 2 , 1 , 6 , 1 , 1 , 4 , 1 , 3 , 1 , 1 , 1 , 1 , 1 , 1 , 1 , 6 , 1 , 1 , 1 , 1 , 6 , 1 , 1 }; geobubble ( tsunami_lat , tsunami_lon , log_tsunami_height , tsunami_cause ); show (); return 0 ; }","title":"Geobubble"},{"location":"plot-types/geography/geodensity-plot/","text":"Geodensity Plot 1 geodensityplot ( lat , lon ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > lon = transform ( linspace ( -170 , 170 , 3000 ), []( double x ) { return x + 10. * rand ( 0 , 1 ); }); std :: vector < double > lat = transform ( lon , []( double x ) { return 50. * cosd ( 3 * x ) + 10 * rand ( 0 , 1 ); }); std :: vector < double > weights = transform ( lon , []( double lon ) { return 101. + 100 * ( sind ( 2 * lon )); }); geodensityplot ( lat , lon ); show (); return 0 ; }","title":"Geodensity Plot"},{"location":"plot-types/geography/geodensity-plot/#geodensity-plot","text":"1 geodensityplot ( lat , lon ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > lon = transform ( linspace ( -170 , 170 , 3000 ), []( double x ) { return x + 10. * rand ( 0 , 1 ); }); std :: vector < double > lat = transform ( lon , []( double x ) { return 50. * cosd ( 3 * x ) + 10 * rand ( 0 , 1 ); }); std :: vector < double > weights = transform ( lon , []( double lon ) { return 101. + 100 * ( sind ( 2 * lon )); }); geodensityplot ( lat , lon ); show (); return 0 ; }","title":"Geodensity Plot"},{"location":"plot-types/geography/geoplot/","text":"Geoplot 1 geoplot ( lat , lon ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double lat_seattle = 47.62 ; double lon_seattle = -122.33 ; double lat_anchorage = 61.20 ; double lon_anchorage = -149.9 ; geoplot ( std :: vector { lat_seattle , lat_anchorage }, std :: vector { lon_seattle , lon_anchorage }, \"g-*\" ); geolimits ({ 45 , 62 }, { -155 , -120 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double lat_seattle = 47.62 ; double lon_seattle = -122.33 ; double lat_anchorage = 61.20 ; double lon_anchorage = -149.9 ; geoplot ( std :: vector { lat_seattle , lat_anchorage }, std :: vector { lon_seattle , lon_anchorage }, \"g-*\" ); geolimits ({ 45 , 62 }, { -155 , -120 }); text ( lon_anchorage , lat_anchorage , \"Anchorage\" ); text ( lon_seattle , lat_seattle , \"Seattle\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ lon , lat , names ] = world_cities ( 6 , 8 ); auto [ lon_star , lat_star ] = greedy_tsp ( lon , lat ); geoplot ( lat_star , lon_star ) -> marker ( \"o\" ) . marker_colors ( iota ( 1. , static_cast < double > ( names . size ()))); text ( lon , lat , names ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double lat_seattle = 47.62 ; double lon_seattle = -122.33 ; double lat_anchorage = 61.20 ; double lon_anchorage = -149.9 ; double lat_pt_barrow = 71.38 ; double lon_pt_barrow = -156.47 ; geoplot ( std :: vector { lat_seattle , lat_anchorage }, std :: vector { lon_seattle , lon_anchorage }, \"y-\" ); hold ( on ); geoplot ( std :: vector { lat_seattle , lat_pt_barrow }, std :: vector { lon_seattle , lon_pt_barrow }, \"b:\" ); geolimits ( 44 , 75 , -170 , -100 ); text ( lon_anchorage , lat_anchorage , \"Anchorage\" ); text ( lon_seattle , lat_seattle , \"Seattle\" ); text ( lon_pt_barrow , lat_pt_barrow , \"Point Barrow\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double lat_seattle = 47.62 ; double lon_seattle = -122.33 ; double lat_anchorage = 61.20 ; double lon_anchorage = -149.9 ; auto g = geoplot ( std :: vector { lat_seattle , lat_anchorage }, std :: vector { lon_seattle , lon_anchorage }); g -> line_width ( 2. ); hold ( on ); geolimits ({ 44 , 75 }, { -170 , -100 }); text ( lon_anchorage , lat_anchorage , \"Anchorage\" ); text ( lon_seattle , lat_seattle , \"Seattle\" ); color_array terrain = { 0. , 0.71 , 0.65 , 0.59 }; geoplot () -> color ( terrain ); color_array blue_water = { 0. , 0.4 , 0.61 , 0.76 }; gca () -> color ( blue_water ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 #include <matplot/matplot.h> #include <random> using namespace matplot ; using namespace std ; class eurotrip_solver { public : eurotrip_solver ( const vector < double > & lat , const vector < double > & lon , const vector < string > & names , axes_handle ax ); void run ( size_t iterations = 100 ); private : void setup_starting_point ( size_t iteration ); double tour_distance ( const vector < size_t > & tour ); void iteration (); static vector < vector < size_t >> get_neighbors ( const std :: vector < size_t > & tour ); bool update_if_better ( const vector < size_t > & neighbor ); void draw_if_improvement (); void draw (); private : vector < double > lat_ ; vector < double > lon_ ; vector < string > names_ ; axes_handle ax_ ; // Current tour double curr_dist_ { 0.0 }; vector < size_t > curr_tour_ ; // Best tour double min_dist_ { 0.0 }; vector < size_t > best_tour_ ; }; eurotrip_solver :: eurotrip_solver ( const vector < double > & lat , const vector < double > & lon , const vector < string > & names , axes_handle ax ) : lat_ ( lat ), lon_ ( lon ), names_ ( names ), ax_ ( ax ) {} void eurotrip_solver :: run ( size_t iterations ) { for ( size_t i = 0 ; i < iterations ; ++ i ) { setup_starting_point ( i ); iteration (); } ax_ -> draw (); ax_ -> parent () -> save ( \"eurotrip.svg\" ); } void eurotrip_solver :: setup_starting_point ( size_t iteration ) { std :: cout << \"Starting point \" << iteration << std :: endl ; if ( iteration < names_ . size ()) { auto [ lon_ignore , lat_ignore , tour ] = greedy_tsp_with_idx ( lon_ , lat_ , iteration ); curr_tour_ = tour ; curr_dist_ = tour_distance ( curr_tour_ ); } else { static std :: mt19937 g (( std :: random_device ())()); std :: iota ( curr_tour_ . begin (), curr_tour_ . end (), 0 ); std :: shuffle ( curr_tour_ . begin (), curr_tour_ . end (), g ); curr_dist_ = tour_distance ( curr_tour_ ); } if ( iteration == 0 || curr_dist_ < min_dist_ ) { best_tour_ = curr_tour_ ; min_dist_ = curr_dist_ ; } } vector < vector < size_t >> eurotrip_solver :: get_neighbors ( const std :: vector < size_t > & tour ) { vector < vector < size_t >> neighbors ; constexpr size_t n_movements = 2 ; for ( size_t i = 0 ; i < tour . size () - 1 ; ++ i ) { for ( size_t j = i + 1 ; j < tour . size (); ++ j ) { for ( size_t movement = 0 ; movement < n_movements ; ++ movement ) { vector < size_t > neighbor = tour ; if ( movement == 0 ) { std :: swap ( neighbor [ i ], neighbor [ j ]); } else { std :: reverse ( neighbor . begin () + i , neighbor . begin () + j + 1 ); } neighbors . emplace_back ( neighbor ); } } } return neighbors ; } void eurotrip_solver :: iteration () { bool improvement = true ; while ( improvement ) { improvement = false ; for ( const auto & neighbor : get_neighbors ( curr_tour_ )) { improvement = update_if_better ( neighbor ); draw_if_improvement (); if ( improvement ) { break ; } } } } double eurotrip_solver :: tour_distance ( const vector < size_t > & tour ) { double sum = 0. ; for ( size_t i = 0 ; i < tour . size () - 1 ; ++ i ) { sum += distance ( lon_ [ tour [ i ]], lat_ [ tour [ i ]], lon_ [ tour [ i + 1 ]], lat_ [ tour [ i + 1 ]]); } sum += distance ( lon_ [ tour [ tour . size () - 1 ]], lat_ [ tour [ tour . size () - 1 ]], lon_ [ tour [ 0 ]], lat_ [ tour [ 0 ]]); return sum ; } void eurotrip_solver :: draw () { ax_ -> clear (); ax_ -> geolimits ( min ( lat_ ) - 5 , max ( lat_ ) + 5 , min ( lon_ ) - 2 , max ( lon_ ) + 10 ); vector < double > sorted_lat ; vector < double > sorted_lon ; for ( const size_t & idx : best_tour_ ) { sorted_lat . emplace_back ( lat_ [ idx ]); sorted_lon . emplace_back ( lon_ [ idx ]); } sorted_lat . emplace_back ( lat_ [ best_tour_ [ 0 ]]); sorted_lon . emplace_back ( lon_ [ best_tour_ [ 0 ]]); ax_ -> geoplot ( sorted_lat , sorted_lon ); ax_ -> hold ( true ); ax_ -> geoscatter ( lat_ , lon_ ); auto [ lon_c , lat_c , names_c ] = clear_overlapping_labels ( lon_ , lat_ , names_ , 1 , 1 ); ax_ -> text ( lon_c , lat_c , names_c ); ax_ -> title ( \"Tour distance \" + num2str ( min_dist_ )); ax_ -> draw (); } bool eurotrip_solver :: update_if_better ( const vector < size_t > & neighbor ) { double d = tour_distance ( neighbor ); if ( d < curr_dist_ ) { curr_tour_ = neighbor ; curr_dist_ = d ; if ( d < min_dist_ ) { best_tour_ = curr_tour_ ; min_dist_ = d ; } return true ; } return false ; } void eurotrip_solver :: draw_if_improvement () { static auto last_draw = chrono :: high_resolution_clock :: now () - chrono :: seconds ( 1 ); static auto min_dist_when_last_draw = min_dist_ ; const auto current_time = chrono :: high_resolution_clock :: now (); const bool its_been_a_while = current_time - last_draw > chrono :: seconds ( 1 ); const bool things_are_better = min_dist_ < min_dist_when_last_draw ; if ( its_been_a_while && things_are_better ) { last_draw = current_time ; min_dist_when_last_draw = min_dist_ ; draw (); } } int main () { vector < string > names = { \"Tirana\" , \"Andorra la Vella\" , \"Vienna\" , \"Minsk\" , \"Brussels\" , \"Sarajevo\" , \"Sofia\" , \"Zagreb\" , \"Prague\" , \"Copenhagen\" , \"Tallinn\" , \"Helsinki\" , \"Paris\" , \"Berlin\" , \"Athens\" , \"Budapest\" , \"Reykjavik\" , \"Dublin\" , \"Rome\" , \"Pristina\" , \"Riga\" , \"Vaduz\" , \"Vilnius\" , \"Luxembourg\" , \"Valletta\" , \"Chisinau\" , \"Monaco\" , \"Podgorica\" , \"Amsterdam\" , \"Skopje\" , \"Oslo\" , \"Warsaw\" , \"Lisbon\" , \"Bucharest\" , \"Moscow\" , \"San Marino\" , \"Belgrade\" , \"Bratislava\" , \"Ljubljana\" , \"Madrid\" , \"Stockholm\" , \"Bern\" , \"Kiev\" , \"London\" }; vector < double > lat = { + 41.3317 , + 42.5075 , + 48.2092 , + 53.9678 , + 50.8371 , + 43.8608 , + 42.7105 , + 45.8150 , + 50.0878 , + 55.6763 , + 59.4389 , + 60.1699 , + 48.8567 , + 52.5235 , + 37.9792 , + 47.4984 , + 64.1353 , + 53.3441 , + 41.8955 , + 42.6740 , + 56.9465 , + 47.1411 , + 54.6896 , + 49.6100 , + 35.9042 , + 47.0167 , + 43.7325 , + 42.4602 , + 52.3738 , + 42.0024 , + 59.9138 , + 52.2297 , + 38.7072 , + 44.4479 , + 55.7558 , + 43.9424 , + 44.8048 , + 48.2116 , + 46.0514 , + 40.4167 , + 59.3328 , + 46.9480 , + 50.4422 , + 51.5002 }; vector < double > lon = { + 19.8172 , + 1.5218 , + 16.3728 , + 27.5766 , + 4.3676 , + 18.4214 , + 23.3238 , + 15.9785 , + 14.4205 , + 12.5681 , + 24.7545 , + 24.9384 , + 2.3510 , + 13.4115 , + 23.7166 , + 19.0408 , -21.8952 , -6.2675 , + 12.4823 , + 21.1788 , + 24.1049 , + 9.5215 , + 25.2799 , + 6.1296 , + 14.5189 , + 28.8497 , + 7.4189 , + 19.2595 , + 4.8910 , + 21.4361 , + 10.7387 , + 21.0122 , -9.1355 , + 26.0979 , + 37.6176 , + 12.4578 , + 20.4781 , + 17.1547 , + 14.5060 , -3.7033 , + 18.0645 , + 7.4481 , + 30.5367 , -0.1262 }; std :: cout << names . size () << \" cities\" << std :: endl ; figure_handle f = figure ( true ); eurotrip_solver s ( lat , lon , names , f -> current_axes ()); s . run (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 #include <matplot/matplot.h> #include <random> using namespace matplot ; using namespace std ; class americas_trip_solver { public : americas_trip_solver ( const vector < double > & lat , const vector < double > & lon , const vector < string > & names , axes_handle ax ); void run ( size_t iterations = 100 ); private : void setup_axes (); void setup_starting_point ( size_t iteration ); double tour_distance ( const vector < size_t > & tour ); void iteration (); static vector < vector < size_t >> get_neighbors ( const std :: vector < size_t > & tour ); bool update_if_better ( const vector < size_t > & neighbor ); void draw_if_improvement (); void draw (); private : vector < double > lat_ ; vector < double > lon_ ; vector < string > names_ ; axes_handle ax_ ; line_handle lh_ ; // Current tour double curr_dist_ { 0.0 }; vector < size_t > curr_tour_ ; // Best tour double min_dist_ { 0.0 }; vector < size_t > best_tour_ ; }; americas_trip_solver :: americas_trip_solver ( const vector < double > & lat , const vector < double > & lon , const vector < string > & names , axes_handle ax ) : lat_ ( lat ), lon_ ( lon ), names_ ( names ), ax_ ( ax ) { setup_axes (); } void americas_trip_solver :: run ( size_t iterations ) { for ( size_t i = 0 ; i < iterations ; ++ i ) { setup_starting_point ( i ); iteration (); } ax_ -> draw (); ax_ -> parent () -> save ( \"americastrip.svg\" ); } void americas_trip_solver :: setup_starting_point ( size_t iteration ) { std :: cout << \"Starting point \" << iteration << std :: endl ; if ( iteration < names_ . size ()) { auto [ lon_ignore , lat_ignore , tour ] = greedy_tsp_with_idx ( lon_ , lat_ , iteration ); curr_tour_ = tour ; curr_dist_ = tour_distance ( curr_tour_ ); } else { static std :: mt19937 g (( std :: random_device ())()); std :: iota ( curr_tour_ . begin (), curr_tour_ . end (), 0 ); std :: shuffle ( curr_tour_ . begin (), curr_tour_ . end (), g ); curr_dist_ = tour_distance ( curr_tour_ ); } if ( iteration == 0 || curr_dist_ < min_dist_ ) { best_tour_ = curr_tour_ ; min_dist_ = curr_dist_ ; } } vector < vector < size_t >> americas_trip_solver :: get_neighbors ( const std :: vector < size_t > & tour ) { vector < vector < size_t >> neighbors ; constexpr size_t n_movements = 2 ; for ( size_t i = 0 ; i < tour . size () - 1 ; ++ i ) { for ( size_t j = i + 1 ; j < tour . size (); ++ j ) { for ( size_t movement = 0 ; movement < n_movements ; ++ movement ) { vector < size_t > neighbor = tour ; if ( movement == 0 ) { std :: swap ( neighbor [ i ], neighbor [ j ]); } else { std :: reverse ( neighbor . begin () + i , neighbor . begin () + j + 1 ); } neighbors . emplace_back ( neighbor ); } } } return neighbors ; } void americas_trip_solver :: iteration () { bool improvement = true ; while ( improvement ) { improvement = false ; for ( const auto & neighbor : get_neighbors ( curr_tour_ )) { improvement = update_if_better ( neighbor ); draw_if_improvement (); if ( improvement ) { break ; } } } } double americas_trip_solver :: tour_distance ( const vector < size_t > & tour ) { double sum = 0. ; for ( size_t i = 0 ; i < tour . size () - 1 ; ++ i ) { sum += distance ( lon_ [ tour [ i ]], lat_ [ tour [ i ]], lon_ [ tour [ i + 1 ]], lat_ [ tour [ i + 1 ]]); } sum += distance ( lon_ [ tour [ tour . size () - 1 ]], lat_ [ tour [ tour . size () - 1 ]], lon_ [ tour [ 0 ]], lat_ [ tour [ 0 ]]); return sum ; } void americas_trip_solver :: draw () { vector < double > sorted_lat ; vector < double > sorted_lon ; for ( const size_t & idx : best_tour_ ) { sorted_lat . emplace_back ( lat_ [ idx ]); sorted_lon . emplace_back ( lon_ [ idx ]); } sorted_lat . emplace_back ( lat_ [ best_tour_ [ 0 ]]); sorted_lon . emplace_back ( lon_ [ best_tour_ [ 0 ]]); lh_ -> x_data ( sorted_lon ); lh_ -> y_data ( sorted_lat ); ax_ -> title ( \"Tour distance \" + num2str ( min_dist_ )); ax_ -> draw (); } bool americas_trip_solver :: update_if_better ( const vector < size_t > & neighbor ) { double d = tour_distance ( neighbor ); if ( d < curr_dist_ ) { curr_tour_ = neighbor ; curr_dist_ = d ; if ( d < min_dist_ ) { best_tour_ = curr_tour_ ; min_dist_ = d ; } return true ; } return false ; } void americas_trip_solver :: draw_if_improvement () { static auto last_draw = chrono :: high_resolution_clock :: now () - chrono :: seconds ( 1 ); static auto min_dist_when_last_draw = min_dist_ ; const auto current_time = chrono :: high_resolution_clock :: now (); const bool its_been_a_while = current_time - last_draw > chrono :: seconds ( 1 ); const bool things_are_better = min_dist_ < min_dist_when_last_draw ; if ( its_been_a_while && things_are_better ) { last_draw = current_time ; min_dist_when_last_draw = min_dist_ ; draw (); } } void americas_trip_solver :: setup_axes () { ax_ -> clear (); ax_ -> geolimits ( min ( lat_ ) - 5 , max ( lat_ ) + 5 , min ( lon_ ) - 30 , max ( lon_ ) + 50 ); lh_ = ax_ -> geoplot ( lat_ , lon_ ); ax_ -> hold ( true ); ax_ -> geoscatter ( lat_ , lon_ ); auto [ lon_c , lat_c , names_c ] = clear_overlapping_labels ( lon_ , lat_ , names_ , 2 , 2 ); ax_ -> text ( lon_c , lat_c , names_c ); ax_ -> draw (); } int main () { vector < string > names = { \"Marigot\" , \"The Valley\" , \"Saint John's\" , \"Buenos Aires\" , \"Oranjestad\" , \"Nassau\" , \"Bridgetown\" , \"Belmopan\" , \"Hamilton\" , \"La Paz\" , \"Brasilia\" , \"Road Town\" , \"Ottawa\" , \"George Town\" , \"Santiago\" , \"Bogota\" , \"San Jose\" , \"Havana\" , \"Willemstad\" , \"Roseau\" , \"Santo Domingo\" , \"Quito\" , \"San Salvador\" , \"Stanley\" , \"Nuuk\" , \"Saint George's\" , \"Guatemala City\" , \"Georgetown\" , \"Port-au-Prince\" , \"Tegucigalpa\" , \"Kingston\" , \"Mexico City\" , \"Plymouth\" , \"Managua\" , \"Panama City\" , \"Asuncion\" , \"Lima\" , \"San Juan\" , \"Gustavia\" , \"Basseterre\" , \"Castries\" , \"Saint-Pierre\" , \"Kingstown\" , \"Philipsburg\" , \"Paramaribo\" , \"Port of Spain\" , \"Grand Turk\" , \"Washington\" , \"Montevideo\" , \"Caracas\" , \"Charlotte Amalie\" }; vector < double > lat = { 18.0731 , 18.2166 , 17.1166 , -34.5833 , 12.5166 , 25.0833 , 13.1 , 17.25 , 32.2833 , -16.5 , -15.7833 , 18.4166 , 45.4166 , 19.3 , -33.45 , 4.6 , 9.9333 , 23.1166 , 12.1 , 15.3 , 18.4666 , -0.2166 , 13.7 , -51.7 , 64.1833 , 12.05 , 14.6166 , 6.8 , 18.5333 , 14.1 , 18 , 19.4333 , 16.7 , 12.1333 , 8.9666 , -25.2666 , -12.05 , 18.4666 , 17.8833 , 17.3 , 14 , 46.7666 , 13.1333 , 18.0166 , 5.8333 , 10.65 , 21.4666 , 38.8833 , -34.85 , 10.4833 , 18.35 }; vector < double > lon = { -63.0822 , -63.0500 , -61.8500 , -58.6666 , -70.0333 , -77.3500 , -59.6166 , -88.7666 , -64.7833 , -68.1500 , -47.9166 , -64.6166 , -75.7000 , -81.3833 , -70.6666 , -74.0833 , -84.0833 , -82.3500 , -68.9166 , -61.4000 , -69.9000 , -78.5000 , -89.2000 , -57.8500 , -51.7500 , -61.7500 , -90.5166 , -58.1500 , -72.3333 , -87.2166 , -76.8000 , -99.1333 , -62.2166 , -86.2500 , -79.5333 , -57.6666 , -77.0500 , -66.1166 , -62.8500 , -62.7166 , -61.0000 , -56.1833 , -61.2166 , -63.0333 , -55.1666 , -61.5166 , -71.1333 , -77.0000 , -56.1666 , -66.8666 , -64.9333 }; figure_handle f = figure ( true ); americas_trip_solver s ( lat , lon , names , f -> current_axes ()); s . run (); show (); return 0 ; } For the first geography plot, Matplot++ calls geoplot() , which creates a filled polygon with the world map. This first plot receives the tag \"map\" so that subsequent geography plots recognize there is no need to recreate this world map. The data for the world map comes from Natural Earth. They provide data at 1:10m, 1:50m, and 1:110m scales. The geoplot function will initially use the data at the 1:110m scales. The geolimits function can be used to update the axis limits for geography plots. The difference between the usual functions for adjusting axis limits ( xlim and ylim ) and geolimits is that the latter will also update the map resolution according to the new limits for the and axis. The geolimits function will query the figure size and, depending on the new limits for the axes, update the map to the 1:10m, or 1:50m scales if needed. Because it would be very inefficient to render the whole world map at a 1:10m or 1:50m scale only to display a region of this map, the geolimits function also crops the data pertinent to the new region being displayed. Note that this does not only involve removing data points outside the new limits but it also needs to create new data points on the correct borders to create new polygons coherent with the map entry points in the region. For this reason, the algorithm needs to track all submaps represented as closed polygons in the original world map. If submaps are completely inside or outside the new ranges, we can respectively include or dismiss the data points. However, if the submap is only partially inside the new limits, to generate the correct borders for the polygons, we need to track all points outside the limits to classify the directions of these points outside the limits. We do that by only including points that change quadrants around the new limits so that the map entry points create polygons that look like they would if the complete world map were still being rendered outside these new limits. If the you are not interested in geographic plots, the build script includes an option to remove the high-resolution maps at 1:10m and 1:50m scales from the library. In this case, the library will always use the map at a 1:110m scale no matter the axis limits. The function world_cities returns a list of major world cities. Its parameters define the minimum distances between cities in the and axes. The greedy_tsp function is a naive greedy algorithm to find a route between these cities as a Traveling Salesman Problem (TSP). We use the geoplot function to draw this route. Note that we use method chaining to define some further plot properties. Finally, the text function includes the city names in the map.","title":"Geoplot"},{"location":"plot-types/geography/geoplot/#geoplot","text":"1 geoplot ( lat , lon ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double lat_seattle = 47.62 ; double lon_seattle = -122.33 ; double lat_anchorage = 61.20 ; double lon_anchorage = -149.9 ; geoplot ( std :: vector { lat_seattle , lat_anchorage }, std :: vector { lon_seattle , lon_anchorage }, \"g-*\" ); geolimits ({ 45 , 62 }, { -155 , -120 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double lat_seattle = 47.62 ; double lon_seattle = -122.33 ; double lat_anchorage = 61.20 ; double lon_anchorage = -149.9 ; geoplot ( std :: vector { lat_seattle , lat_anchorage }, std :: vector { lon_seattle , lon_anchorage }, \"g-*\" ); geolimits ({ 45 , 62 }, { -155 , -120 }); text ( lon_anchorage , lat_anchorage , \"Anchorage\" ); text ( lon_seattle , lat_seattle , \"Seattle\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ lon , lat , names ] = world_cities ( 6 , 8 ); auto [ lon_star , lat_star ] = greedy_tsp ( lon , lat ); geoplot ( lat_star , lon_star ) -> marker ( \"o\" ) . marker_colors ( iota ( 1. , static_cast < double > ( names . size ()))); text ( lon , lat , names ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double lat_seattle = 47.62 ; double lon_seattle = -122.33 ; double lat_anchorage = 61.20 ; double lon_anchorage = -149.9 ; double lat_pt_barrow = 71.38 ; double lon_pt_barrow = -156.47 ; geoplot ( std :: vector { lat_seattle , lat_anchorage }, std :: vector { lon_seattle , lon_anchorage }, \"y-\" ); hold ( on ); geoplot ( std :: vector { lat_seattle , lat_pt_barrow }, std :: vector { lon_seattle , lon_pt_barrow }, \"b:\" ); geolimits ( 44 , 75 , -170 , -100 ); text ( lon_anchorage , lat_anchorage , \"Anchorage\" ); text ( lon_seattle , lat_seattle , \"Seattle\" ); text ( lon_pt_barrow , lat_pt_barrow , \"Point Barrow\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double lat_seattle = 47.62 ; double lon_seattle = -122.33 ; double lat_anchorage = 61.20 ; double lon_anchorage = -149.9 ; auto g = geoplot ( std :: vector { lat_seattle , lat_anchorage }, std :: vector { lon_seattle , lon_anchorage }); g -> line_width ( 2. ); hold ( on ); geolimits ({ 44 , 75 }, { -170 , -100 }); text ( lon_anchorage , lat_anchorage , \"Anchorage\" ); text ( lon_seattle , lat_seattle , \"Seattle\" ); color_array terrain = { 0. , 0.71 , 0.65 , 0.59 }; geoplot () -> color ( terrain ); color_array blue_water = { 0. , 0.4 , 0.61 , 0.76 }; gca () -> color ( blue_water ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 #include <matplot/matplot.h> #include <random> using namespace matplot ; using namespace std ; class eurotrip_solver { public : eurotrip_solver ( const vector < double > & lat , const vector < double > & lon , const vector < string > & names , axes_handle ax ); void run ( size_t iterations = 100 ); private : void setup_starting_point ( size_t iteration ); double tour_distance ( const vector < size_t > & tour ); void iteration (); static vector < vector < size_t >> get_neighbors ( const std :: vector < size_t > & tour ); bool update_if_better ( const vector < size_t > & neighbor ); void draw_if_improvement (); void draw (); private : vector < double > lat_ ; vector < double > lon_ ; vector < string > names_ ; axes_handle ax_ ; // Current tour double curr_dist_ { 0.0 }; vector < size_t > curr_tour_ ; // Best tour double min_dist_ { 0.0 }; vector < size_t > best_tour_ ; }; eurotrip_solver :: eurotrip_solver ( const vector < double > & lat , const vector < double > & lon , const vector < string > & names , axes_handle ax ) : lat_ ( lat ), lon_ ( lon ), names_ ( names ), ax_ ( ax ) {} void eurotrip_solver :: run ( size_t iterations ) { for ( size_t i = 0 ; i < iterations ; ++ i ) { setup_starting_point ( i ); iteration (); } ax_ -> draw (); ax_ -> parent () -> save ( \"eurotrip.svg\" ); } void eurotrip_solver :: setup_starting_point ( size_t iteration ) { std :: cout << \"Starting point \" << iteration << std :: endl ; if ( iteration < names_ . size ()) { auto [ lon_ignore , lat_ignore , tour ] = greedy_tsp_with_idx ( lon_ , lat_ , iteration ); curr_tour_ = tour ; curr_dist_ = tour_distance ( curr_tour_ ); } else { static std :: mt19937 g (( std :: random_device ())()); std :: iota ( curr_tour_ . begin (), curr_tour_ . end (), 0 ); std :: shuffle ( curr_tour_ . begin (), curr_tour_ . end (), g ); curr_dist_ = tour_distance ( curr_tour_ ); } if ( iteration == 0 || curr_dist_ < min_dist_ ) { best_tour_ = curr_tour_ ; min_dist_ = curr_dist_ ; } } vector < vector < size_t >> eurotrip_solver :: get_neighbors ( const std :: vector < size_t > & tour ) { vector < vector < size_t >> neighbors ; constexpr size_t n_movements = 2 ; for ( size_t i = 0 ; i < tour . size () - 1 ; ++ i ) { for ( size_t j = i + 1 ; j < tour . size (); ++ j ) { for ( size_t movement = 0 ; movement < n_movements ; ++ movement ) { vector < size_t > neighbor = tour ; if ( movement == 0 ) { std :: swap ( neighbor [ i ], neighbor [ j ]); } else { std :: reverse ( neighbor . begin () + i , neighbor . begin () + j + 1 ); } neighbors . emplace_back ( neighbor ); } } } return neighbors ; } void eurotrip_solver :: iteration () { bool improvement = true ; while ( improvement ) { improvement = false ; for ( const auto & neighbor : get_neighbors ( curr_tour_ )) { improvement = update_if_better ( neighbor ); draw_if_improvement (); if ( improvement ) { break ; } } } } double eurotrip_solver :: tour_distance ( const vector < size_t > & tour ) { double sum = 0. ; for ( size_t i = 0 ; i < tour . size () - 1 ; ++ i ) { sum += distance ( lon_ [ tour [ i ]], lat_ [ tour [ i ]], lon_ [ tour [ i + 1 ]], lat_ [ tour [ i + 1 ]]); } sum += distance ( lon_ [ tour [ tour . size () - 1 ]], lat_ [ tour [ tour . size () - 1 ]], lon_ [ tour [ 0 ]], lat_ [ tour [ 0 ]]); return sum ; } void eurotrip_solver :: draw () { ax_ -> clear (); ax_ -> geolimits ( min ( lat_ ) - 5 , max ( lat_ ) + 5 , min ( lon_ ) - 2 , max ( lon_ ) + 10 ); vector < double > sorted_lat ; vector < double > sorted_lon ; for ( const size_t & idx : best_tour_ ) { sorted_lat . emplace_back ( lat_ [ idx ]); sorted_lon . emplace_back ( lon_ [ idx ]); } sorted_lat . emplace_back ( lat_ [ best_tour_ [ 0 ]]); sorted_lon . emplace_back ( lon_ [ best_tour_ [ 0 ]]); ax_ -> geoplot ( sorted_lat , sorted_lon ); ax_ -> hold ( true ); ax_ -> geoscatter ( lat_ , lon_ ); auto [ lon_c , lat_c , names_c ] = clear_overlapping_labels ( lon_ , lat_ , names_ , 1 , 1 ); ax_ -> text ( lon_c , lat_c , names_c ); ax_ -> title ( \"Tour distance \" + num2str ( min_dist_ )); ax_ -> draw (); } bool eurotrip_solver :: update_if_better ( const vector < size_t > & neighbor ) { double d = tour_distance ( neighbor ); if ( d < curr_dist_ ) { curr_tour_ = neighbor ; curr_dist_ = d ; if ( d < min_dist_ ) { best_tour_ = curr_tour_ ; min_dist_ = d ; } return true ; } return false ; } void eurotrip_solver :: draw_if_improvement () { static auto last_draw = chrono :: high_resolution_clock :: now () - chrono :: seconds ( 1 ); static auto min_dist_when_last_draw = min_dist_ ; const auto current_time = chrono :: high_resolution_clock :: now (); const bool its_been_a_while = current_time - last_draw > chrono :: seconds ( 1 ); const bool things_are_better = min_dist_ < min_dist_when_last_draw ; if ( its_been_a_while && things_are_better ) { last_draw = current_time ; min_dist_when_last_draw = min_dist_ ; draw (); } } int main () { vector < string > names = { \"Tirana\" , \"Andorra la Vella\" , \"Vienna\" , \"Minsk\" , \"Brussels\" , \"Sarajevo\" , \"Sofia\" , \"Zagreb\" , \"Prague\" , \"Copenhagen\" , \"Tallinn\" , \"Helsinki\" , \"Paris\" , \"Berlin\" , \"Athens\" , \"Budapest\" , \"Reykjavik\" , \"Dublin\" , \"Rome\" , \"Pristina\" , \"Riga\" , \"Vaduz\" , \"Vilnius\" , \"Luxembourg\" , \"Valletta\" , \"Chisinau\" , \"Monaco\" , \"Podgorica\" , \"Amsterdam\" , \"Skopje\" , \"Oslo\" , \"Warsaw\" , \"Lisbon\" , \"Bucharest\" , \"Moscow\" , \"San Marino\" , \"Belgrade\" , \"Bratislava\" , \"Ljubljana\" , \"Madrid\" , \"Stockholm\" , \"Bern\" , \"Kiev\" , \"London\" }; vector < double > lat = { + 41.3317 , + 42.5075 , + 48.2092 , + 53.9678 , + 50.8371 , + 43.8608 , + 42.7105 , + 45.8150 , + 50.0878 , + 55.6763 , + 59.4389 , + 60.1699 , + 48.8567 , + 52.5235 , + 37.9792 , + 47.4984 , + 64.1353 , + 53.3441 , + 41.8955 , + 42.6740 , + 56.9465 , + 47.1411 , + 54.6896 , + 49.6100 , + 35.9042 , + 47.0167 , + 43.7325 , + 42.4602 , + 52.3738 , + 42.0024 , + 59.9138 , + 52.2297 , + 38.7072 , + 44.4479 , + 55.7558 , + 43.9424 , + 44.8048 , + 48.2116 , + 46.0514 , + 40.4167 , + 59.3328 , + 46.9480 , + 50.4422 , + 51.5002 }; vector < double > lon = { + 19.8172 , + 1.5218 , + 16.3728 , + 27.5766 , + 4.3676 , + 18.4214 , + 23.3238 , + 15.9785 , + 14.4205 , + 12.5681 , + 24.7545 , + 24.9384 , + 2.3510 , + 13.4115 , + 23.7166 , + 19.0408 , -21.8952 , -6.2675 , + 12.4823 , + 21.1788 , + 24.1049 , + 9.5215 , + 25.2799 , + 6.1296 , + 14.5189 , + 28.8497 , + 7.4189 , + 19.2595 , + 4.8910 , + 21.4361 , + 10.7387 , + 21.0122 , -9.1355 , + 26.0979 , + 37.6176 , + 12.4578 , + 20.4781 , + 17.1547 , + 14.5060 , -3.7033 , + 18.0645 , + 7.4481 , + 30.5367 , -0.1262 }; std :: cout << names . size () << \" cities\" << std :: endl ; figure_handle f = figure ( true ); eurotrip_solver s ( lat , lon , names , f -> current_axes ()); s . run (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 #include <matplot/matplot.h> #include <random> using namespace matplot ; using namespace std ; class americas_trip_solver { public : americas_trip_solver ( const vector < double > & lat , const vector < double > & lon , const vector < string > & names , axes_handle ax ); void run ( size_t iterations = 100 ); private : void setup_axes (); void setup_starting_point ( size_t iteration ); double tour_distance ( const vector < size_t > & tour ); void iteration (); static vector < vector < size_t >> get_neighbors ( const std :: vector < size_t > & tour ); bool update_if_better ( const vector < size_t > & neighbor ); void draw_if_improvement (); void draw (); private : vector < double > lat_ ; vector < double > lon_ ; vector < string > names_ ; axes_handle ax_ ; line_handle lh_ ; // Current tour double curr_dist_ { 0.0 }; vector < size_t > curr_tour_ ; // Best tour double min_dist_ { 0.0 }; vector < size_t > best_tour_ ; }; americas_trip_solver :: americas_trip_solver ( const vector < double > & lat , const vector < double > & lon , const vector < string > & names , axes_handle ax ) : lat_ ( lat ), lon_ ( lon ), names_ ( names ), ax_ ( ax ) { setup_axes (); } void americas_trip_solver :: run ( size_t iterations ) { for ( size_t i = 0 ; i < iterations ; ++ i ) { setup_starting_point ( i ); iteration (); } ax_ -> draw (); ax_ -> parent () -> save ( \"americastrip.svg\" ); } void americas_trip_solver :: setup_starting_point ( size_t iteration ) { std :: cout << \"Starting point \" << iteration << std :: endl ; if ( iteration < names_ . size ()) { auto [ lon_ignore , lat_ignore , tour ] = greedy_tsp_with_idx ( lon_ , lat_ , iteration ); curr_tour_ = tour ; curr_dist_ = tour_distance ( curr_tour_ ); } else { static std :: mt19937 g (( std :: random_device ())()); std :: iota ( curr_tour_ . begin (), curr_tour_ . end (), 0 ); std :: shuffle ( curr_tour_ . begin (), curr_tour_ . end (), g ); curr_dist_ = tour_distance ( curr_tour_ ); } if ( iteration == 0 || curr_dist_ < min_dist_ ) { best_tour_ = curr_tour_ ; min_dist_ = curr_dist_ ; } } vector < vector < size_t >> americas_trip_solver :: get_neighbors ( const std :: vector < size_t > & tour ) { vector < vector < size_t >> neighbors ; constexpr size_t n_movements = 2 ; for ( size_t i = 0 ; i < tour . size () - 1 ; ++ i ) { for ( size_t j = i + 1 ; j < tour . size (); ++ j ) { for ( size_t movement = 0 ; movement < n_movements ; ++ movement ) { vector < size_t > neighbor = tour ; if ( movement == 0 ) { std :: swap ( neighbor [ i ], neighbor [ j ]); } else { std :: reverse ( neighbor . begin () + i , neighbor . begin () + j + 1 ); } neighbors . emplace_back ( neighbor ); } } } return neighbors ; } void americas_trip_solver :: iteration () { bool improvement = true ; while ( improvement ) { improvement = false ; for ( const auto & neighbor : get_neighbors ( curr_tour_ )) { improvement = update_if_better ( neighbor ); draw_if_improvement (); if ( improvement ) { break ; } } } } double americas_trip_solver :: tour_distance ( const vector < size_t > & tour ) { double sum = 0. ; for ( size_t i = 0 ; i < tour . size () - 1 ; ++ i ) { sum += distance ( lon_ [ tour [ i ]], lat_ [ tour [ i ]], lon_ [ tour [ i + 1 ]], lat_ [ tour [ i + 1 ]]); } sum += distance ( lon_ [ tour [ tour . size () - 1 ]], lat_ [ tour [ tour . size () - 1 ]], lon_ [ tour [ 0 ]], lat_ [ tour [ 0 ]]); return sum ; } void americas_trip_solver :: draw () { vector < double > sorted_lat ; vector < double > sorted_lon ; for ( const size_t & idx : best_tour_ ) { sorted_lat . emplace_back ( lat_ [ idx ]); sorted_lon . emplace_back ( lon_ [ idx ]); } sorted_lat . emplace_back ( lat_ [ best_tour_ [ 0 ]]); sorted_lon . emplace_back ( lon_ [ best_tour_ [ 0 ]]); lh_ -> x_data ( sorted_lon ); lh_ -> y_data ( sorted_lat ); ax_ -> title ( \"Tour distance \" + num2str ( min_dist_ )); ax_ -> draw (); } bool americas_trip_solver :: update_if_better ( const vector < size_t > & neighbor ) { double d = tour_distance ( neighbor ); if ( d < curr_dist_ ) { curr_tour_ = neighbor ; curr_dist_ = d ; if ( d < min_dist_ ) { best_tour_ = curr_tour_ ; min_dist_ = d ; } return true ; } return false ; } void americas_trip_solver :: draw_if_improvement () { static auto last_draw = chrono :: high_resolution_clock :: now () - chrono :: seconds ( 1 ); static auto min_dist_when_last_draw = min_dist_ ; const auto current_time = chrono :: high_resolution_clock :: now (); const bool its_been_a_while = current_time - last_draw > chrono :: seconds ( 1 ); const bool things_are_better = min_dist_ < min_dist_when_last_draw ; if ( its_been_a_while && things_are_better ) { last_draw = current_time ; min_dist_when_last_draw = min_dist_ ; draw (); } } void americas_trip_solver :: setup_axes () { ax_ -> clear (); ax_ -> geolimits ( min ( lat_ ) - 5 , max ( lat_ ) + 5 , min ( lon_ ) - 30 , max ( lon_ ) + 50 ); lh_ = ax_ -> geoplot ( lat_ , lon_ ); ax_ -> hold ( true ); ax_ -> geoscatter ( lat_ , lon_ ); auto [ lon_c , lat_c , names_c ] = clear_overlapping_labels ( lon_ , lat_ , names_ , 2 , 2 ); ax_ -> text ( lon_c , lat_c , names_c ); ax_ -> draw (); } int main () { vector < string > names = { \"Marigot\" , \"The Valley\" , \"Saint John's\" , \"Buenos Aires\" , \"Oranjestad\" , \"Nassau\" , \"Bridgetown\" , \"Belmopan\" , \"Hamilton\" , \"La Paz\" , \"Brasilia\" , \"Road Town\" , \"Ottawa\" , \"George Town\" , \"Santiago\" , \"Bogota\" , \"San Jose\" , \"Havana\" , \"Willemstad\" , \"Roseau\" , \"Santo Domingo\" , \"Quito\" , \"San Salvador\" , \"Stanley\" , \"Nuuk\" , \"Saint George's\" , \"Guatemala City\" , \"Georgetown\" , \"Port-au-Prince\" , \"Tegucigalpa\" , \"Kingston\" , \"Mexico City\" , \"Plymouth\" , \"Managua\" , \"Panama City\" , \"Asuncion\" , \"Lima\" , \"San Juan\" , \"Gustavia\" , \"Basseterre\" , \"Castries\" , \"Saint-Pierre\" , \"Kingstown\" , \"Philipsburg\" , \"Paramaribo\" , \"Port of Spain\" , \"Grand Turk\" , \"Washington\" , \"Montevideo\" , \"Caracas\" , \"Charlotte Amalie\" }; vector < double > lat = { 18.0731 , 18.2166 , 17.1166 , -34.5833 , 12.5166 , 25.0833 , 13.1 , 17.25 , 32.2833 , -16.5 , -15.7833 , 18.4166 , 45.4166 , 19.3 , -33.45 , 4.6 , 9.9333 , 23.1166 , 12.1 , 15.3 , 18.4666 , -0.2166 , 13.7 , -51.7 , 64.1833 , 12.05 , 14.6166 , 6.8 , 18.5333 , 14.1 , 18 , 19.4333 , 16.7 , 12.1333 , 8.9666 , -25.2666 , -12.05 , 18.4666 , 17.8833 , 17.3 , 14 , 46.7666 , 13.1333 , 18.0166 , 5.8333 , 10.65 , 21.4666 , 38.8833 , -34.85 , 10.4833 , 18.35 }; vector < double > lon = { -63.0822 , -63.0500 , -61.8500 , -58.6666 , -70.0333 , -77.3500 , -59.6166 , -88.7666 , -64.7833 , -68.1500 , -47.9166 , -64.6166 , -75.7000 , -81.3833 , -70.6666 , -74.0833 , -84.0833 , -82.3500 , -68.9166 , -61.4000 , -69.9000 , -78.5000 , -89.2000 , -57.8500 , -51.7500 , -61.7500 , -90.5166 , -58.1500 , -72.3333 , -87.2166 , -76.8000 , -99.1333 , -62.2166 , -86.2500 , -79.5333 , -57.6666 , -77.0500 , -66.1166 , -62.8500 , -62.7166 , -61.0000 , -56.1833 , -61.2166 , -63.0333 , -55.1666 , -61.5166 , -71.1333 , -77.0000 , -56.1666 , -66.8666 , -64.9333 }; figure_handle f = figure ( true ); americas_trip_solver s ( lat , lon , names , f -> current_axes ()); s . run (); show (); return 0 ; } For the first geography plot, Matplot++ calls geoplot() , which creates a filled polygon with the world map. This first plot receives the tag \"map\" so that subsequent geography plots recognize there is no need to recreate this world map. The data for the world map comes from Natural Earth. They provide data at 1:10m, 1:50m, and 1:110m scales. The geoplot function will initially use the data at the 1:110m scales. The geolimits function can be used to update the axis limits for geography plots. The difference between the usual functions for adjusting axis limits ( xlim and ylim ) and geolimits is that the latter will also update the map resolution according to the new limits for the and axis. The geolimits function will query the figure size and, depending on the new limits for the axes, update the map to the 1:10m, or 1:50m scales if needed. Because it would be very inefficient to render the whole world map at a 1:10m or 1:50m scale only to display a region of this map, the geolimits function also crops the data pertinent to the new region being displayed. Note that this does not only involve removing data points outside the new limits but it also needs to create new data points on the correct borders to create new polygons coherent with the map entry points in the region. For this reason, the algorithm needs to track all submaps represented as closed polygons in the original world map. If submaps are completely inside or outside the new ranges, we can respectively include or dismiss the data points. However, if the submap is only partially inside the new limits, to generate the correct borders for the polygons, we need to track all points outside the limits to classify the directions of these points outside the limits. We do that by only including points that change quadrants around the new limits so that the map entry points create polygons that look like they would if the complete world map were still being rendered outside these new limits. If the you are not interested in geographic plots, the build script includes an option to remove the high-resolution maps at 1:10m and 1:50m scales from the library. In this case, the library will always use the map at a 1:110m scale no matter the axis limits. The function world_cities returns a list of major world cities. Its parameters define the minimum distances between cities in the and axes. The greedy_tsp function is a naive greedy algorithm to find a route between these cities as a Traveling Salesman Problem (TSP). We use the geoplot function to draw this route. Note that we use method chaining to define some further plot properties. Finally, the text function includes the city names in the map.","title":"Geoplot"},{"location":"plot-types/geography/geoscatter-plot/","text":"Geoscatter Plot 1 geoscatter ( lat , lon ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > lon = iota ( -170 , 10 , 170 ); std :: vector < double > lat = transform ( lon , []( double x ) { return 50. * cosd ( 3 * x ); }); std :: vector < double > A = transform ( lon , []( double lon ) { return ( 101. + 100 * ( sind ( 2 * lon ))) / 7 ; }); std :: vector < double > C = transform ( lon , []( double lon ) { return cosd ( 4 * lon ); }); geoscatter ( lat , lon , A , C ) -> marker_style ( line_spec :: marker_style :: upward_pointing_triangle ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > lon = iota ( -170 , 10 , 170 ); std :: vector < double > lat = transform ( lon , []( double lon ) { return 50. * cosd ( 3 * lon ); }); std :: vector < double > A = transform ( lon , []( double lon ) { return ( 101. + 100 * ( sind ( 2 * lon ))) / 7 ; }); std :: vector < double > C = transform ( lon , []( double lon ) { return cosd ( 4 * lon ); }); geoscatter ( lat , lon , A , C ) -> marker_style ( line_spec :: marker_style :: upward_pointing_triangle ); color_array terrain = { 0. , 0.71 , 0.65 , 0.59 }; geoplot () -> color ( terrain ); color_array blue_water = { 0. , 0.4 , 0.61 , 0.76 }; gca () -> color ( blue_water ); show (); return 0 ; }","title":"Geoscatter Plot"},{"location":"plot-types/geography/geoscatter-plot/#geoscatter-plot","text":"1 geoscatter ( lat , lon ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > lon = iota ( -170 , 10 , 170 ); std :: vector < double > lat = transform ( lon , []( double x ) { return 50. * cosd ( 3 * x ); }); std :: vector < double > A = transform ( lon , []( double lon ) { return ( 101. + 100 * ( sind ( 2 * lon ))) / 7 ; }); std :: vector < double > C = transform ( lon , []( double lon ) { return cosd ( 4 * lon ); }); geoscatter ( lat , lon , A , C ) -> marker_style ( line_spec :: marker_style :: upward_pointing_triangle ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > lon = iota ( -170 , 10 , 170 ); std :: vector < double > lat = transform ( lon , []( double lon ) { return 50. * cosd ( 3 * lon ); }); std :: vector < double > A = transform ( lon , []( double lon ) { return ( 101. + 100 * ( sind ( 2 * lon ))) / 7 ; }); std :: vector < double > C = transform ( lon , []( double lon ) { return cosd ( 4 * lon ); }); geoscatter ( lat , lon , A , C ) -> marker_style ( line_spec :: marker_style :: upward_pointing_triangle ); color_array terrain = { 0. , 0.71 , 0.65 , 0.59 }; geoplot () -> color ( terrain ); color_array blue_water = { 0. , 0.4 , 0.61 , 0.76 }; gca () -> color ( blue_water ); show (); return 0 ; }","title":"Geoscatter Plot"},{"location":"plot-types/graphs/directed-graph/","text":"Directed Graph 1 digraph ( edges ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> std :: vector < std :: pair < size_t , size_t >> get_edges (); int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 3 }, { 0 , 4 }, { 1 , 5 }, { 1 , 6 }, { 1 , 7 }, { 1 , 8 }, { 1 , 9 }, { 1 , 10 }, { 1 , 11 }, { 1 , 12 }, { 1 , 13 }, { 1 , 14 }, { 14 , 15 }, { 14 , 16 }, { 14 , 17 }, { 14 , 18 }, { 14 , 19 }}; digraph ( edges ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 3 }, { 1 , 4 }, { 1 , 5 }, { 2 , 4 }, { 2 , 6 }, { 3 , 5 }, { 3 , 6 }, { 4 , 7 }, { 5 , 7 }, { 6 , 7 }}; auto g = digraph ( edges ); g -> edge_labels ( { \"x\" , \"y\" , \"z\" , \"y\" , \"z\" , \"x\" , \"z\" , \"x\" , \"y\" , \"z\" , \"y\" , \"x\" }); g -> node_labels ( { \"{0}\" , \"{x}\" , \"{y}\" , \"{z}\" , \"{x,y}\" , \"{x,z}\" , \"{y,z}\" , \"{x,y,z}\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 9 }, { 1 , 3 }, { 1 , 11 }, { 2 , 3 }, { 2 , 4 }, { 3 , 5 }, { 4 , 5 }, { 4 , 6 }, { 5 , 8 }, { 6 , 7 }, { 6 , 9 }, { 7 , 8 }, { 7 , 10 }, { 8 , 11 }, { 9 , 10 }, { 10 , 11 }}; auto g = digraph ( edges ); g -> marker ( \"s\" ); g -> node_color ( \"red\" ); g -> marker_size ( 7 ); g -> line_style ( \"--\" ); g -> x_data ({ 2 , 4 , 1.5 , 3.5 , 1 , 3 , 1 , 2.1 , 3 , 2 , 3.1 , 4 }); g -> y_data ({ 3 , 3 , 3.5 , 3.5 , 4 , 4 , 2 , 2 , 2 , 1 , 1 , 1 }); show (); return 0 ; }","title":"Directed Graph"},{"location":"plot-types/graphs/directed-graph/#directed-graph","text":"1 digraph ( edges ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> std :: vector < std :: pair < size_t , size_t >> get_edges (); int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 3 }, { 0 , 4 }, { 1 , 5 }, { 1 , 6 }, { 1 , 7 }, { 1 , 8 }, { 1 , 9 }, { 1 , 10 }, { 1 , 11 }, { 1 , 12 }, { 1 , 13 }, { 1 , 14 }, { 14 , 15 }, { 14 , 16 }, { 14 , 17 }, { 14 , 18 }, { 14 , 19 }}; digraph ( edges ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 3 }, { 1 , 4 }, { 1 , 5 }, { 2 , 4 }, { 2 , 6 }, { 3 , 5 }, { 3 , 6 }, { 4 , 7 }, { 5 , 7 }, { 6 , 7 }}; auto g = digraph ( edges ); g -> edge_labels ( { \"x\" , \"y\" , \"z\" , \"y\" , \"z\" , \"x\" , \"z\" , \"x\" , \"y\" , \"z\" , \"y\" , \"x\" }); g -> node_labels ( { \"{0}\" , \"{x}\" , \"{y}\" , \"{z}\" , \"{x,y}\" , \"{x,z}\" , \"{y,z}\" , \"{x,y,z}\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 9 }, { 1 , 3 }, { 1 , 11 }, { 2 , 3 }, { 2 , 4 }, { 3 , 5 }, { 4 , 5 }, { 4 , 6 }, { 5 , 8 }, { 6 , 7 }, { 6 , 9 }, { 7 , 8 }, { 7 , 10 }, { 8 , 11 }, { 9 , 10 }, { 10 , 11 }}; auto g = digraph ( edges ); g -> marker ( \"s\" ); g -> node_color ( \"red\" ); g -> marker_size ( 7 ); g -> line_style ( \"--\" ); g -> x_data ({ 2 , 4 , 1.5 , 3.5 , 1 , 3 , 1 , 2.1 , 3 , 2 , 3.1 , 4 }); g -> y_data ({ 3 , 3 , 3.5 , 3.5 , 4 , 4 , 2 , 2 , 2 , 1 , 1 , 1 }); show (); return 0 ; }","title":"Directed Graph"},{"location":"plot-types/graphs/undirected-graph/","text":"Undirected Graph 1 graph ( edges ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <cmath> #include <matplot/matplot.h> std :: vector < std :: pair < size_t , size_t >> get_edges (); int main () { using namespace matplot ; auto edges = get_edges (); graph ( edges ); show (); return 0 ; } std :: vector < std :: pair < size_t , size_t >> get_edges () { return { { 0 , 0 }, { 1 , 0 }, { 5 , 0 }, { 0 , 1 }, { 1 , 1 }, { 2 , 1 }, { 6 , 1 }, { 1 , 2 }, { 2 , 2 }, { 3 , 2 }, { 7 , 2 }, { 2 , 3 }, { 3 , 3 }, { 4 , 3 }, { 8 , 3 }, { 3 , 4 }, { 4 , 4 }, { 9 , 4 }, { 0 , 5 }, { 5 , 5 }, { 6 , 5 }, { 10 , 5 }, { 1 , 6 }, { 5 , 6 }, { 6 , 6 }, { 7 , 6 }, { 11 , 6 }, { 2 , 7 }, { 6 , 7 }, { 7 , 7 }, { 8 , 7 }, { 12 , 7 }, { 3 , 8 }, { 7 , 8 }, { 8 , 8 }, { 9 , 8 }, { 13 , 8 }, { 4 , 9 }, { 8 , 9 }, { 9 , 9 }, { 14 , 9 }, { 5 , 10 }, { 10 , 10 }, { 11 , 10 }, { 15 , 10 }, { 6 , 11 }, { 10 , 11 }, { 11 , 11 }, { 12 , 11 }, { 16 , 11 }, { 7 , 12 }, { 11 , 12 }, { 12 , 12 }, { 13 , 12 }, { 17 , 12 }, { 8 , 13 }, { 12 , 13 }, { 13 , 13 }, { 14 , 13 }, { 18 , 13 }, { 9 , 14 }, { 13 , 14 }, { 14 , 14 }, { 19 , 14 }, { 10 , 15 }, { 15 , 15 }, { 16 , 15 }, { 20 , 15 }, { 11 , 16 }, { 15 , 16 }, { 16 , 16 }, { 17 , 16 }, { 21 , 16 }, { 12 , 17 }, { 16 , 17 }, { 17 , 17 }, { 18 , 17 }, { 22 , 17 }, { 13 , 18 }, { 17 , 18 }, { 18 , 18 }, { 19 , 18 }, { 23 , 18 }, { 14 , 19 }, { 18 , 19 }, { 19 , 19 }, { 24 , 19 }, { 15 , 20 }, { 20 , 20 }, { 21 , 20 }, { 25 , 20 }, { 16 , 21 }, { 20 , 21 }, { 21 , 21 }, { 22 , 21 }, { 26 , 21 }, { 17 , 22 }, { 21 , 22 }, { 22 , 22 }, { 23 , 22 }, { 27 , 22 }, { 18 , 23 }, { 22 , 23 }, { 23 , 23 }, { 24 , 23 }, { 28 , 23 }, { 19 , 24 }, { 23 , 24 }, { 24 , 24 }, { 29 , 24 }, { 20 , 25 }, { 25 , 25 }, { 26 , 25 }, { 35 , 25 }, { 21 , 26 }, { 25 , 26 }, { 26 , 26 }, { 27 , 26 }, { 36 , 26 }, { 22 , 27 }, { 26 , 27 }, { 27 , 27 }, { 28 , 27 }, { 37 , 27 }, { 23 , 28 }, { 27 , 28 }, { 28 , 28 }, { 29 , 28 }, { 38 , 28 }, { 24 , 29 }, { 28 , 29 }, { 29 , 29 }, { 30 , 29 }, { 39 , 29 }, { 29 , 30 }, { 30 , 30 }, { 31 , 30 }, { 40 , 30 }, { 30 , 31 }, { 31 , 31 }, { 32 , 31 }, { 41 , 31 }, { 31 , 32 }, { 32 , 32 }, { 33 , 32 }, { 42 , 32 }, { 32 , 33 }, { 33 , 33 }, { 34 , 33 }, { 43 , 33 }, { 33 , 34 }, { 34 , 34 }, { 44 , 34 }, { 25 , 35 }, { 35 , 35 }, { 36 , 35 }, { 45 , 35 }, { 26 , 36 }, { 35 , 36 }, { 36 , 36 }, { 37 , 36 }, { 46 , 36 }, { 27 , 37 }, { 36 , 37 }, { 37 , 37 }, { 38 , 37 }, { 47 , 37 }, { 28 , 38 }, { 37 , 38 }, { 38 , 38 }, { 39 , 38 }, { 48 , 38 }, { 29 , 39 }, { 38 , 39 }, { 39 , 39 }, { 40 , 39 }, { 49 , 39 }, { 30 , 40 }, { 39 , 40 }, { 40 , 40 }, { 41 , 40 }, { 50 , 40 }, { 31 , 41 }, { 40 , 41 }, { 41 , 41 }, { 42 , 41 }, { 51 , 41 }, { 32 , 42 }, { 41 , 42 }, { 42 , 42 }, { 43 , 42 }, { 52 , 42 }, { 33 , 43 }, { 42 , 43 }, { 43 , 43 }, { 44 , 43 }, { 53 , 43 }, { 34 , 44 }, { 43 , 44 }, { 44 , 44 }, { 54 , 44 }, { 35 , 45 }, { 45 , 45 }, { 46 , 45 }, { 55 , 45 }, { 36 , 46 }, { 45 , 46 }, { 46 , 46 }, { 47 , 46 }, { 56 , 46 }, { 37 , 47 }, { 46 , 47 }, { 47 , 47 }, { 48 , 47 }, { 57 , 47 }, { 38 , 48 }, { 47 , 48 }, { 48 , 48 }, { 49 , 48 }, { 58 , 48 }, { 39 , 49 }, { 48 , 49 }, { 49 , 49 }, { 50 , 49 }, { 59 , 49 }, { 40 , 50 }, { 49 , 50 }, { 50 , 50 }, { 51 , 50 }, { 60 , 50 }, { 41 , 51 }, { 50 , 51 }, { 51 , 51 }, { 52 , 51 }, { 61 , 51 }, { 42 , 52 }, { 51 , 52 }, { 52 , 52 }, { 53 , 52 }, { 62 , 52 }, { 43 , 53 }, { 52 , 53 }, { 53 , 53 }, { 54 , 53 }, { 63 , 53 }, { 44 , 54 }, { 53 , 54 }, { 54 , 54 }, { 64 , 54 }, { 45 , 55 }, { 55 , 55 }, { 56 , 55 }, { 65 , 55 }, { 46 , 56 }, { 55 , 56 }, { 56 , 56 }, { 57 , 56 }, { 66 , 56 }, { 47 , 57 }, { 56 , 57 }, { 57 , 57 }, { 58 , 57 }, { 67 , 57 }, { 48 , 58 }, { 57 , 58 }, { 58 , 58 }, { 59 , 58 }, { 68 , 58 }, { 49 , 59 }, { 58 , 59 }, { 59 , 59 }, { 60 , 59 }, { 69 , 59 }, { 50 , 60 }, { 59 , 60 }, { 60 , 60 }, { 61 , 60 }, { 70 , 60 }, { 51 , 61 }, { 60 , 61 }, { 61 , 61 }, { 62 , 61 }, { 71 , 61 }, { 52 , 62 }, { 61 , 62 }, { 62 , 62 }, { 63 , 62 }, { 72 , 62 }, { 53 , 63 }, { 62 , 63 }, { 63 , 63 }, { 64 , 63 }, { 73 , 63 }, { 54 , 64 }, { 63 , 64 }, { 64 , 64 }, { 74 , 64 }, { 55 , 65 }, { 65 , 65 }, { 66 , 65 }, { 56 , 66 }, { 65 , 66 }, { 66 , 66 }, { 67 , 66 }, { 57 , 67 }, { 66 , 67 }, { 67 , 67 }, { 68 , 67 }, { 58 , 68 }, { 67 , 68 }, { 68 , 68 }, { 69 , 68 }, { 59 , 69 }, { 68 , 69 }, { 69 , 69 }, { 70 , 69 }, { 60 , 70 }, { 69 , 70 }, { 70 , 70 }, { 71 , 70 }, { 61 , 71 }, { 70 , 71 }, { 71 , 71 }, { 72 , 71 }, { 62 , 72 }, { 71 , 72 }, { 72 , 72 }, { 73 , 72 }, { 63 , 73 }, { 72 , 73 }, { 73 , 73 }, { 74 , 73 }, { 64 , 74 }, { 73 , 74 }, { 74 , 74 }}; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <cmath> #include <matplot/matplot.h> std :: vector < std :: pair < size_t , size_t >> get_edges (); int main () { using namespace matplot ; auto edges = get_edges (); graph ( edges , \"-.dr\" ) -> show_labels ( false ); show (); return 0 ; } std :: vector < std :: pair < size_t , size_t >> get_edges () { return { { 0 , 1 }, { 0 , 4 }, { 0 , 5 }, { 1 , 2 }, { 1 , 10 }, { 2 , 3 }, { 2 , 15 }, { 3 , 4 }, { 3 , 20 }, { 4 , 25 }, { 5 , 6 }, { 5 , 9 }, { 6 , 7 }, { 6 , 29 }, { 7 , 8 }, { 7 , 41 }, { 8 , 9 }, { 8 , 37 }, { 9 , 11 }, { 10 , 11 }, { 10 , 14 }, { 11 , 12 }, { 12 , 13 }, { 12 , 36 }, { 13 , 14 }, { 13 , 32 }, { 14 , 16 }, { 15 , 16 }, { 15 , 19 }, { 16 , 17 }, { 17 , 18 }, { 17 , 31 }, { 18 , 19 }, { 18 , 52 }, { 19 , 21 }, { 20 , 21 }, { 20 , 24 }, { 21 , 22 }, { 22 , 23 }, { 22 , 51 }, { 23 , 24 }, { 23 , 47 }, { 24 , 26 }, { 25 , 26 }, { 25 , 29 }, { 26 , 27 }, { 27 , 28 }, { 27 , 46 }, { 28 , 29 }, { 28 , 42 }, { 30 , 31 }, { 30 , 34 }, { 30 , 53 }, { 31 , 32 }, { 32 , 33 }, { 33 , 34 }, { 33 , 35 }, { 34 , 55 }, { 35 , 36 }, { 35 , 39 }, { 36 , 37 }, { 37 , 38 }, { 38 , 39 }, { 38 , 40 }, { 39 , 56 }, { 40 , 41 }, { 40 , 44 }, { 41 , 42 }, { 42 , 43 }, { 43 , 44 }, { 43 , 45 }, { 44 , 57 }, { 45 , 46 }, { 45 , 49 }, { 46 , 47 }, { 47 , 48 }, { 48 , 49 }, { 48 , 50 }, { 49 , 58 }, { 50 , 51 }, { 50 , 54 }, { 51 , 52 }, { 52 , 53 }, { 53 , 54 }, { 54 , 59 }, { 55 , 56 }, { 55 , 59 }, { 56 , 57 }, { 57 , 58 }, { 58 , 59 }}; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 3 }, { 0 , 4 }, { 0 , 6 }, { 0 , 9 }, { 1 , 5 }, { 1 , 6 }, { 2 , 5 }, { 2 , 9 }, { 3 , 7 }, { 3 , 9 }, { 4 , 6 }, { 4 , 7 }, { 5 , 8 }, { 5 , 10 }, { 6 , 8 }, { 7 , 8 }, { 7 , 10 }, { 9 , 10 }}; std :: vector < double > weights = { 1 , 1 , 1 , 1 , 3 , 3 , 2 , 4 , 1 , 6 , 2 , 8 , 8 , 9 , 3 , 2 , 10 , 12 , 15 , 16 }; auto g = graph ( edges ); g -> x_data ({ 0 , 0.5 , -0.5 , -0.5 , 0.5 , 0 , 1.5 , 0 , 2 , -1.5 , -2 }); g -> y_data ({ 0 , 0.5 , 0.5 , -0.5 , -0.5 , 2 , 0 , -2 , 0 , 0 , 0 }); g -> z_data ({ 5 , 3 , 3 , 3 , 3 , 0 , 1 , 0 , 0 , 1 , 0 }); g -> edge_labels ( weights ); view ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 3 }, { 0 , 4 }, { 1 , 2 }, { 1 , 5 }, { 2 , 5 }, { 3 , 4 }, { 3 , 6 }, { 4 , 6 }, { 5 , 6 }}; std :: vector < double > weights = { 50 , 10 , 20 , 80 , 90 , 90 , 30 , 20 , 100 , 40 , 60 }; auto g = graph ( edges ); g -> edge_labels ( weights ); double m_weight = max ( weights ); std :: vector < double > line_widths = transform ( weights , [ & ]( double w ) { return 5. * w / m_weight ; }); g -> line_widths ( line_widths ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include <matplot/matplot.h> #include <thread> std :: vector < std :: pair < size_t , size_t >> get_edges (); int main () { using namespace matplot ; auto edges = get_edges (); auto g = graph ( edges ); g -> layout_algorithm ( network :: layout :: force ); for ( int i = 0 ; i < 300 ; ++ i ) { g -> layout_iterations ( i ); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } show (); return 0 ; } std :: vector < std :: pair < size_t , size_t >> get_edges () { return { { 0 , 0 }, { 1 , 0 }, { 5 , 0 }, { 0 , 1 }, { 1 , 1 }, { 2 , 1 }, { 6 , 1 }, { 1 , 2 }, { 2 , 2 }, { 3 , 2 }, { 7 , 2 }, { 2 , 3 }, { 3 , 3 }, { 4 , 3 }, { 8 , 3 }, { 3 , 4 }, { 4 , 4 }, { 9 , 4 }, { 0 , 5 }, { 5 , 5 }, { 6 , 5 }, { 10 , 5 }, { 1 , 6 }, { 5 , 6 }, { 6 , 6 }, { 7 , 6 }, { 11 , 6 }, { 2 , 7 }, { 6 , 7 }, { 7 , 7 }, { 8 , 7 }, { 12 , 7 }, { 3 , 8 }, { 7 , 8 }, { 8 , 8 }, { 9 , 8 }, { 13 , 8 }, { 4 , 9 }, { 8 , 9 }, { 9 , 9 }, { 14 , 9 }, { 5 , 10 }, { 10 , 10 }, { 11 , 10 }, { 15 , 10 }, { 6 , 11 }, { 10 , 11 }, { 11 , 11 }, { 12 , 11 }, { 16 , 11 }, { 7 , 12 }, { 11 , 12 }, { 12 , 12 }, { 13 , 12 }, { 17 , 12 }, { 8 , 13 }, { 12 , 13 }, { 13 , 13 }, { 14 , 13 }, { 18 , 13 }, { 9 , 14 }, { 13 , 14 }, { 14 , 14 }, { 19 , 14 }, { 10 , 15 }, { 15 , 15 }, { 16 , 15 }, { 20 , 15 }, { 11 , 16 }, { 15 , 16 }, { 16 , 16 }, { 17 , 16 }, { 21 , 16 }, { 12 , 17 }, { 16 , 17 }, { 17 , 17 }, { 18 , 17 }, { 22 , 17 }, { 13 , 18 }, { 17 , 18 }, { 18 , 18 }, { 19 , 18 }, { 23 , 18 }, { 14 , 19 }, { 18 , 19 }, { 19 , 19 }, { 24 , 19 }, { 15 , 20 }, { 20 , 20 }, { 21 , 20 }, { 25 , 20 }, { 16 , 21 }, { 20 , 21 }, { 21 , 21 }, { 22 , 21 }, { 26 , 21 }, { 17 , 22 }, { 21 , 22 }, { 22 , 22 }, { 23 , 22 }, { 27 , 22 }, { 18 , 23 }, { 22 , 23 }, { 23 , 23 }, { 24 , 23 }, { 28 , 23 }, { 19 , 24 }, { 23 , 24 }, { 24 , 24 }, { 29 , 24 }, { 20 , 25 }, { 25 , 25 }, { 26 , 25 }, { 35 , 25 }, { 21 , 26 }, { 25 , 26 }, { 26 , 26 }, { 27 , 26 }, { 36 , 26 }, { 22 , 27 }, { 26 , 27 }, { 27 , 27 }, { 28 , 27 }, { 37 , 27 }, { 23 , 28 }, { 27 , 28 }, { 28 , 28 }, { 29 , 28 }, { 38 , 28 }, { 24 , 29 }, { 28 , 29 }, { 29 , 29 }, { 30 , 29 }, { 39 , 29 }, { 29 , 30 }, { 30 , 30 }, { 31 , 30 }, { 40 , 30 }, { 30 , 31 }, { 31 , 31 }, { 32 , 31 }, { 41 , 31 }, { 31 , 32 }, { 32 , 32 }, { 33 , 32 }, { 42 , 32 }, { 32 , 33 }, { 33 , 33 }, { 34 , 33 }, { 43 , 33 }, { 33 , 34 }, { 34 , 34 }, { 44 , 34 }, { 25 , 35 }, { 35 , 35 }, { 36 , 35 }, { 45 , 35 }, { 26 , 36 }, { 35 , 36 }, { 36 , 36 }, { 37 , 36 }, { 46 , 36 }, { 27 , 37 }, { 36 , 37 }, { 37 , 37 }, { 38 , 37 }, { 47 , 37 }, { 28 , 38 }, { 37 , 38 }, { 38 , 38 }, { 39 , 38 }, { 48 , 38 }, { 29 , 39 }, { 38 , 39 }, { 39 , 39 }, { 40 , 39 }, { 49 , 39 }, { 30 , 40 }, { 39 , 40 }, { 40 , 40 }, { 41 , 40 }, { 50 , 40 }, { 31 , 41 }, { 40 , 41 }, { 41 , 41 }, { 42 , 41 }, { 51 , 41 }, { 32 , 42 }, { 41 , 42 }, { 42 , 42 }, { 43 , 42 }, { 52 , 42 }, { 33 , 43 }, { 42 , 43 }, { 43 , 43 }, { 44 , 43 }, { 53 , 43 }, { 34 , 44 }, { 43 , 44 }, { 44 , 44 }, { 54 , 44 }, { 35 , 45 }, { 45 , 45 }, { 46 , 45 }, { 55 , 45 }, { 36 , 46 }, { 45 , 46 }, { 46 , 46 }, { 47 , 46 }, { 56 , 46 }, { 37 , 47 }, { 46 , 47 }, { 47 , 47 }, { 48 , 47 }, { 57 , 47 }, { 38 , 48 }, { 47 , 48 }, { 48 , 48 }, { 49 , 48 }, { 58 , 48 }, { 39 , 49 }, { 48 , 49 }, { 49 , 49 }, { 50 , 49 }, { 59 , 49 }, { 40 , 50 }, { 49 , 50 }, { 50 , 50 }, { 51 , 50 }, { 60 , 50 }, { 41 , 51 }, { 50 , 51 }, { 51 , 51 }, { 52 , 51 }, { 61 , 51 }, { 42 , 52 }, { 51 , 52 }, { 52 , 52 }, { 53 , 52 }, { 62 , 52 }, { 43 , 53 }, { 52 , 53 }, { 53 , 53 }, { 54 , 53 }, { 63 , 53 }, { 44 , 54 }, { 53 , 54 }, { 54 , 54 }, { 64 , 54 }, { 45 , 55 }, { 55 , 55 }, { 56 , 55 }, { 65 , 55 }, { 46 , 56 }, { 55 , 56 }, { 56 , 56 }, { 57 , 56 }, { 66 , 56 }, { 47 , 57 }, { 56 , 57 }, { 57 , 57 }, { 58 , 57 }, { 67 , 57 }, { 48 , 58 }, { 57 , 58 }, { 58 , 58 }, { 59 , 58 }, { 68 , 58 }, { 49 , 59 }, { 58 , 59 }, { 59 , 59 }, { 60 , 59 }, { 69 , 59 }, { 50 , 60 }, { 59 , 60 }, { 60 , 60 }, { 61 , 60 }, { 70 , 60 }, { 51 , 61 }, { 60 , 61 }, { 61 , 61 }, { 62 , 61 }, { 71 , 61 }, { 52 , 62 }, { 61 , 62 }, { 62 , 62 }, { 63 , 62 }, { 72 , 62 }, { 53 , 63 }, { 62 , 63 }, { 63 , 63 }, { 64 , 63 }, { 73 , 63 }, { 54 , 64 }, { 63 , 64 }, { 64 , 64 }, { 74 , 64 }, { 55 , 65 }, { 65 , 65 }, { 66 , 65 }, { 56 , 66 }, { 65 , 66 }, { 66 , 66 }, { 67 , 66 }, { 57 , 67 }, { 66 , 67 }, { 67 , 67 }, { 68 , 67 }, { 58 , 68 }, { 67 , 68 }, { 68 , 68 }, { 69 , 68 }, { 59 , 69 }, { 68 , 69 }, { 69 , 69 }, { 70 , 69 }, { 60 , 70 }, { 69 , 70 }, { 70 , 70 }, { 71 , 70 }, { 61 , 71 }, { 70 , 71 }, { 71 , 71 }, { 72 , 71 }, { 62 , 72 }, { 71 , 72 }, { 72 , 72 }, { 73 , 72 }, { 63 , 73 }, { 72 , 73 }, { 73 , 73 }, { 74 , 73 }, { 64 , 74 }, { 73 , 74 }, { 74 , 74 }}; } All these subcategories depend on the network class. Graphs are abstract structures that represent objects and relationships between these objects. The objects are represented as vertices and the relationships are depicted as edges. In an abstract graph, the vertices have no specific position in space. Mathematically, a graph does not depend on its layout. However, the graph layout has a large impact on its understandability. The network class can calculate appropriate positions for graph vertices with several algorithms: Kamada Kawai algorithm, Fruchterman-Reingold algorithm, circle layout, random layout, and automatic layout. The implementation of the Kamada Kawai and Fruchterman-Reingold algorithms depend on the NodeSoup library. The automatic layout uses the Kamada Kawai algorithm for small graphs and the Fruchterman-Reingold algorithm for larger graphs.","title":"Undirected Graph"},{"location":"plot-types/graphs/undirected-graph/#undirected-graph","text":"1 graph ( edges ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 #include <cmath> #include <matplot/matplot.h> std :: vector < std :: pair < size_t , size_t >> get_edges (); int main () { using namespace matplot ; auto edges = get_edges (); graph ( edges ); show (); return 0 ; } std :: vector < std :: pair < size_t , size_t >> get_edges () { return { { 0 , 0 }, { 1 , 0 }, { 5 , 0 }, { 0 , 1 }, { 1 , 1 }, { 2 , 1 }, { 6 , 1 }, { 1 , 2 }, { 2 , 2 }, { 3 , 2 }, { 7 , 2 }, { 2 , 3 }, { 3 , 3 }, { 4 , 3 }, { 8 , 3 }, { 3 , 4 }, { 4 , 4 }, { 9 , 4 }, { 0 , 5 }, { 5 , 5 }, { 6 , 5 }, { 10 , 5 }, { 1 , 6 }, { 5 , 6 }, { 6 , 6 }, { 7 , 6 }, { 11 , 6 }, { 2 , 7 }, { 6 , 7 }, { 7 , 7 }, { 8 , 7 }, { 12 , 7 }, { 3 , 8 }, { 7 , 8 }, { 8 , 8 }, { 9 , 8 }, { 13 , 8 }, { 4 , 9 }, { 8 , 9 }, { 9 , 9 }, { 14 , 9 }, { 5 , 10 }, { 10 , 10 }, { 11 , 10 }, { 15 , 10 }, { 6 , 11 }, { 10 , 11 }, { 11 , 11 }, { 12 , 11 }, { 16 , 11 }, { 7 , 12 }, { 11 , 12 }, { 12 , 12 }, { 13 , 12 }, { 17 , 12 }, { 8 , 13 }, { 12 , 13 }, { 13 , 13 }, { 14 , 13 }, { 18 , 13 }, { 9 , 14 }, { 13 , 14 }, { 14 , 14 }, { 19 , 14 }, { 10 , 15 }, { 15 , 15 }, { 16 , 15 }, { 20 , 15 }, { 11 , 16 }, { 15 , 16 }, { 16 , 16 }, { 17 , 16 }, { 21 , 16 }, { 12 , 17 }, { 16 , 17 }, { 17 , 17 }, { 18 , 17 }, { 22 , 17 }, { 13 , 18 }, { 17 , 18 }, { 18 , 18 }, { 19 , 18 }, { 23 , 18 }, { 14 , 19 }, { 18 , 19 }, { 19 , 19 }, { 24 , 19 }, { 15 , 20 }, { 20 , 20 }, { 21 , 20 }, { 25 , 20 }, { 16 , 21 }, { 20 , 21 }, { 21 , 21 }, { 22 , 21 }, { 26 , 21 }, { 17 , 22 }, { 21 , 22 }, { 22 , 22 }, { 23 , 22 }, { 27 , 22 }, { 18 , 23 }, { 22 , 23 }, { 23 , 23 }, { 24 , 23 }, { 28 , 23 }, { 19 , 24 }, { 23 , 24 }, { 24 , 24 }, { 29 , 24 }, { 20 , 25 }, { 25 , 25 }, { 26 , 25 }, { 35 , 25 }, { 21 , 26 }, { 25 , 26 }, { 26 , 26 }, { 27 , 26 }, { 36 , 26 }, { 22 , 27 }, { 26 , 27 }, { 27 , 27 }, { 28 , 27 }, { 37 , 27 }, { 23 , 28 }, { 27 , 28 }, { 28 , 28 }, { 29 , 28 }, { 38 , 28 }, { 24 , 29 }, { 28 , 29 }, { 29 , 29 }, { 30 , 29 }, { 39 , 29 }, { 29 , 30 }, { 30 , 30 }, { 31 , 30 }, { 40 , 30 }, { 30 , 31 }, { 31 , 31 }, { 32 , 31 }, { 41 , 31 }, { 31 , 32 }, { 32 , 32 }, { 33 , 32 }, { 42 , 32 }, { 32 , 33 }, { 33 , 33 }, { 34 , 33 }, { 43 , 33 }, { 33 , 34 }, { 34 , 34 }, { 44 , 34 }, { 25 , 35 }, { 35 , 35 }, { 36 , 35 }, { 45 , 35 }, { 26 , 36 }, { 35 , 36 }, { 36 , 36 }, { 37 , 36 }, { 46 , 36 }, { 27 , 37 }, { 36 , 37 }, { 37 , 37 }, { 38 , 37 }, { 47 , 37 }, { 28 , 38 }, { 37 , 38 }, { 38 , 38 }, { 39 , 38 }, { 48 , 38 }, { 29 , 39 }, { 38 , 39 }, { 39 , 39 }, { 40 , 39 }, { 49 , 39 }, { 30 , 40 }, { 39 , 40 }, { 40 , 40 }, { 41 , 40 }, { 50 , 40 }, { 31 , 41 }, { 40 , 41 }, { 41 , 41 }, { 42 , 41 }, { 51 , 41 }, { 32 , 42 }, { 41 , 42 }, { 42 , 42 }, { 43 , 42 }, { 52 , 42 }, { 33 , 43 }, { 42 , 43 }, { 43 , 43 }, { 44 , 43 }, { 53 , 43 }, { 34 , 44 }, { 43 , 44 }, { 44 , 44 }, { 54 , 44 }, { 35 , 45 }, { 45 , 45 }, { 46 , 45 }, { 55 , 45 }, { 36 , 46 }, { 45 , 46 }, { 46 , 46 }, { 47 , 46 }, { 56 , 46 }, { 37 , 47 }, { 46 , 47 }, { 47 , 47 }, { 48 , 47 }, { 57 , 47 }, { 38 , 48 }, { 47 , 48 }, { 48 , 48 }, { 49 , 48 }, { 58 , 48 }, { 39 , 49 }, { 48 , 49 }, { 49 , 49 }, { 50 , 49 }, { 59 , 49 }, { 40 , 50 }, { 49 , 50 }, { 50 , 50 }, { 51 , 50 }, { 60 , 50 }, { 41 , 51 }, { 50 , 51 }, { 51 , 51 }, { 52 , 51 }, { 61 , 51 }, { 42 , 52 }, { 51 , 52 }, { 52 , 52 }, { 53 , 52 }, { 62 , 52 }, { 43 , 53 }, { 52 , 53 }, { 53 , 53 }, { 54 , 53 }, { 63 , 53 }, { 44 , 54 }, { 53 , 54 }, { 54 , 54 }, { 64 , 54 }, { 45 , 55 }, { 55 , 55 }, { 56 , 55 }, { 65 , 55 }, { 46 , 56 }, { 55 , 56 }, { 56 , 56 }, { 57 , 56 }, { 66 , 56 }, { 47 , 57 }, { 56 , 57 }, { 57 , 57 }, { 58 , 57 }, { 67 , 57 }, { 48 , 58 }, { 57 , 58 }, { 58 , 58 }, { 59 , 58 }, { 68 , 58 }, { 49 , 59 }, { 58 , 59 }, { 59 , 59 }, { 60 , 59 }, { 69 , 59 }, { 50 , 60 }, { 59 , 60 }, { 60 , 60 }, { 61 , 60 }, { 70 , 60 }, { 51 , 61 }, { 60 , 61 }, { 61 , 61 }, { 62 , 61 }, { 71 , 61 }, { 52 , 62 }, { 61 , 62 }, { 62 , 62 }, { 63 , 62 }, { 72 , 62 }, { 53 , 63 }, { 62 , 63 }, { 63 , 63 }, { 64 , 63 }, { 73 , 63 }, { 54 , 64 }, { 63 , 64 }, { 64 , 64 }, { 74 , 64 }, { 55 , 65 }, { 65 , 65 }, { 66 , 65 }, { 56 , 66 }, { 65 , 66 }, { 66 , 66 }, { 67 , 66 }, { 57 , 67 }, { 66 , 67 }, { 67 , 67 }, { 68 , 67 }, { 58 , 68 }, { 67 , 68 }, { 68 , 68 }, { 69 , 68 }, { 59 , 69 }, { 68 , 69 }, { 69 , 69 }, { 70 , 69 }, { 60 , 70 }, { 69 , 70 }, { 70 , 70 }, { 71 , 70 }, { 61 , 71 }, { 70 , 71 }, { 71 , 71 }, { 72 , 71 }, { 62 , 72 }, { 71 , 72 }, { 72 , 72 }, { 73 , 72 }, { 63 , 73 }, { 72 , 73 }, { 73 , 73 }, { 74 , 73 }, { 64 , 74 }, { 73 , 74 }, { 74 , 74 }}; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <cmath> #include <matplot/matplot.h> std :: vector < std :: pair < size_t , size_t >> get_edges (); int main () { using namespace matplot ; auto edges = get_edges (); graph ( edges , \"-.dr\" ) -> show_labels ( false ); show (); return 0 ; } std :: vector < std :: pair < size_t , size_t >> get_edges () { return { { 0 , 1 }, { 0 , 4 }, { 0 , 5 }, { 1 , 2 }, { 1 , 10 }, { 2 , 3 }, { 2 , 15 }, { 3 , 4 }, { 3 , 20 }, { 4 , 25 }, { 5 , 6 }, { 5 , 9 }, { 6 , 7 }, { 6 , 29 }, { 7 , 8 }, { 7 , 41 }, { 8 , 9 }, { 8 , 37 }, { 9 , 11 }, { 10 , 11 }, { 10 , 14 }, { 11 , 12 }, { 12 , 13 }, { 12 , 36 }, { 13 , 14 }, { 13 , 32 }, { 14 , 16 }, { 15 , 16 }, { 15 , 19 }, { 16 , 17 }, { 17 , 18 }, { 17 , 31 }, { 18 , 19 }, { 18 , 52 }, { 19 , 21 }, { 20 , 21 }, { 20 , 24 }, { 21 , 22 }, { 22 , 23 }, { 22 , 51 }, { 23 , 24 }, { 23 , 47 }, { 24 , 26 }, { 25 , 26 }, { 25 , 29 }, { 26 , 27 }, { 27 , 28 }, { 27 , 46 }, { 28 , 29 }, { 28 , 42 }, { 30 , 31 }, { 30 , 34 }, { 30 , 53 }, { 31 , 32 }, { 32 , 33 }, { 33 , 34 }, { 33 , 35 }, { 34 , 55 }, { 35 , 36 }, { 35 , 39 }, { 36 , 37 }, { 37 , 38 }, { 38 , 39 }, { 38 , 40 }, { 39 , 56 }, { 40 , 41 }, { 40 , 44 }, { 41 , 42 }, { 42 , 43 }, { 43 , 44 }, { 43 , 45 }, { 44 , 57 }, { 45 , 46 }, { 45 , 49 }, { 46 , 47 }, { 47 , 48 }, { 48 , 49 }, { 48 , 50 }, { 49 , 58 }, { 50 , 51 }, { 50 , 54 }, { 51 , 52 }, { 52 , 53 }, { 53 , 54 }, { 54 , 59 }, { 55 , 56 }, { 55 , 59 }, { 56 , 57 }, { 57 , 58 }, { 58 , 59 }}; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 3 }, { 0 , 4 }, { 0 , 6 }, { 0 , 9 }, { 1 , 5 }, { 1 , 6 }, { 2 , 5 }, { 2 , 9 }, { 3 , 7 }, { 3 , 9 }, { 4 , 6 }, { 4 , 7 }, { 5 , 8 }, { 5 , 10 }, { 6 , 8 }, { 7 , 8 }, { 7 , 10 }, { 9 , 10 }}; std :: vector < double > weights = { 1 , 1 , 1 , 1 , 3 , 3 , 2 , 4 , 1 , 6 , 2 , 8 , 8 , 9 , 3 , 2 , 10 , 12 , 15 , 16 }; auto g = graph ( edges ); g -> x_data ({ 0 , 0.5 , -0.5 , -0.5 , 0.5 , 0 , 1.5 , 0 , 2 , -1.5 , -2 }); g -> y_data ({ 0 , 0.5 , 0.5 , -0.5 , -0.5 , 2 , 0 , -2 , 0 , 0 , 0 }); g -> z_data ({ 5 , 3 , 3 , 3 , 3 , 0 , 1 , 0 , 0 , 1 , 0 }); g -> edge_labels ( weights ); view ( 2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: pair < size_t , size_t >> edges = { { 0 , 1 }, { 0 , 2 }, { 0 , 3 }, { 0 , 4 }, { 1 , 2 }, { 1 , 5 }, { 2 , 5 }, { 3 , 4 }, { 3 , 6 }, { 4 , 6 }, { 5 , 6 }}; std :: vector < double > weights = { 50 , 10 , 20 , 80 , 90 , 90 , 30 , 20 , 100 , 40 , 60 }; auto g = graph ( edges ); g -> edge_labels ( weights ); double m_weight = max ( weights ); std :: vector < double > line_widths = transform ( weights , [ & ]( double w ) { return 5. * w / m_weight ; }); g -> line_widths ( line_widths ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include <matplot/matplot.h> #include <thread> std :: vector < std :: pair < size_t , size_t >> get_edges (); int main () { using namespace matplot ; auto edges = get_edges (); auto g = graph ( edges ); g -> layout_algorithm ( network :: layout :: force ); for ( int i = 0 ; i < 300 ; ++ i ) { g -> layout_iterations ( i ); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 100 )); } show (); return 0 ; } std :: vector < std :: pair < size_t , size_t >> get_edges () { return { { 0 , 0 }, { 1 , 0 }, { 5 , 0 }, { 0 , 1 }, { 1 , 1 }, { 2 , 1 }, { 6 , 1 }, { 1 , 2 }, { 2 , 2 }, { 3 , 2 }, { 7 , 2 }, { 2 , 3 }, { 3 , 3 }, { 4 , 3 }, { 8 , 3 }, { 3 , 4 }, { 4 , 4 }, { 9 , 4 }, { 0 , 5 }, { 5 , 5 }, { 6 , 5 }, { 10 , 5 }, { 1 , 6 }, { 5 , 6 }, { 6 , 6 }, { 7 , 6 }, { 11 , 6 }, { 2 , 7 }, { 6 , 7 }, { 7 , 7 }, { 8 , 7 }, { 12 , 7 }, { 3 , 8 }, { 7 , 8 }, { 8 , 8 }, { 9 , 8 }, { 13 , 8 }, { 4 , 9 }, { 8 , 9 }, { 9 , 9 }, { 14 , 9 }, { 5 , 10 }, { 10 , 10 }, { 11 , 10 }, { 15 , 10 }, { 6 , 11 }, { 10 , 11 }, { 11 , 11 }, { 12 , 11 }, { 16 , 11 }, { 7 , 12 }, { 11 , 12 }, { 12 , 12 }, { 13 , 12 }, { 17 , 12 }, { 8 , 13 }, { 12 , 13 }, { 13 , 13 }, { 14 , 13 }, { 18 , 13 }, { 9 , 14 }, { 13 , 14 }, { 14 , 14 }, { 19 , 14 }, { 10 , 15 }, { 15 , 15 }, { 16 , 15 }, { 20 , 15 }, { 11 , 16 }, { 15 , 16 }, { 16 , 16 }, { 17 , 16 }, { 21 , 16 }, { 12 , 17 }, { 16 , 17 }, { 17 , 17 }, { 18 , 17 }, { 22 , 17 }, { 13 , 18 }, { 17 , 18 }, { 18 , 18 }, { 19 , 18 }, { 23 , 18 }, { 14 , 19 }, { 18 , 19 }, { 19 , 19 }, { 24 , 19 }, { 15 , 20 }, { 20 , 20 }, { 21 , 20 }, { 25 , 20 }, { 16 , 21 }, { 20 , 21 }, { 21 , 21 }, { 22 , 21 }, { 26 , 21 }, { 17 , 22 }, { 21 , 22 }, { 22 , 22 }, { 23 , 22 }, { 27 , 22 }, { 18 , 23 }, { 22 , 23 }, { 23 , 23 }, { 24 , 23 }, { 28 , 23 }, { 19 , 24 }, { 23 , 24 }, { 24 , 24 }, { 29 , 24 }, { 20 , 25 }, { 25 , 25 }, { 26 , 25 }, { 35 , 25 }, { 21 , 26 }, { 25 , 26 }, { 26 , 26 }, { 27 , 26 }, { 36 , 26 }, { 22 , 27 }, { 26 , 27 }, { 27 , 27 }, { 28 , 27 }, { 37 , 27 }, { 23 , 28 }, { 27 , 28 }, { 28 , 28 }, { 29 , 28 }, { 38 , 28 }, { 24 , 29 }, { 28 , 29 }, { 29 , 29 }, { 30 , 29 }, { 39 , 29 }, { 29 , 30 }, { 30 , 30 }, { 31 , 30 }, { 40 , 30 }, { 30 , 31 }, { 31 , 31 }, { 32 , 31 }, { 41 , 31 }, { 31 , 32 }, { 32 , 32 }, { 33 , 32 }, { 42 , 32 }, { 32 , 33 }, { 33 , 33 }, { 34 , 33 }, { 43 , 33 }, { 33 , 34 }, { 34 , 34 }, { 44 , 34 }, { 25 , 35 }, { 35 , 35 }, { 36 , 35 }, { 45 , 35 }, { 26 , 36 }, { 35 , 36 }, { 36 , 36 }, { 37 , 36 }, { 46 , 36 }, { 27 , 37 }, { 36 , 37 }, { 37 , 37 }, { 38 , 37 }, { 47 , 37 }, { 28 , 38 }, { 37 , 38 }, { 38 , 38 }, { 39 , 38 }, { 48 , 38 }, { 29 , 39 }, { 38 , 39 }, { 39 , 39 }, { 40 , 39 }, { 49 , 39 }, { 30 , 40 }, { 39 , 40 }, { 40 , 40 }, { 41 , 40 }, { 50 , 40 }, { 31 , 41 }, { 40 , 41 }, { 41 , 41 }, { 42 , 41 }, { 51 , 41 }, { 32 , 42 }, { 41 , 42 }, { 42 , 42 }, { 43 , 42 }, { 52 , 42 }, { 33 , 43 }, { 42 , 43 }, { 43 , 43 }, { 44 , 43 }, { 53 , 43 }, { 34 , 44 }, { 43 , 44 }, { 44 , 44 }, { 54 , 44 }, { 35 , 45 }, { 45 , 45 }, { 46 , 45 }, { 55 , 45 }, { 36 , 46 }, { 45 , 46 }, { 46 , 46 }, { 47 , 46 }, { 56 , 46 }, { 37 , 47 }, { 46 , 47 }, { 47 , 47 }, { 48 , 47 }, { 57 , 47 }, { 38 , 48 }, { 47 , 48 }, { 48 , 48 }, { 49 , 48 }, { 58 , 48 }, { 39 , 49 }, { 48 , 49 }, { 49 , 49 }, { 50 , 49 }, { 59 , 49 }, { 40 , 50 }, { 49 , 50 }, { 50 , 50 }, { 51 , 50 }, { 60 , 50 }, { 41 , 51 }, { 50 , 51 }, { 51 , 51 }, { 52 , 51 }, { 61 , 51 }, { 42 , 52 }, { 51 , 52 }, { 52 , 52 }, { 53 , 52 }, { 62 , 52 }, { 43 , 53 }, { 52 , 53 }, { 53 , 53 }, { 54 , 53 }, { 63 , 53 }, { 44 , 54 }, { 53 , 54 }, { 54 , 54 }, { 64 , 54 }, { 45 , 55 }, { 55 , 55 }, { 56 , 55 }, { 65 , 55 }, { 46 , 56 }, { 55 , 56 }, { 56 , 56 }, { 57 , 56 }, { 66 , 56 }, { 47 , 57 }, { 56 , 57 }, { 57 , 57 }, { 58 , 57 }, { 67 , 57 }, { 48 , 58 }, { 57 , 58 }, { 58 , 58 }, { 59 , 58 }, { 68 , 58 }, { 49 , 59 }, { 58 , 59 }, { 59 , 59 }, { 60 , 59 }, { 69 , 59 }, { 50 , 60 }, { 59 , 60 }, { 60 , 60 }, { 61 , 60 }, { 70 , 60 }, { 51 , 61 }, { 60 , 61 }, { 61 , 61 }, { 62 , 61 }, { 71 , 61 }, { 52 , 62 }, { 61 , 62 }, { 62 , 62 }, { 63 , 62 }, { 72 , 62 }, { 53 , 63 }, { 62 , 63 }, { 63 , 63 }, { 64 , 63 }, { 73 , 63 }, { 54 , 64 }, { 63 , 64 }, { 64 , 64 }, { 74 , 64 }, { 55 , 65 }, { 65 , 65 }, { 66 , 65 }, { 56 , 66 }, { 65 , 66 }, { 66 , 66 }, { 67 , 66 }, { 57 , 67 }, { 66 , 67 }, { 67 , 67 }, { 68 , 67 }, { 58 , 68 }, { 67 , 68 }, { 68 , 68 }, { 69 , 68 }, { 59 , 69 }, { 68 , 69 }, { 69 , 69 }, { 70 , 69 }, { 60 , 70 }, { 69 , 70 }, { 70 , 70 }, { 71 , 70 }, { 61 , 71 }, { 70 , 71 }, { 71 , 71 }, { 72 , 71 }, { 62 , 72 }, { 71 , 72 }, { 72 , 72 }, { 73 , 72 }, { 63 , 73 }, { 72 , 73 }, { 73 , 73 }, { 74 , 73 }, { 64 , 74 }, { 73 , 74 }, { 74 , 74 }}; } All these subcategories depend on the network class. Graphs are abstract structures that represent objects and relationships between these objects. The objects are represented as vertices and the relationships are depicted as edges. In an abstract graph, the vertices have no specific position in space. Mathematically, a graph does not depend on its layout. However, the graph layout has a large impact on its understandability. The network class can calculate appropriate positions for graph vertices with several algorithms: Kamada Kawai algorithm, Fruchterman-Reingold algorithm, circle layout, random layout, and automatic layout. The implementation of the Kamada Kawai and Fruchterman-Reingold algorithms depend on the NodeSoup library. The automatic layout uses the Kamada Kawai algorithm for small graphs and the Fruchterman-Reingold algorithm for larger graphs.","title":"Undirected Graph"},{"location":"plot-types/images/image-matrix/","text":"Image Matrix 1 image ( C ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; image ( C ); colorbar (); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; image ( C , true ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; image ( 5 , 8 , 3 , 6 , C ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: tuple < vector_2d , vector_2d , vector_2d > C ; auto & [ r , g , b ] = C ; r = transform ( vector_2d {{ .1 , .2 , .3 }, { .4 , .5 , .6 }, { .7 , .8 , .9 }}, []( double x ) { return x * 255 ; }); g = zeros ( 3 , 3 ); b = zeros ( 3 , 3 ); image ( C ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 3 )); hold ( on ); vector_2d C = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}; auto im = image ( C ); im -> alpha ( 0.5 ); gca () -> y_axis (). reverse ( false ); show (); return 0 ; }","title":"Image Matrix"},{"location":"plot-types/images/image-matrix/#image-matrix","text":"1 image ( C ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; image ( C ); colorbar (); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; image ( C , true ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; image ( 5 , 8 , 3 , 6 , C ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: tuple < vector_2d , vector_2d , vector_2d > C ; auto & [ r , g , b ] = C ; r = transform ( vector_2d {{ .1 , .2 , .3 }, { .4 , .5 , .6 }, { .7 , .8 , .9 }}, []( double x ) { return x * 255 ; }); g = zeros ( 3 , 3 ); b = zeros ( 3 , 3 ); image ( C ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; plot ( iota ( 1 , 3 )); hold ( on ); vector_2d C = {{ 1 , 2 , 3 }, { 4 , 5 , 6 }, { 7 , 8 , 9 }}; auto im = image ( C ); im -> alpha ( 0.5 ); gca () -> y_axis (). reverse ( false ); show (); return 0 ; }","title":"Image Matrix"},{"location":"plot-types/images/image-show/","text":"Image Show 1 imshow ( image ); Plot C++ 1 2 3 4 5 6 7 8 9 10 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_gray.tiff\" ); imshow ( image ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_color.tiff\" ); imshow ( image ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_gray.tiff\" ); auto & gray = image [ 0 ]; auto [ h , w ] = size ( gray ); double mean_intensity = 0 ; for ( const auto & row : gray ) { for ( const auto & pixel : row ) { mean_intensity += pixel ; } } mean_intensity /= ( h * w ); for ( auto & row : gray ) { for ( auto & pixel : row ) { pixel = pixel > mean_intensity ? 255 : 0 ; } } imshow ( gray ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 #include <matplot/matplot.h> int main () { using namespace matplot ; imshow ( \"lena_color.tiff\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_gray.tiff\" ); imshow ( image [ 0 ]); colormap ( palette :: greens ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_gray.tiff\" ); imshow ( image [ 0 ]); colormap ( palette :: default_map ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_color.tiff\" ); image = imvignette ( image ); imshow ( image ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_gray.tiff\" ); image = imvignette ( image ); imshow ( image ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_color.tiff\" ); image = imresize ( image , 0.1 , image_interpolation :: bilinear ); imshow ( image ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_color.tiff\" ); image = imvignette ( image ); auto image_to_show = imresize ( image , 0.5 ); imshow ( image_to_show ); auto image_to_save = imresize ( image , 2. , image_interpolation :: bicubic ); imwrite ( image_to_save , \"lena_bicubic.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: bilinear ), \"lena_bilinear.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: grid ), \"lena_grid.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: lanczos ), \"lena_lanczos.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: moving_average ), \"lena_moving_average.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: nearest ), \"lena_nearest.tiff\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_gray.tiff\" ); imshow ( image [ 0 ]); colormap ( palette :: blues ()); imwrite ( image [ 0 ], palette :: blues (), \"lena_blues.tiff\" ); show (); return 0 ; } These subcategories depend on the matrix class. The matrix class can have up to four matrices. If it has only one matrix, it is represented with a colormap. If it has three matrices, they represent the red, green, and blue channels. If it has four matrices, the fourth matrix represents an alpha channel to control the transparency of each pixel. We use the CImg library to load and save images. CImg can handle many common image formats as long as it has access to the appropriate libraries. The Matplot++ build script will look at compile-time for the following optional libraries: JPEG, TIFF, ZLIB, PNG, LAPACK, BLAS, OpenCV, X11, fftw3, OpenEXR, and Magick++. The build script will attempt to link all libraries from this list to Matplot++ . Matplot++ includes a few convenience functions to manipulate matrices with images: imread , rgb2gray , gray2rgb , imresize , and imwrite . All these functions work with lists of matrices.","title":"Image Show"},{"location":"plot-types/images/image-show/#image-show","text":"1 imshow ( image ); Plot C++ 1 2 3 4 5 6 7 8 9 10 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_gray.tiff\" ); imshow ( image ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_color.tiff\" ); imshow ( image ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_gray.tiff\" ); auto & gray = image [ 0 ]; auto [ h , w ] = size ( gray ); double mean_intensity = 0 ; for ( const auto & row : gray ) { for ( const auto & pixel : row ) { mean_intensity += pixel ; } } mean_intensity /= ( h * w ); for ( auto & row : gray ) { for ( auto & pixel : row ) { pixel = pixel > mean_intensity ? 255 : 0 ; } } imshow ( gray ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 #include <matplot/matplot.h> int main () { using namespace matplot ; imshow ( \"lena_color.tiff\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_gray.tiff\" ); imshow ( image [ 0 ]); colormap ( palette :: greens ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; auto image = imread ( \"lena_gray.tiff\" ); imshow ( image [ 0 ]); colormap ( palette :: default_map ()); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_color.tiff\" ); image = imvignette ( image ); imshow ( image ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_gray.tiff\" ); image = imvignette ( image ); imshow ( image ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_color.tiff\" ); image = imresize ( image , 0.1 , image_interpolation :: bilinear ); imshow ( image ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_color.tiff\" ); image = imvignette ( image ); auto image_to_show = imresize ( image , 0.5 ); imshow ( image_to_show ); auto image_to_save = imresize ( image , 2. , image_interpolation :: bicubic ); imwrite ( image_to_save , \"lena_bicubic.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: bilinear ), \"lena_bilinear.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: grid ), \"lena_grid.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: lanczos ), \"lena_lanczos.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: moving_average ), \"lena_moving_average.tiff\" ); imwrite ( imresize ( image , 2. , image_interpolation :: nearest ), \"lena_nearest.tiff\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <matplot/matplot.h> int main () { using namespace matplot ; image_channels_t image = imread ( \"lena_gray.tiff\" ); imshow ( image [ 0 ]); colormap ( palette :: blues ()); imwrite ( image [ 0 ], palette :: blues (), \"lena_blues.tiff\" ); show (); return 0 ; } These subcategories depend on the matrix class. The matrix class can have up to four matrices. If it has only one matrix, it is represented with a colormap. If it has three matrices, they represent the red, green, and blue channels. If it has four matrices, the fourth matrix represents an alpha channel to control the transparency of each pixel. We use the CImg library to load and save images. CImg can handle many common image formats as long as it has access to the appropriate libraries. The Matplot++ build script will look at compile-time for the following optional libraries: JPEG, TIFF, ZLIB, PNG, LAPACK, BLAS, OpenCV, X11, fftw3, OpenEXR, and Magick++. The build script will attempt to link all libraries from this list to Matplot++ . Matplot++ includes a few convenience functions to manipulate matrices with images: imread , rgb2gray , gray2rgb , imresize , and imwrite . All these functions work with lists of matrices.","title":"Image Show"},{"location":"plot-types/images/scaled-image/","text":"Scaled Image 1 imagesc ( C ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; imagesc ( C ); colorbar (); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; imagesc ( 5 , 8 , 3 , 6 , C ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; imagesc ( 5 , 8 , 3 , 6 , C ); gca () -> color_box_range ( 4 , 18 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; auto im = imagesc ( 5 , 8 , 3 , 6 , C ); gca () -> color_box_range ( 4 , 18 ); im -> alpha ( 0.5 ); show (); return 0 ; }","title":"Scaled Image"},{"location":"plot-types/images/scaled-image/#scaled-image","text":"1 imagesc ( C ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; imagesc ( C ); colorbar (); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; imagesc ( 5 , 8 , 3 , 6 , C ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; imagesc ( 5 , 8 , 3 , 6 , C ); gca () -> color_box_range ( 4 , 18 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> C = { { 0 , 2 , 4 , 6 }, { 8 , 10 , 12 , 14 }, { 16 , 18 , 20 , 22 }}; auto im = imagesc ( 5 , 8 , 3 , 6 , C ); gca () -> color_box_range ( 4 , 18 ); im -> alpha ( 0.5 ); show (); return 0 ; }","title":"Scaled Image"},{"location":"plot-types/line-plots/area/","text":"Area 1 area ( Y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 1 , 3 , 1 , 2 }, { 5 , 2 , 5 , 6 }, { 3 , 7 , 3 , 1 }}; auto f = gcf (); f -> width ( f -> width () * 2 ); subplot ( 1 , 2 , 0 ); area ( Y ); title ( \"Stacked\" ); subplot ( 1 , 2 , 1 ); area ( Y , false ); title ( \"Not stacked\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 1 , 3 , 1 , 2 }, { 5 , 2 , 5 , 6 }, { 3 , 7 , 3 , 1 }}; auto f = gcf (); f -> width ( f -> width () * 2 ); subplot ( 1 , 2 , 0 ); area ( Y , -4. ); title ( \"Stacked\" ); subplot ( 1 , 2 , 1 ); area ( Y , -4 , false ); title ( \"Not stacked\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 1 , 3 , 1 , 2 }, { 5 , 2 , 5 , 6 }, { 3 , 7 , 3 , 1 }}; auto f = gcf (); f -> width ( f -> width () * 2 ); subplot ( 1 , 2 , 0 ); auto h1 = area ( Y , -4. ); h1 [ 0 ] -> line_style ( \":\" ); h1 [ 1 ] -> line_style ( \":\" ); h1 [ 2 ] -> line_style ( \":\" ); h1 [ 0 ] -> face_color ({ 0 , 0 , 0.25 , 0.25 }); h1 [ 1 ] -> face_color ({ 0 , 0 , 0.5 , 0.5 }); h1 [ 2 ] -> face_color ({ 0 , 0 , 0.75 , 0.75 }); title ( \"Stacked\" ); subplot ( 1 , 2 , 1 ); auto h2 = area ( Y , -4 , false ); h2 [ 0 ] -> line_style ( \":\" ); h2 [ 1 ] -> line_style ( \":\" ); h2 [ 2 ] -> line_style ( \":\" ); h2 [ 0 ] -> face_color ({ 0.2 , 0 , 0.25 , 0.25 }); h2 [ 1 ] -> face_color ({ 0.2 , 0 , 0.5 , 0.5 }); h2 [ 2 ] -> face_color ({ 0.2 , 0 , 0.75 , 0.75 }); title ( \"Not stacked\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 1 , 3 , 4 , 0 }, { 2 , 5 , 4 , 7 }, { 6 , 4 , 5 , 3 }}; auto f = gcf (); f -> width ( f -> width () * 2 ); subplot ( 1 , 2 , 0 ); area ( Y , -4. ); title ( \"Stacked\" ); subplot ( 1 , 2 , 1 ); area ( Y , -4 , false ); title ( \"Not stacked\" ); save ( \"area_4.svg\" ); show (); return 0 ; }","title":"Area"},{"location":"plot-types/line-plots/area/#area","text":"1 area ( Y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 1 , 3 , 1 , 2 }, { 5 , 2 , 5 , 6 }, { 3 , 7 , 3 , 1 }}; auto f = gcf (); f -> width ( f -> width () * 2 ); subplot ( 1 , 2 , 0 ); area ( Y ); title ( \"Stacked\" ); subplot ( 1 , 2 , 1 ); area ( Y , false ); title ( \"Not stacked\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 1 , 3 , 1 , 2 }, { 5 , 2 , 5 , 6 }, { 3 , 7 , 3 , 1 }}; auto f = gcf (); f -> width ( f -> width () * 2 ); subplot ( 1 , 2 , 0 ); area ( Y , -4. ); title ( \"Stacked\" ); subplot ( 1 , 2 , 1 ); area ( Y , -4 , false ); title ( \"Not stacked\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 1 , 3 , 1 , 2 }, { 5 , 2 , 5 , 6 }, { 3 , 7 , 3 , 1 }}; auto f = gcf (); f -> width ( f -> width () * 2 ); subplot ( 1 , 2 , 0 ); auto h1 = area ( Y , -4. ); h1 [ 0 ] -> line_style ( \":\" ); h1 [ 1 ] -> line_style ( \":\" ); h1 [ 2 ] -> line_style ( \":\" ); h1 [ 0 ] -> face_color ({ 0 , 0 , 0.25 , 0.25 }); h1 [ 1 ] -> face_color ({ 0 , 0 , 0.5 , 0.5 }); h1 [ 2 ] -> face_color ({ 0 , 0 , 0.75 , 0.75 }); title ( \"Stacked\" ); subplot ( 1 , 2 , 1 ); auto h2 = area ( Y , -4 , false ); h2 [ 0 ] -> line_style ( \":\" ); h2 [ 1 ] -> line_style ( \":\" ); h2 [ 2 ] -> line_style ( \":\" ); h2 [ 0 ] -> face_color ({ 0.2 , 0 , 0.25 , 0.25 }); h2 [ 1 ] -> face_color ({ 0.2 , 0 , 0.5 , 0.5 }); h2 [ 2 ] -> face_color ({ 0.2 , 0 , 0.75 , 0.75 }); title ( \"Not stacked\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 1 , 3 , 4 , 0 }, { 2 , 5 , 4 , 7 }, { 6 , 4 , 5 , 3 }}; auto f = gcf (); f -> width ( f -> width () * 2 ); subplot ( 1 , 2 , 0 ); area ( Y , -4. ); title ( \"Stacked\" ); subplot ( 1 , 2 , 1 ); area ( Y , -4 , false ); title ( \"Not stacked\" ); save ( \"area_4.svg\" ); show (); return 0 ; }","title":"Area"},{"location":"plot-types/line-plots/error-bars/","text":"Error Bars 1 errorbar ( x , y , err ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err ( y . size (), 10. ); errorbar ( x , y , err ); axis ({ 0 , 100 , 0 , 110 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err ( y . size (), 10. ); errorbar ( x , y , err ) -> filled_curve ( true ); axis ({ 0 , 100 , 0 , 110 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err = { 5 , 8 , 2 , 9 , 3 , 3 , 8 , 3 , 9 , 3 }; errorbar ( x , y , err ); axis ({ 0 , 100 , 0 , 110 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err = { 1 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; errorbar ( x , y , err , error_bar :: type :: horizontal ); axis ({ 0 , 100 , 0 , 110 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err = { 4 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; errorbar ( x , y , err , error_bar :: type :: both ); axis ({ 0 , 100 , 0 , 110 }); axis ( equal ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err = { 4 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; errorbar ( x , y , err , error_bar :: type :: both , \"o\" ); axis ({ 0 , 100 , 0 , 100 }); axis ( equal ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > yneg = { 1 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; std :: vector < double > ypos = { 2 , 5 , 3 , 5 , 2 , 5 , 2 , 2 , 5 , 5 }; std :: vector < double > xneg = { 1 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; std :: vector < double > xpos = { 2 , 5 , 3 , 5 , 2 , 5 , 2 , 2 , 5 , 5 }; errorbar ( x , y , yneg , ypos , xneg , xpos , \"o\" ); axis ({ 0 , 100 , 0 , 100 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 , 15 ); std :: vector < double > y = transform ( x , []( double x ) { return sin ( x / 2 ); }); std :: vector < double > err ( y . size (), 0.3 ); auto e = errorbar ( x , y , err , \"-s\" ) -> marker_size ( 10 ) . marker_color ( \"red\" ) . marker_face_color ( \"red\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 , 15 ); std :: vector < double > y = transform ( x , []( double x ) { return exp ( x ); }); std :: vector < double > err ( y . size (), 0.3 ); auto e = errorbar ( x , y , err ) -> cap_size ( 18 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 , 10 ); std :: vector < double > y = transform ( x , []( double x ) { return sin ( x / 2. ); }); std :: vector < double > err ( y . size (), 0.3 ); auto e = errorbar ( x , y , err ) -> cap_size ( 15 ). marker ( \"*\" ). marker_size ( 10 ). color ( \"red\" ); show (); return 0 ; } The error bar object includes extra lines to represent error around data points. Log plots are utility functions that adjust the x or y axes to a logarithmic scale.","title":"Error Bars"},{"location":"plot-types/line-plots/error-bars/#error-bars","text":"1 errorbar ( x , y , err ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err ( y . size (), 10. ); errorbar ( x , y , err ); axis ({ 0 , 100 , 0 , 110 }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err ( y . size (), 10. ); errorbar ( x , y , err ) -> filled_curve ( true ); axis ({ 0 , 100 , 0 , 110 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err = { 5 , 8 , 2 , 9 , 3 , 3 , 8 , 3 , 9 , 3 }; errorbar ( x , y , err ); axis ({ 0 , 100 , 0 , 110 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err = { 1 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; errorbar ( x , y , err , error_bar :: type :: horizontal ); axis ({ 0 , 100 , 0 , 110 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err = { 4 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; errorbar ( x , y , err , error_bar :: type :: both ); axis ({ 0 , 100 , 0 , 110 }); axis ( equal ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > err = { 4 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; errorbar ( x , y , err , error_bar :: type :: both , \"o\" ); axis ({ 0 , 100 , 0 , 100 }); axis ( equal ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 10 , 100 ); std :: vector < double > y = { 20 , 30 , 45 , 40 , 60 , 65 , 80 , 75 , 95 , 90 }; std :: vector < double > yneg = { 1 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; std :: vector < double > ypos = { 2 , 5 , 3 , 5 , 2 , 5 , 2 , 2 , 5 , 5 }; std :: vector < double > xneg = { 1 , 3 , 5 , 3 , 5 , 3 , 6 , 4 , 3 , 3 }; std :: vector < double > xpos = { 2 , 5 , 3 , 5 , 2 , 5 , 2 , 2 , 5 , 5 }; errorbar ( x , y , yneg , ypos , xneg , xpos , \"o\" ); axis ({ 0 , 100 , 0 , 100 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 , 15 ); std :: vector < double > y = transform ( x , []( double x ) { return sin ( x / 2 ); }); std :: vector < double > err ( y . size (), 0.3 ); auto e = errorbar ( x , y , err , \"-s\" ) -> marker_size ( 10 ) . marker_color ( \"red\" ) . marker_face_color ( \"red\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 , 15 ); std :: vector < double > y = transform ( x , []( double x ) { return exp ( x ); }); std :: vector < double > err ( y . size (), 0.3 ); auto e = errorbar ( x , y , err ) -> cap_size ( 18 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 , 10 ); std :: vector < double > y = transform ( x , []( double x ) { return sin ( x / 2. ); }); std :: vector < double > err ( y . size (), 0.3 ); auto e = errorbar ( x , y , err ) -> cap_size ( 15 ). marker ( \"*\" ). marker_size ( 10 ). color ( \"red\" ); show (); return 0 ; } The error bar object includes extra lines to represent error around data points. Log plots are utility functions that adjust the x or y axes to a logarithmic scale.","title":"Error Bars"},{"location":"plot-types/line-plots/function-plot-3d/","text":"Function Plot 3D 1 fplot ( fxy ); Plot C++ ```cpp include include int main() { using namespace matplot; 1 2 3 4 5 6 7 auto xt = [](double t) { return sin(t); }; auto yt = [](double t) { return cos(t); }; auto zt = [](double t) { return t; }; fplot3(xt, yt, zt); show(); return 0; } ````` More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto xt = []( double t ) { return exp ( - t / 10. ) * sin ( 5 * t ); }; auto yt = []( double t ) { return exp ( - t / 10. ) * cos ( 5 * t ); }; auto zt = []( double t ) { return t ; }; fplot3 ( xt , yt , zt , std :: array < double , 2 > { -10 , 10 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto sin_t = []( double t ) { return sin ( t ); }; auto cos_t = []( double t ) { return cos ( t ); }; auto t_t = []( double t ) { return t ; }; auto fp = fplot3 ( sin_t , cos_t , t_t , std :: array < double , 2 > { 0 , 2 * pi }) -> line_width ( 2 ); hold ( on ); fplot3 ( sin_t , cos_t , t_t , std :: array < double , 2 > { 2 * pi , 4 * pi }, \"--or\" ); fplot3 ( sin_t , cos_t , t_t , std :: array < double , 2 > { 4 * pi , 6 * pi }, \"-.*c\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <cmath> #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto xt = []( double t ) { return exp ( - std :: abs ( t ) / 10 ) * sin ( 5 * std :: abs ( t )); }; auto yt = []( double t ) { return exp ( - std :: abs ( t ) / 10 ) * cos ( 5 * std :: abs ( t )); }; auto zt = []( double t ) { return t ; }; auto fp = fplot3 ( xt , yt , zt ) -> t_range ({ -10 , 10 }). color ( \"r\" ); xlabel ( \"e^{-|z|/10} sin(2|z|)\" ); ylabel ( \"e^{-|z|/10} cos(2|z|)\" ); zlabel ( \"z\" ); grid ( true ); auto ax = gca (); float da = ax -> azimuth (); float de = ax -> elevation (); for ( size_t i = 0 ; i <= 180 ; ++ i ) { view ( da + 2 * i , de + i ); title ( \"Azimuth: \" + num2str ( da + 2 * i ) + \" Elevation: \" + num2str ( de + i )); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 50 )); } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto xt = []( double t ) { return t ; }; auto yt = []( double t ) { return t / 2. ; }; auto zt = []( double t ) { return sin ( 6. * t ); }; fplot3 ( xt , yt , zt , std :: array < double , 2 > { -2 * pi , 2 * pi }) -> mesh_density ( 300 ) . line_width ( 1 ); title ( \"x=t, y=t/2, z=sin(6t) for -2\u03c0<t<2\u03c0\" ); xlabel ( \"x\" ); ylabel ( \"y\" ); view ( 52.5 , 30 ); box ( on ); xrange ({ -2 * pi , + 2 * pi }); yrange ({ - pi , + pi }); auto ax = gca (); ax -> xticks ( iota ( -2 * pi , pi / 2 , 2 * pi )); ax -> x_axis (). ticklabels ( { \"-2\u03c0\" , \"-3\u03c0/2\" , \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" , \"3\u03c0/2\" , \"\u03c0\" }); ax -> yticks ( iota ( - pi , pi / 2 , pi )); ax -> y_axis (). ticklabels ({ \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" }); show (); return 0 ; }","title":"Function Plot 3D"},{"location":"plot-types/line-plots/function-plot-3d/#function-plot-3d","text":"1 fplot ( fxy ); Plot C++ ```cpp","title":"Function Plot 3D"},{"location":"plot-types/line-plots/function-plot-3d/#include","text":"","title":"include "},{"location":"plot-types/line-plots/function-plot-3d/#include_1","text":"int main() { using namespace matplot; 1 2 3 4 5 6 7 auto xt = [](double t) { return sin(t); }; auto yt = [](double t) { return cos(t); }; auto zt = [](double t) { return t; }; fplot3(xt, yt, zt); show(); return 0; } ````` More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto xt = []( double t ) { return exp ( - t / 10. ) * sin ( 5 * t ); }; auto yt = []( double t ) { return exp ( - t / 10. ) * cos ( 5 * t ); }; auto zt = []( double t ) { return t ; }; fplot3 ( xt , yt , zt , std :: array < double , 2 > { -10 , 10 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto sin_t = []( double t ) { return sin ( t ); }; auto cos_t = []( double t ) { return cos ( t ); }; auto t_t = []( double t ) { return t ; }; auto fp = fplot3 ( sin_t , cos_t , t_t , std :: array < double , 2 > { 0 , 2 * pi }) -> line_width ( 2 ); hold ( on ); fplot3 ( sin_t , cos_t , t_t , std :: array < double , 2 > { 2 * pi , 4 * pi }, \"--or\" ); fplot3 ( sin_t , cos_t , t_t , std :: array < double , 2 > { 4 * pi , 6 * pi }, \"-.*c\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <cmath> #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto xt = []( double t ) { return exp ( - std :: abs ( t ) / 10 ) * sin ( 5 * std :: abs ( t )); }; auto yt = []( double t ) { return exp ( - std :: abs ( t ) / 10 ) * cos ( 5 * std :: abs ( t )); }; auto zt = []( double t ) { return t ; }; auto fp = fplot3 ( xt , yt , zt ) -> t_range ({ -10 , 10 }). color ( \"r\" ); xlabel ( \"e^{-|z|/10} sin(2|z|)\" ); ylabel ( \"e^{-|z|/10} cos(2|z|)\" ); zlabel ( \"z\" ); grid ( true ); auto ax = gca (); float da = ax -> azimuth (); float de = ax -> elevation (); for ( size_t i = 0 ; i <= 180 ; ++ i ) { view ( da + 2 * i , de + i ); title ( \"Azimuth: \" + num2str ( da + 2 * i ) + \" Elevation: \" + num2str ( de + i )); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 50 )); } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto xt = []( double t ) { return t ; }; auto yt = []( double t ) { return t / 2. ; }; auto zt = []( double t ) { return sin ( 6. * t ); }; fplot3 ( xt , yt , zt , std :: array < double , 2 > { -2 * pi , 2 * pi }) -> mesh_density ( 300 ) . line_width ( 1 ); title ( \"x=t, y=t/2, z=sin(6t) for -2\u03c0<t<2\u03c0\" ); xlabel ( \"x\" ); ylabel ( \"y\" ); view ( 52.5 , 30 ); box ( on ); xrange ({ -2 * pi , + 2 * pi }); yrange ({ - pi , + pi }); auto ax = gca (); ax -> xticks ( iota ( -2 * pi , pi / 2 , 2 * pi )); ax -> x_axis (). ticklabels ( { \"-2\u03c0\" , \"-3\u03c0/2\" , \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" , \"3\u03c0/2\" , \"\u03c0\" }); ax -> yticks ( iota ( - pi , pi / 2 , pi )); ax -> y_axis (). ticklabels ({ \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" }); show (); return 0 ; }","title":"include "},{"location":"plot-types/line-plots/function-plot/","text":"Function Plot 1 fplot ( fx ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fplot ( \"cos(x)\" , \"o-r\" ) -> line_width ( 2 ); hold ( on ); fplot ([]( double x ) { return sin ( x ); }, std :: array < double , 2 > { -10 , 10 }, \"x--b\" ) -> line_width ( 2 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fplot ([]( double t ) { return cos ( 3 * t ); }, []( double t ) { return sin ( 2 * t ); }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fplot ([]( double x ) { return exp ( x ); }, std :: array < double , 2 > { -3 , 0 }, \"b\" ); hold ( on ); fplot ([]( double x ) { return cos ( x ); }, std :: array < double , 2 > { 0 , 3 }, \"b\" ); hold ( off ); grid ( on ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = fplot ([]( double x ) { return sin ( x + pi / 5 ); }); f -> line_width ( 2 ); hold ( on ); fplot ([]( double x ) { return sin ( x - pi / 5 ); }, \"--or\" ); fplot ([]( double x ) { return sin ( x ); }, \"-.*c\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto fp = fplot ([]( double x ) { return sin ( x ); }); fp -> line_style ( \":\" ); fp -> color ( \"r\" ); fp -> marker ( \"x\" ); fp -> marker_color ( \"b\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fplot ([]( double x ) { return sin ( x ); }, std :: array < double , 2 > { -2 * pi , 2 * pi }); grid ( on ); title ( \"sin(x) from -2\u03c0 to 2\u03c0\" ); xlabel ( \"x\" ); ylabel ( \"y\" ); auto ax = gca (); ax -> x_axis (). tick_values ( iota ( -2 * pi , pi / 2 , 2 * pi )); ax -> x_axis (). ticklabels ( { \"-2\u03c0\" , \"-3\u03c0/2\" , \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" , \"3\u03c0/2\" , \"2\u03c0\" }); show (); return 0 ; } Instead of storing data points, the objects function line and string function store a function as a lambda function or as a string with an expression. These objects use lazy evaluation to generate absolute data points. The data is generated only when the draw function is called.","title":"Function Plot"},{"location":"plot-types/line-plots/function-plot/#function-plot","text":"1 fplot ( fx ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fplot ( \"cos(x)\" , \"o-r\" ) -> line_width ( 2 ); hold ( on ); fplot ([]( double x ) { return sin ( x ); }, std :: array < double , 2 > { -10 , 10 }, \"x--b\" ) -> line_width ( 2 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fplot ([]( double t ) { return cos ( 3 * t ); }, []( double t ) { return sin ( 2 * t ); }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fplot ([]( double x ) { return exp ( x ); }, std :: array < double , 2 > { -3 , 0 }, \"b\" ); hold ( on ); fplot ([]( double x ) { return cos ( x ); }, std :: array < double , 2 > { 0 , 3 }, \"b\" ); hold ( off ); grid ( on ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto f = fplot ([]( double x ) { return sin ( x + pi / 5 ); }); f -> line_width ( 2 ); hold ( on ); fplot ([]( double x ) { return sin ( x - pi / 5 ); }, \"--or\" ); fplot ([]( double x ) { return sin ( x ); }, \"-.*c\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto fp = fplot ([]( double x ) { return sin ( x ); }); fp -> line_style ( \":\" ); fp -> color ( \"r\" ); fp -> marker ( \"x\" ); fp -> marker_color ( \"b\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fplot ([]( double x ) { return sin ( x ); }, std :: array < double , 2 > { -2 * pi , 2 * pi }); grid ( on ); title ( \"sin(x) from -2\u03c0 to 2\u03c0\" ); xlabel ( \"x\" ); ylabel ( \"y\" ); auto ax = gca (); ax -> x_axis (). tick_values ( iota ( -2 * pi , pi / 2 , 2 * pi )); ax -> x_axis (). ticklabels ( { \"-2\u03c0\" , \"-3\u03c0/2\" , \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" , \"3\u03c0/2\" , \"2\u03c0\" }); show (); return 0 ; } Instead of storing data points, the objects function line and string function store a function as a lambda function or as a string with an expression. These objects use lazy evaluation to generate absolute data points. The data is generated only when the draw function is called.","title":"Function Plot"},{"location":"plot-types/line-plots/implicit-function/","text":"Implicit function 1 fplot ( fxy ); Plot C++ 1 2 3 4 5 6 7 8 9 10 #include <matplot/matplot.h> int main () { using namespace matplot ; fimplicit ([]( double x , double y ) { return pow ( x , 2 ) - pow ( y , 2 ) - 1 ; }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; fimplicit ([]( double x , double y ) { return pow ( x , 2 ) + pow ( y , 2 ) - 3 ; }, std :: array < double , 4 > { -3 , 0 , -2 , 2 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; fimplicit ([]( double x , double y ) { return pow ( x , 2 ) + pow ( y , 2 ) - 1 ; }); hold ( on ); fimplicit ([]( double x , double y ) { return pow ( x , 2 ) + pow ( y , 2 ) - 2 ; }, \"--g\" ) -> line_width ( 2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; fimplicit ([]( double x , double y ) { return y * sin ( x ) + x * cos ( y ); }) -> color ( \"r\" ) . line_style ( \"--\" ) . line_width ( 2 ); show (); return 0 ; }","title":"Implicit function"},{"location":"plot-types/line-plots/implicit-function/#implicit-function","text":"1 fplot ( fxy ); Plot C++ 1 2 3 4 5 6 7 8 9 10 #include <matplot/matplot.h> int main () { using namespace matplot ; fimplicit ([]( double x , double y ) { return pow ( x , 2 ) - pow ( y , 2 ) - 1 ; }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; fimplicit ([]( double x , double y ) { return pow ( x , 2 ) + pow ( y , 2 ) - 3 ; }, std :: array < double , 4 > { -3 , 0 , -2 , 2 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <matplot/matplot.h> int main () { using namespace matplot ; fimplicit ([]( double x , double y ) { return pow ( x , 2 ) + pow ( y , 2 ) - 1 ; }); hold ( on ); fimplicit ([]( double x , double y ) { return pow ( x , 2 ) + pow ( y , 2 ) - 2 ; }, \"--g\" ) -> line_width ( 2 ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> int main () { using namespace matplot ; fimplicit ([]( double x , double y ) { return y * sin ( x ) + x * cos ( y ); }) -> color ( \"r\" ) . line_style ( \"--\" ) . line_width ( 2 ); show (); return 0 ; }","title":"Implicit function"},{"location":"plot-types/line-plots/line-plot-3d/","text":"Line Plot 3D 1 plot3 ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > t = iota ( 0 , pi / 50 , 10 * pi ); std :: vector < double > st = transform ( t , []( auto x ) { return sin ( x ); }); std :: vector < double > ct = transform ( t , []( auto x ) { return cos ( x ); }); auto l = plot3 ( st , ct , t ); show (); return 0 ; } Tip With method chaining: 1 plot3 ( x , y ) -> line_width ( 2 ). color ( \"red\" ); More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > t = iota ( 0 , pi / 500 , pi ); std :: vector < double > xt1 = transform ( t , []( auto x ) { return sin ( x ) * cos ( 10 * x ); }); std :: vector < double > yt1 = transform ( t , []( auto x ) { return sin ( x ) * sin ( 10 * x ); }); std :: vector < double > zt1 = transform ( t , []( auto x ) { return cos ( x ); }); std :: vector < double > xt2 = transform ( t , []( auto x ) { return sin ( x ) * cos ( 12 * x ); }); std :: vector < double > yt2 = transform ( t , []( auto x ) { return sin ( x ) * sin ( 12 * x ); }); std :: vector < double > zt2 = transform ( t , []( auto x ) { return cos ( x ); }); plot3 ( xt1 , yt1 , zt1 , xt2 , yt2 , zt2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > t = iota ( 0 , pi / 500 , pi ); std :: vector < std :: vector < double >> X ( 3 ); std :: vector < std :: vector < double >> Y ( 3 ); X [ 0 ] = transform ( t , []( auto x ) { return sin ( x ) * cos ( 10 * x ); }); X [ 1 ] = transform ( t , []( auto x ) { return sin ( x ) * cos ( 12 * x ); }); X [ 2 ] = transform ( t , []( auto x ) { return sin ( x ) * cos ( 20 * x ); }); Y [ 0 ] = transform ( t , []( auto x ) { return sin ( x ) * sin ( 10 * x ); }); Y [ 1 ] = transform ( t , []( auto x ) { return sin ( x ) * sin ( 12 * x ); }); Y [ 2 ] = transform ( t , []( auto x ) { return sin ( x ) * sin ( 20 * x ); }); std :: vector < double > z = transform ( t , []( auto x ) { return cos ( x ); }); plot3 ( X , Y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <cmath> #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 500 , 40 * pi ); auto xt = transform ( t , []( auto t ) { return ( 3. + cos ( sqrt ( 32. ) * t )) * cos ( t ); }); auto yt = transform ( t , []( auto t ) { return sin ( sqrt ( 32. ) * t ); }); auto zt = transform ( t , []( auto t ) { return ( 3. + cos ( sqrt ( 32. ) * t )) * sin ( t ); }); plot3 ( xt , yt , zt ); axis ( equal ); xlabel ( \"x(t)\" ); ylabel ( \"y(t)\" ); zlabel ( \"z(t)\" ); auto ax = gca (); float da = ax -> azimuth (); for ( size_t i = 0 ; i <= 360 ; ++ i ) { ax -> azimuth ( da + 2 * i ); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 50 )); } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 20 , 10 * pi ); auto xt = transform ( t , []( auto t ) { return sin ( t ); }); auto yt = transform ( t , []( auto t ) { return cos ( t ); }); auto l = plot3 ( xt , yt , t , \"-ob\" ); l -> marker_size ( 10 ); l -> marker_face_color ( \"#D9FFFF\" ); xlabel ( \"x(t)\" ); ylabel ( \"y(t)\" ); zlabel ( \"t\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = linspace ( -10 , 10 , 1000 ); auto xt = transform ( t , []( auto t ) { return exp ( - t / 10 ) * sin ( 5 * t ); }); auto yt = transform ( t , []( auto t ) { return exp ( - t / 10 ) * cos ( 5 * t ); }); auto p = plot3 ( xt , yt , t ); p -> line_width ( 3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 1 , 2 ); auto ax1 = nexttile (); auto t = iota ( 0 , pi / 20 , 10 * pi ); auto xt1 = transform ( t , []( auto t ) { return sin ( t ); }); auto yt1 = transform ( t , []( auto t ) { return cos ( t ); }); plot3 ( ax1 , xt1 , yt1 , t ); title ( ax1 , \"Helix with 5 Turns\" ); auto ax2 = nexttile (); t = iota ( 0 , pi / 40 , 10 * pi ); auto xt2 = transform ( t , []( auto t ) { return sin ( 2 * t ); }); auto yt2 = transform ( t , []( auto t ) { return cos ( 2 * t ); }); plot3 ( ax2 , xt2 , yt2 , t ); ax2 -> box ( false ); title ( ax2 , \"Helix with 10 Turns\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: default_random_engine g ( 0 ); std :: uniform_real_distribution < double > d ; std :: vector < double > x ( 10 ); std :: generate ( x . begin (), x . end (), [ & ]() { return d ( g ); }); std :: vector < double > y ( 10 ); std :: generate ( y . begin (), y . end (), [ & ]() { return d ( g ); }); std :: uniform_real_distribution < double > d2 ( 0 , 90 ); std :: vector < double > z ( 10 ); std :: generate ( z . begin (), z . end (), [ & ]() { return d2 ( g ); }); auto p = plot3 ( x , y , z , \"o\" ); p -> parent () -> x_axis (). tick_label_format ( \"s\" ); xlabel ( \"X\" ); ylabel ( \"Y\" ); zlabel ( \"Duration\" ); grid ( on ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 500 , pi ); auto xt = transform ( t , []( auto t ) { return sin ( t ) * cos ( 10 * t ); }); auto yt = transform ( t , []( auto t ) { return sin ( t ) * sin ( 10 * t ); }); auto zt = transform ( t , []( auto t ) { return cos ( t ); }); auto p = plot3 ( xt , yt , zt , \"-o\" ); p -> marker_indices ({ 200 }); show (); return 0 ; }","title":"Line Plot 3D"},{"location":"plot-types/line-plots/line-plot-3d/#line-plot-3d","text":"1 plot3 ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > t = iota ( 0 , pi / 50 , 10 * pi ); std :: vector < double > st = transform ( t , []( auto x ) { return sin ( x ); }); std :: vector < double > ct = transform ( t , []( auto x ) { return cos ( x ); }); auto l = plot3 ( st , ct , t ); show (); return 0 ; } Tip With method chaining: 1 plot3 ( x , y ) -> line_width ( 2 ). color ( \"red\" ); More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > t = iota ( 0 , pi / 500 , pi ); std :: vector < double > xt1 = transform ( t , []( auto x ) { return sin ( x ) * cos ( 10 * x ); }); std :: vector < double > yt1 = transform ( t , []( auto x ) { return sin ( x ) * sin ( 10 * x ); }); std :: vector < double > zt1 = transform ( t , []( auto x ) { return cos ( x ); }); std :: vector < double > xt2 = transform ( t , []( auto x ) { return sin ( x ) * cos ( 12 * x ); }); std :: vector < double > yt2 = transform ( t , []( auto x ) { return sin ( x ) * sin ( 12 * x ); }); std :: vector < double > zt2 = transform ( t , []( auto x ) { return cos ( x ); }); plot3 ( xt1 , yt1 , zt1 , xt2 , yt2 , zt2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > t = iota ( 0 , pi / 500 , pi ); std :: vector < std :: vector < double >> X ( 3 ); std :: vector < std :: vector < double >> Y ( 3 ); X [ 0 ] = transform ( t , []( auto x ) { return sin ( x ) * cos ( 10 * x ); }); X [ 1 ] = transform ( t , []( auto x ) { return sin ( x ) * cos ( 12 * x ); }); X [ 2 ] = transform ( t , []( auto x ) { return sin ( x ) * cos ( 20 * x ); }); Y [ 0 ] = transform ( t , []( auto x ) { return sin ( x ) * sin ( 10 * x ); }); Y [ 1 ] = transform ( t , []( auto x ) { return sin ( x ) * sin ( 12 * x ); }); Y [ 2 ] = transform ( t , []( auto x ) { return sin ( x ) * sin ( 20 * x ); }); std :: vector < double > z = transform ( t , []( auto x ) { return cos ( x ); }); plot3 ( X , Y , z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include <cmath> #include <matplot/matplot.h> #include <thread> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 500 , 40 * pi ); auto xt = transform ( t , []( auto t ) { return ( 3. + cos ( sqrt ( 32. ) * t )) * cos ( t ); }); auto yt = transform ( t , []( auto t ) { return sin ( sqrt ( 32. ) * t ); }); auto zt = transform ( t , []( auto t ) { return ( 3. + cos ( sqrt ( 32. ) * t )) * sin ( t ); }); plot3 ( xt , yt , zt ); axis ( equal ); xlabel ( \"x(t)\" ); ylabel ( \"y(t)\" ); zlabel ( \"z(t)\" ); auto ax = gca (); float da = ax -> azimuth (); for ( size_t i = 0 ; i <= 360 ; ++ i ) { ax -> azimuth ( da + 2 * i ); std :: this_thread :: sleep_for ( std :: chrono :: milliseconds ( 50 )); } show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 20 , 10 * pi ); auto xt = transform ( t , []( auto t ) { return sin ( t ); }); auto yt = transform ( t , []( auto t ) { return cos ( t ); }); auto l = plot3 ( xt , yt , t , \"-ob\" ); l -> marker_size ( 10 ); l -> marker_face_color ( \"#D9FFFF\" ); xlabel ( \"x(t)\" ); ylabel ( \"y(t)\" ); zlabel ( \"t\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto t = linspace ( -10 , 10 , 1000 ); auto xt = transform ( t , []( auto t ) { return exp ( - t / 10 ) * sin ( 5 * t ); }); auto yt = transform ( t , []( auto t ) { return exp ( - t / 10 ) * cos ( 5 * t ); }); auto p = plot3 ( xt , yt , t ); p -> line_width ( 3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 1 , 2 ); auto ax1 = nexttile (); auto t = iota ( 0 , pi / 20 , 10 * pi ); auto xt1 = transform ( t , []( auto t ) { return sin ( t ); }); auto yt1 = transform ( t , []( auto t ) { return cos ( t ); }); plot3 ( ax1 , xt1 , yt1 , t ); title ( ax1 , \"Helix with 5 Turns\" ); auto ax2 = nexttile (); t = iota ( 0 , pi / 40 , 10 * pi ); auto xt2 = transform ( t , []( auto t ) { return sin ( 2 * t ); }); auto yt2 = transform ( t , []( auto t ) { return cos ( 2 * t ); }); plot3 ( ax2 , xt2 , yt2 , t ); ax2 -> box ( false ); title ( ax2 , \"Helix with 10 Turns\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; std :: default_random_engine g ( 0 ); std :: uniform_real_distribution < double > d ; std :: vector < double > x ( 10 ); std :: generate ( x . begin (), x . end (), [ & ]() { return d ( g ); }); std :: vector < double > y ( 10 ); std :: generate ( y . begin (), y . end (), [ & ]() { return d ( g ); }); std :: uniform_real_distribution < double > d2 ( 0 , 90 ); std :: vector < double > z ( 10 ); std :: generate ( z . begin (), z . end (), [ & ]() { return d2 ( g ); }); auto p = plot3 ( x , y , z , \"o\" ); p -> parent () -> x_axis (). tick_label_format ( \"s\" ); xlabel ( \"X\" ); ylabel ( \"Y\" ); zlabel ( \"Duration\" ); grid ( on ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> #include <random> int main () { using namespace matplot ; auto t = iota ( 0 , pi / 500 , pi ); auto xt = transform ( t , []( auto t ) { return sin ( t ) * cos ( 10 * t ); }); auto yt = transform ( t , []( auto t ) { return sin ( t ) * sin ( 10 * t ); }); auto zt = transform ( t , []( auto t ) { return cos ( t ); }); auto p = plot3 ( xt , yt , zt , \"-o\" ); p -> marker_indices ({ 200 }); show (); return 0 ; }","title":"Line Plot 3D"},{"location":"plot-types/line-plots/line-plot/","text":"Line Plot Tip Use these examples to understand how to quickly use the library for data visualization. If you are interested in understanding how the library works, you can later read the details in the complete article . 1 plot ( x , y ); Where x and y are are any value ranges. Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi ); std :: vector < double > y = transform ( x , []( auto x ) { return sin ( x ); }); plot ( x , y , \"-o\" ); hold ( on ); plot ( x , transform ( y , []( auto y ) { return - y ; }), \"--xr\" ); plot ( x , transform ( x , []( auto x ) { return x / pi - 1. ; }), \"-:gs\" ); plot ({ 1.0 , 0.7 , 0.4 , 0.0 , -0.4 , -0.7 , -1 }, \"k\" ); show (); return 0 ; } Tip Setters return a reference to *this to allow method chaining: 1 plot ( x , y ) -> line_width ( 2 ). color ( \"red\" ); Tip These examples use free-standing functions to create plots. You can also use a object-oriented style for plots. We discuss these coding styles in the Section Coding Styles . More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> #include <set> int main () { using namespace matplot ; std :: set < std :: vector < double >> Y = { { 16 , 5 , 9 , 4 }, { 2 , 11 , 7 , 14 }, { 3 , 10 , 6 , 15 }, { 13 , 8 , 12 , 1 }}; plot ( Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi ); std :: vector < double > y1 = transform ( x , []( auto x ) { return sin ( x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return sin ( x - 0.25 ); }); std :: vector < double > y3 = transform ( x , []( auto x ) { return sin ( x - 0.5 ); }); plot ( x , y1 , x , y2 , \"--\" , x , y3 , \":\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi ); std :: vector < double > y1 = transform ( x , []( auto x ) { return sin ( x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return sin ( x - 0.25 ); }); std :: vector < double > y3 = transform ( x , []( auto x ) { return sin ( x - 0.5 ); }); plot ( x , y1 , \"g\" , x , y2 , \"b--o\" , x , y3 , \"c*\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 ); std :: vector < double > y = transform ( x , []( auto x ) { return sin ( x ); }); plot ( x , y , \"-o\" ) -> marker_indices ({ 0 , 5 , 10 , 15 , 20 , 25 , 30 , 35 , 40 , 45 , 50 , 55 , 60 , 65 , 70 , 75 , 80 , 85 , 90 , 95 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> #include <set> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi , + pi , 20 ); // test with set, just because... std :: set < double > x2 ( x . begin (), x . end ()); std :: vector < double > y = transform ( x , []( auto x ) { return tan ( sin ( x )) - sin ( tan ( x )); }); plot ( x2 , y , \"--gs\" ) -> line_width ( 2 ) . marker_size ( 10 ) . marker_color ( \"b\" ) . marker_face_color ({ .5 , .5 , .5 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 , 150 ); std :: vector < double > y = transform ( x , []( auto x ) { return cos ( 5 * x ); }); plot ( x , y ) -> color ({ 0 , 0.7 , 0.9 }); title ( \"2-D Line Plot\" ); xlabel ( \"x\" ); ylabel ( \"cos(5x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 180 , 7 ); std :: vector < double > y = { 0.8 , 0.9 , 0.1 , 0.9 , 0.6 , 0.1 , 0.3 }; plot ( x , y ); title ( \"Time Plot\" ); xlabel ( \"Time\" ); yrange ({ 0 , 1 }); xticks ({ 0 , 30 , 60 , 90 , 120 , 150 , 180 }); xticklabels ( { \"00:00s\" , \"30:00\" , \"01:00\" , \"01:30\" , \"02:00\" , \"02:30\" , \"03:00\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 3 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return sin ( 5 * x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return sin ( 15 * x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x , y1 ); title ( ax1 , \"Top Plot\" ); ylabel ( ax1 , \"sin(5x)\" ); auto ax2 = nexttile (); plot ( ax2 , x , y2 ); title ( ax2 , \"Bottom Plot\" ); ylabel ( ax2 , \"sin(15x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -2 * pi , 3 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return sin ( x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return cos ( x ); }); auto p = plot ( x , y1 , x , y2 ); p [ 0 ] -> line_width ( 2 ); p [ 1 ] -> marker ( line_spec :: marker_style :: asterisk ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double r = 2 ; double xc = 4 ; double yc = 3 ; std :: vector < double > theta = linspace ( 0 , 2 * pi ); std :: vector < double > x = transform ( theta , [ = ]( auto theta ) { return r * cos ( theta ) + xc ; }); std :: vector < double > y = transform ( theta , [ = ]( auto theta ) { return r * sin ( theta ) + yc ; }); plot ( x , y ); axis ( equal ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < int > y = { 2 , 4 , 7 , 7 , 6 , 3 , 9 , 7 , 3 , 5 }; plot ( y ); show (); return 0 ; }","title":"Line Plot"},{"location":"plot-types/line-plots/line-plot/#line-plot","text":"Tip Use these examples to understand how to quickly use the library for data visualization. If you are interested in understanding how the library works, you can later read the details in the complete article . 1 plot ( x , y ); Where x and y are are any value ranges. Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi ); std :: vector < double > y = transform ( x , []( auto x ) { return sin ( x ); }); plot ( x , y , \"-o\" ); hold ( on ); plot ( x , transform ( y , []( auto y ) { return - y ; }), \"--xr\" ); plot ( x , transform ( x , []( auto x ) { return x / pi - 1. ; }), \"-:gs\" ); plot ({ 1.0 , 0.7 , 0.4 , 0.0 , -0.4 , -0.7 , -1 }, \"k\" ); show (); return 0 ; } Tip Setters return a reference to *this to allow method chaining: 1 plot ( x , y ) -> line_width ( 2 ). color ( \"red\" ); Tip These examples use free-standing functions to create plots. You can also use a object-oriented style for plots. We discuss these coding styles in the Section Coding Styles . More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <matplot/matplot.h> #include <set> int main () { using namespace matplot ; std :: set < std :: vector < double >> Y = { { 16 , 5 , 9 , 4 }, { 2 , 11 , 7 , 14 }, { 3 , 10 , 6 , 15 }, { 13 , 8 , 12 , 1 }}; plot ( Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi ); std :: vector < double > y1 = transform ( x , []( auto x ) { return sin ( x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return sin ( x - 0.25 ); }); std :: vector < double > y3 = transform ( x , []( auto x ) { return sin ( x - 0.5 ); }); plot ( x , y1 , x , y2 , \"--\" , x , y3 , \":\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi ); std :: vector < double > y1 = transform ( x , []( auto x ) { return sin ( x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return sin ( x - 0.25 ); }); std :: vector < double > y3 = transform ( x , []( auto x ) { return sin ( x - 0.5 ); }); plot ( x , y1 , \"g\" , x , y2 , \"b--o\" , x , y3 , \"c*\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 ); std :: vector < double > y = transform ( x , []( auto x ) { return sin ( x ); }); plot ( x , y , \"-o\" ) -> marker_indices ({ 0 , 5 , 10 , 15 , 20 , 25 , 30 , 35 , 40 , 45 , 50 , 55 , 60 , 65 , 70 , 75 , 80 , 85 , 90 , 95 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <matplot/matplot.h> #include <set> int main () { using namespace matplot ; std :: vector < double > x = linspace ( - pi , + pi , 20 ); // test with set, just because... std :: set < double > x2 ( x . begin (), x . end ()); std :: vector < double > y = transform ( x , []( auto x ) { return tan ( sin ( x )) - sin ( tan ( x )); }); plot ( x2 , y , \"--gs\" ) -> line_width ( 2 ) . marker_size ( 10 ) . marker_color ( \"b\" ) . marker_face_color ({ .5 , .5 , .5 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 10 , 150 ); std :: vector < double > y = transform ( x , []( auto x ) { return cos ( 5 * x ); }); plot ( x , y ) -> color ({ 0 , 0.7 , 0.9 }); title ( \"2-D Line Plot\" ); xlabel ( \"x\" ); ylabel ( \"cos(5x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 180 , 7 ); std :: vector < double > y = { 0.8 , 0.9 , 0.1 , 0.9 , 0.6 , 0.1 , 0.3 }; plot ( x , y ); title ( \"Time Plot\" ); xlabel ( \"Time\" ); yrange ({ 0 , 1 }); xticks ({ 0 , 30 , 60 , 90 , 120 , 150 , 180 }); xticklabels ( { \"00:00s\" , \"30:00\" , \"01:00\" , \"01:30\" , \"02:00\" , \"02:30\" , \"03:00\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 3 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return sin ( 5 * x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return sin ( 15 * x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); plot ( ax1 , x , y1 ); title ( ax1 , \"Top Plot\" ); ylabel ( ax1 , \"sin(5x)\" ); auto ax2 = nexttile (); plot ( ax2 , x , y2 ); title ( ax2 , \"Bottom Plot\" ); ylabel ( ax2 , \"sin(15x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( -2 * pi , 3 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return sin ( x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return cos ( x ); }); auto p = plot ( x , y1 , x , y2 ); p [ 0 ] -> line_width ( 2 ); p [ 1 ] -> marker ( line_spec :: marker_style :: asterisk ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; double r = 2 ; double xc = 4 ; double yc = 3 ; std :: vector < double > theta = linspace ( 0 , 2 * pi ); std :: vector < double > x = transform ( theta , [ = ]( auto theta ) { return r * cos ( theta ) + xc ; }); std :: vector < double > y = transform ( theta , [ = ]( auto theta ) { return r * sin ( theta ) + yc ; }); plot ( x , y ); axis ( equal ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < int > y = { 2 , 4 , 7 , 7 , 6 , 3 , 9 , 7 , 3 , 5 }; plot ( y ); show (); return 0 ; }","title":"Line Plot"},{"location":"plot-types/line-plots/loglog-plot/","text":"Loglog Plot 1 loglog ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 ); std :: vector < double > y = transform ( x , []( auto x ) { return pow ( 2 , x ); }); loglog ( x , y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return pow ( 10 , x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return 1 / pow ( 10 , x ); }); loglog ( x , y1 , x , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 , 10000 ); std :: vector < double > y = transform ( x , []( auto x ) { return 5 + 3 * sin ( x ); }); loglog ( x , y ); yticks ({ 3 , 4 , 5 , 6 , 7 }); xlabel ( \"x\" ); ylabel ( \"5+3 sin(x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 , 20 ); std :: vector < double > y = transform ( x , []( auto x ) { return pow ( 10 , x ); }); loglog ( x , y , \"s\" ) -> marker_face_color ({ 0 , 0.447 , 0.741 }); xlabel ( \"x\" ); ylabel ( \"10^x\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 , 10000 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return 5 + 3 * sin ( x / 4 ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return 5 - 3 * sin ( x / 4 ); }); loglog ( x , y1 , x , y2 , \"--\" ); legend ( \"Signal 1\" , \"Signal 2\" ) -> location ( legend :: general_alignment :: topleft ); axis ({ 0.1 , 100 , 2 , 8 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > y = { 0.001 , 0.01 , 0.1 , 1 , 10 , 100 }; loglog ( y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 0.0010 , 0.0100 , 0.1000 , 1.0000 , 10.0000 }, { 0.0100 , 0.1000 , 1.0000 , 10.0000 , 100.0000 }, { 0.1000 , 1.0000 , 10.0000 , 100.0000 , 1000.0000 }}; loglog ( Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); std :: vector < double > x = logspace ( -1 , 2 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return pow ( 10 , x ); }); loglog ( ax1 , x , y1 ); auto ax2 = nexttile (); std :: vector < double > y2 = transform ( x , []( auto x ) { return 1. / pow ( 10 , x ); }); loglog ( ax2 , x , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return pow ( 10 , x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return 1. / pow ( 10 , x ); }); auto lg = loglog ( x , y1 , x , y2 ); lg [ 0 ] -> line_width ( 2 ); lg [ 1 ] -> color ({ 0.4 , 0 , 1 }); show (); return 0 ; }","title":"Loglog Plot"},{"location":"plot-types/line-plots/loglog-plot/#loglog-plot","text":"1 loglog ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 ); std :: vector < double > y = transform ( x , []( auto x ) { return pow ( 2 , x ); }); loglog ( x , y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return pow ( 10 , x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return 1 / pow ( 10 , x ); }); loglog ( x , y1 , x , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 , 10000 ); std :: vector < double > y = transform ( x , []( auto x ) { return 5 + 3 * sin ( x ); }); loglog ( x , y ); yticks ({ 3 , 4 , 5 , 6 , 7 }); xlabel ( \"x\" ); ylabel ( \"5+3 sin(x)\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 , 20 ); std :: vector < double > y = transform ( x , []( auto x ) { return pow ( 10 , x ); }); loglog ( x , y , \"s\" ) -> marker_face_color ({ 0 , 0.447 , 0.741 }); xlabel ( \"x\" ); ylabel ( \"10^x\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 , 10000 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return 5 + 3 * sin ( x / 4 ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return 5 - 3 * sin ( x / 4 ); }); loglog ( x , y1 , x , y2 , \"--\" ); legend ( \"Signal 1\" , \"Signal 2\" ) -> location ( legend :: general_alignment :: topleft ); axis ({ 0.1 , 100 , 2 , 8 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > y = { 0.001 , 0.01 , 0.1 , 1 , 10 , 100 }; loglog ( y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: vector < double >> Y = { { 0.0010 , 0.0100 , 0.1000 , 1.0000 , 10.0000 }, { 0.0100 , 0.1000 , 1.0000 , 10.0000 , 100.0000 }, { 0.1000 , 1.0000 , 10.0000 , 100.0000 , 1000.0000 }}; loglog ( Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); std :: vector < double > x = logspace ( -1 , 2 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return pow ( 10 , x ); }); loglog ( ax1 , x , y1 ); auto ax2 = nexttile (); std :: vector < double > y2 = transform ( x , []( auto x ) { return 1. / pow ( 10 , x ); }); loglog ( ax2 , x , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = logspace ( -1 , 2 ); std :: vector < double > y1 = transform ( x , []( auto x ) { return pow ( 10 , x ); }); std :: vector < double > y2 = transform ( x , []( auto x ) { return 1. / pow ( 10 , x ); }); auto lg = loglog ( x , y1 , x , y2 ); lg [ 0 ] -> line_width ( 2 ); lg [ 1 ] -> color ({ 0.4 , 0 , 1 }); show (); return 0 ; }","title":"Loglog Plot"},{"location":"plot-types/line-plots/semilogx-plot/","text":"Semilogx Plot 1 semilogx ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 1000 ); std :: vector < double > y = transform ( x , []( auto x ) { return log ( x ); }); semilogx ( x , y ); show (); return 0 ; }","title":"Semilogx Plot"},{"location":"plot-types/line-plots/semilogx-plot/#semilogx-plot","text":"1 semilogx ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 1000 ); std :: vector < double > y = transform ( x , []( auto x ) { return log ( x ); }); semilogx ( x , y ); show (); return 0 ; }","title":"Semilogx Plot"},{"location":"plot-types/line-plots/semilogy-plot/","text":"Semilogy Plot 1 semilogy ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 0.1 , 10 ); std :: vector < double > y = transform ( x , []( auto x ) { return exp ( x ); }); semilogy ( x , y ); show (); return 0 ; }","title":"Semilogy Plot"},{"location":"plot-types/line-plots/semilogy-plot/#semilogy-plot","text":"1 semilogy ( x , y ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = iota ( 0 , 0.1 , 10 ); std :: vector < double > y = transform ( x , []( auto x ) { return exp ( x ); }); semilogy ( x , y ); show (); return 0 ; }","title":"Semilogy Plot"},{"location":"plot-types/line-plots/stairs/","text":"Stairs 1 stairs ( x , y ); The stair object renders the line with stairs between data points to denote discrete data. Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto X = linspace ( 0 , 4 * pi , 40 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( X , []( double x ) { return 0.5 * cos ( x ); }); Y [ 1 ] = transform ( X , []( double x ) { return 2 * cos ( x ); }); figure (); stairs ( Y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto X = linspace ( 0 , 4 * pi , 40 ); auto Y = transform ( X , []( double x ) { return sin ( x ); }); figure (); stairs ( X , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto X = linspace ( 0 , 4 * pi , 50 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( X , []( double x ) { return 0.5 * cos ( x ); }); Y [ 1 ] = transform ( X , []( double x ) { return 2 * cos ( x ); }); figure (); stairs ( X , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x1 = linspace ( 0 , 2 * pi ); std :: vector < double > x2 = linspace ( 0 , pi ); std :: vector < std :: vector < double >> X = { x1 , x2 }; std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( x1 , []( double x ) { return sin ( 5 * x ); }); Y [ 1 ] = transform ( x2 , []( double x ) { return exp ( x ) * sin ( 5 * x ); }); figure (); stairs ( X , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > X = linspace ( 0 , 4 * pi , 20 ); std :: vector < double > Y = transform ( X , []( double x ) { return sin ( x ); }); figure (); stairs ( Y , \"-.or\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > X = linspace ( 0 , 4 * pi , 20 ); std :: vector < double > Y = transform ( X , []( double x ) { return sin ( x ); }); auto s = stairs ( Y ) -> line_width ( 2 ). marker ( \"d\" ). marker_face_color ( \"c\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi ); std :: vector < double > y1 = transform ( x , []( double x ) { return 5 * sin ( x ); }); std :: vector < double > y2 = transform ( x , []( double x ) { return sin ( 5 * x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); stairs ( ax1 , x , y1 ); auto ax2 = nexttile (); stairs ( ax2 , x , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 1 , 30 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( x , []( double x ) { return cos ( 10 * x ); }); Y [ 1 ] = transform ( x , []( double x ) { return exp ( x ) * sin ( 10 * x ); }); auto h = stairs ( x , Y ); h [ 0 ] -> marker ( line_spec :: marker_style :: circle ). marker_size ( 4 ); h [ 1 ] -> marker ( line_spec :: marker_style :: circle ). marker_face_color ( \"m\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 1 , 3 , 5 , 7 , 10 }; std :: vector < double > y = { 2 , 5 , 6 , 7 , 11 }; auto stair_handles = stairs ( x , y , x , y , x , y , x , y ); stair_handles [ 0 ] -> stair_style ( stair :: stair_style :: fill ); stair_handles [ 1 ] -> stair_style ( stair :: stair_style :: trace_x_first ) . line_width ( 4 ); stair_handles [ 2 ] -> stair_style ( stair :: stair_style :: trace_y_first ) . line_width ( 2 ); stair_handles [ 3 ] -> stair_style ( stair :: stair_style :: histogram ) . marker_style ( line_spec :: marker_style :: circle ) . line_width ( 1 ) . marker_color ( \"m\" ) . marker_face ( true ) . marker_size ( 10 ); axis ({ 0 , 12 , 0 , 13 }); show (); return 0 ; }","title":"Stairs"},{"location":"plot-types/line-plots/stairs/#stairs","text":"1 stairs ( x , y ); The stair object renders the line with stairs between data points to denote discrete data. Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto X = linspace ( 0 , 4 * pi , 40 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( X , []( double x ) { return 0.5 * cos ( x ); }); Y [ 1 ] = transform ( X , []( double x ) { return 2 * cos ( x ); }); figure (); stairs ( Y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto X = linspace ( 0 , 4 * pi , 40 ); auto Y = transform ( X , []( double x ) { return sin ( x ); }); figure (); stairs ( X , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto X = linspace ( 0 , 4 * pi , 50 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( X , []( double x ) { return 0.5 * cos ( x ); }); Y [ 1 ] = transform ( X , []( double x ) { return 2 * cos ( x ); }); figure (); stairs ( X , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x1 = linspace ( 0 , 2 * pi ); std :: vector < double > x2 = linspace ( 0 , pi ); std :: vector < std :: vector < double >> X = { x1 , x2 }; std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( x1 , []( double x ) { return sin ( 5 * x ); }); Y [ 1 ] = transform ( x2 , []( double x ) { return exp ( x ) * sin ( 5 * x ); }); figure (); stairs ( X , Y ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > X = linspace ( 0 , 4 * pi , 20 ); std :: vector < double > Y = transform ( X , []( double x ) { return sin ( x ); }); figure (); stairs ( Y , \"-.or\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > X = linspace ( 0 , 4 * pi , 20 ); std :: vector < double > Y = transform ( X , []( double x ) { return sin ( x ); }); auto s = stairs ( Y ) -> line_width ( 2 ). marker ( \"d\" ). marker_face_color ( \"c\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 2 * pi ); std :: vector < double > y1 = transform ( x , []( double x ) { return 5 * sin ( x ); }); std :: vector < double > y2 = transform ( x , []( double x ) { return sin ( 5 * x ); }); tiledlayout ( 2 , 1 ); auto ax1 = nexttile (); stairs ( ax1 , x , y1 ); auto ax2 = nexttile (); stairs ( ax2 , x , y2 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = linspace ( 0 , 1 , 30 ); std :: vector < std :: vector < double >> Y ( 2 ); Y [ 0 ] = transform ( x , []( double x ) { return cos ( 10 * x ); }); Y [ 1 ] = transform ( x , []( double x ) { return exp ( x ) * sin ( 10 * x ); }); auto h = stairs ( x , Y ); h [ 0 ] -> marker ( line_spec :: marker_style :: circle ). marker_size ( 4 ); h [ 1 ] -> marker ( line_spec :: marker_style :: circle ). marker_face_color ( \"m\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = { 1 , 3 , 5 , 7 , 10 }; std :: vector < double > y = { 2 , 5 , 6 , 7 , 11 }; auto stair_handles = stairs ( x , y , x , y , x , y , x , y ); stair_handles [ 0 ] -> stair_style ( stair :: stair_style :: fill ); stair_handles [ 1 ] -> stair_style ( stair :: stair_style :: trace_x_first ) . line_width ( 4 ); stair_handles [ 2 ] -> stair_style ( stair :: stair_style :: trace_y_first ) . line_width ( 2 ); stair_handles [ 3 ] -> stair_style ( stair :: stair_style :: histogram ) . marker_style ( line_spec :: marker_style :: circle ) . line_width ( 1 ) . marker_color ( \"m\" ) . marker_face ( true ) . marker_size ( 10 ); axis ({ 0 , 12 , 0 , 13 }); show (); return 0 ; }","title":"Stairs"},{"location":"plot-types/polar-plots/compass/","text":"Compass 1 compass ( u , v ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = rand ( 20 , -1 , + 1 ); std :: vector < double > y = rand ( 20 , -1 , + 1 ); compass ( x , y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = rand ( 20 , -1 , + 1 ); std :: vector < double > y = rand ( 20 , -1 , + 1 ); auto ax1 = subplot ( 1 , 2 , 0 ); compass ( ax1 , x , y ); auto ax2 = subplot ( 1 , 2 , 1 ); vectors_handle l = std :: make_shared < class vectors > ( ax2 , x , y ); ax2 -> emplace_object ( l ); show (); return 0 ; }","title":"Compass"},{"location":"plot-types/polar-plots/compass/#compass","text":"1 compass ( u , v ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = rand ( 20 , -1 , + 1 ); std :: vector < double > y = rand ( 20 , -1 , + 1 ); compass ( x , y ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > x = rand ( 20 , -1 , + 1 ); std :: vector < double > y = rand ( 20 , -1 , + 1 ); auto ax1 = subplot ( 1 , 2 , 0 ); compass ( ax1 , x , y ); auto ax2 = subplot ( 1 , 2 , 1 ); vectors_handle l = std :: make_shared < class vectors > ( ax2 , x , y ); ax2 -> emplace_object ( l ); show (); return 0 ; }","title":"Compass"},{"location":"plot-types/polar-plots/polar-function/","text":"Polar Function 1 ezpolar ( fn ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; ezpolar ( \"1+cos(t)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; ezpolar ([]( double t ) { return 1. + cos ( t ); }); show (); return 0 ; }","title":"Polar Function"},{"location":"plot-types/polar-plots/polar-function/#polar-function","text":"1 ezpolar ( fn ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; ezpolar ( \"1+cos(t)\" ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; ezpolar ([]( double t ) { return 1. + cos ( t ); }); show (); return 0 ; }","title":"Polar Function"},{"location":"plot-types/polar-plots/polar-histogram/","text":"Polar Histogram 1 polarhistogram ( theta , 6 ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = { 0.1 , 1.1 , 5.4 , 3.4 , 2.3 , 4.5 , 3.2 , 3.4 , 5.6 , 2.3 , 2.1 , 3.5 , 0.6 , 6.1 }; polarhistogram ( theta , 6 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r1 = rand ( 100000 , 0 , 1 ); auto r2 = rand ( 100000 , 0 , 1 ); std :: vector < double > theta = transform ( r1 , r2 , []( double x , double y ) { return atan2 ( x - .5 , 2 * ( y - .5 )); }); polarhistogram ( theta , 25 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r1 = rand ( 100000 , 0 , 1 ); auto r2 = rand ( 100000 , 0 , 1 ); std :: vector < double > theta = transform ( r1 , r2 , []( double x , double y ) { return atan2 ( x - .5 , 2 * ( y - .5 )); }); auto h = polarhistogram ( theta , 25 ); h -> face_color ( \"red\" ); h -> face_alpha ( 1. - 0.3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r1 = rand ( 100000 , 0 , 1 ); auto r2 = rand ( 100000 , 0 , 1 ); std :: vector < double > theta = transform ( r1 , r2 , []( double x , double y ) { return atan2 ( x - .5 , 2 * ( y - .5 )); }); auto h = polarhistogram ( theta , 25 ); h -> stairs_only ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > y = randp ( 100 , 1.0 , 0.5 ); polarhistogram ( y , 25 ); show (); return 0 ; } The function polarhistogram distributes the data into the number of bins provided as its second parameter.","title":"Polar Histogram"},{"location":"plot-types/polar-plots/polar-histogram/#polar-histogram","text":"1 polarhistogram ( theta , 6 ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = { 0.1 , 1.1 , 5.4 , 3.4 , 2.3 , 4.5 , 3.2 , 3.4 , 5.6 , 2.3 , 2.1 , 3.5 , 0.6 , 6.1 }; polarhistogram ( theta , 6 ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r1 = rand ( 100000 , 0 , 1 ); auto r2 = rand ( 100000 , 0 , 1 ); std :: vector < double > theta = transform ( r1 , r2 , []( double x , double y ) { return atan2 ( x - .5 , 2 * ( y - .5 )); }); polarhistogram ( theta , 25 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r1 = rand ( 100000 , 0 , 1 ); auto r2 = rand ( 100000 , 0 , 1 ); std :: vector < double > theta = transform ( r1 , r2 , []( double x , double y ) { return atan2 ( x - .5 , 2 * ( y - .5 )); }); auto h = polarhistogram ( theta , 25 ); h -> face_color ( \"red\" ); h -> face_alpha ( 1. - 0.3 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r1 = rand ( 100000 , 0 , 1 ); auto r2 = rand ( 100000 , 0 , 1 ); std :: vector < double > theta = transform ( r1 , r2 , []( double x , double y ) { return atan2 ( x - .5 , 2 * ( y - .5 )); }); auto h = polarhistogram ( theta , 25 ); h -> stairs_only ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > y = randp ( 100 , 1.0 , 0.5 ); polarhistogram ( y , 25 ); show (); return 0 ; } The function polarhistogram distributes the data into the number of bins provided as its second parameter.","title":"Polar Histogram"},{"location":"plot-types/polar-plots/polar-line-plot/","text":"Polar Line Plot 1 polarplot ( theta , rho ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( 0 , 0.01 , 2 * pi ); std :: vector < double > rho = transform ( theta , []( auto t ) { return sin ( 2 * t ) * cos ( 2 * t ); }); polarplot ( theta , rho ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta_degrees = linspace ( 0 , 360 , 50 ); std :: vector < double > rho = transform ( theta_degrees , []( auto t ) { return 0.005 * t / 10. ; }); std :: vector < double > theta_radians = deg2rad ( theta_degrees ); polarplot ( theta_radians , rho ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 6 * pi ); std :: vector < double > rho1 = transform ( theta , []( auto t ) { return t / 10. ; }); polarplot ( theta , rho1 ); std :: vector < double > rho2 = transform ( theta , []( auto t ) { return t / 12. ; }); hold ( on ); polarplot ( theta , rho2 , \"--\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > rho = iota ( 10 , 5 , 70 ); polarplot ( rho , \"-o\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi ); std :: vector < double > rho = transform ( theta , []( double t ) { return sin ( t ); }); polarplot ( theta , rho ); gca () -> r_axis (). limits ({ -1 , 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi , 25 ); std :: vector < double > rho = transform ( theta , []( double t ) { return 2 * t ; }); polarplot ( theta , rho , \"r-o\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi , 25 ); std :: vector < double > rho = transform ( theta , []( double t ) { return 2 * t ; }); auto p = polarplot ( theta , rho ); p -> color ( \"magenta\" ); p -> marker ( \"square\" ); p -> marker_size ( 8. ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <complex> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: complex < double >> z = {{ 2 , 3 }, { 2 , 0 }, { -1 , + 4 }, { 3 , -4 }, { 5 , + 2 }, { -4 , -2 }, { -2 , + 3 }, { -2 , 0 }, { 0 , -3 }, { 0 , 1 }}; polarplot ( z ); show (); return 0 ; } By emplacing a polar plot in the axes , the axes move to a polar mode, where we use the and axis instead of the and axis. From the backend point of view, these axes are an abstraction to the user. The data points in the and axis are drawn by converting the positions from the polar coordinates and to the Cartesian coordinates and with the relationships and . Aside from this conversion, these plot subcategories are analogous to line plots, scatter plots, histograms, quiver plots, and line functions.","title":"Polar Line Plot"},{"location":"plot-types/polar-plots/polar-line-plot/#polar-line-plot","text":"1 polarplot ( theta , rho ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( 0 , 0.01 , 2 * pi ); std :: vector < double > rho = transform ( theta , []( auto t ) { return sin ( 2 * t ) * cos ( 2 * t ); }); polarplot ( theta , rho ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta_degrees = linspace ( 0 , 360 , 50 ); std :: vector < double > rho = transform ( theta_degrees , []( auto t ) { return 0.005 * t / 10. ; }); std :: vector < double > theta_radians = deg2rad ( theta_degrees ); polarplot ( theta_radians , rho ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 6 * pi ); std :: vector < double > rho1 = transform ( theta , []( auto t ) { return t / 10. ; }); polarplot ( theta , rho1 ); std :: vector < double > rho2 = transform ( theta , []( auto t ) { return t / 12. ; }); hold ( on ); polarplot ( theta , rho2 , \"--\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > rho = iota ( 10 , 5 , 70 ); polarplot ( rho , \"-o\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi ); std :: vector < double > rho = transform ( theta , []( double t ) { return sin ( t ); }); polarplot ( theta , rho ); gca () -> r_axis (). limits ({ -1 , 1 }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi , 25 ); std :: vector < double > rho = transform ( theta , []( double t ) { return 2 * t ; }); polarplot ( theta , rho , \"r-o\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi , 25 ); std :: vector < double > rho = transform ( theta , []( double t ) { return 2 * t ; }); auto p = polarplot ( theta , rho ); p -> color ( \"magenta\" ); p -> marker ( \"square\" ); p -> marker_size ( 8. ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <complex> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < std :: complex < double >> z = {{ 2 , 3 }, { 2 , 0 }, { -1 , + 4 }, { 3 , -4 }, { 5 , + 2 }, { -4 , -2 }, { -2 , + 3 }, { -2 , 0 }, { 0 , -3 }, { 0 , 1 }}; polarplot ( z ); show (); return 0 ; } By emplacing a polar plot in the axes , the axes move to a polar mode, where we use the and axis instead of the and axis. From the backend point of view, these axes are an abstraction to the user. The data points in the and axis are drawn by converting the positions from the polar coordinates and to the Cartesian coordinates and with the relationships and . Aside from this conversion, these plot subcategories are analogous to line plots, scatter plots, histograms, quiver plots, and line functions.","title":"Polar Line Plot"},{"location":"plot-types/polar-plots/polar-scatter-plot/","text":"Polar Scatter Plot 1 polarscatter ( theta , rho ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( pi / 4 , pi / 4 , 2 * pi ); std :: vector < double > rho = { 19 , 6 , 12 , 18 , 16 , 11 , 15 , 15 }; polarscatter ( theta , rho ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi , 20 ); std :: vector < double > rho = rand ( 20 , 0 , 1 ); double size = 10 ; polarscatter ( theta , rho , size , \"filled\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( pi / 4 , pi / 4 , 2 * pi ); std :: vector < double > rho = { 19 , 6 , 12 , 18 , 16 , 11 , 15 , 15 }; std :: vector < double > sizes = { 6 * 2 , 15 * 2 , 20 * 2 , 3 * 2 , 15 * 2 , 3 * 2 , 6 * 2 , 40 * 2 , }; std :: vector < double > colors = { 1 , 2 , 2 , 2 , 1 , 1 , 2 , 1 , }; auto s = polarscatter ( theta , rho , sizes , colors , \"filled\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 360 , 50 ); std :: vector < double > rho = transform ( theta , []( double t ) { return 0.005 * t / 10. ; }); std :: vector < double > th_radians = deg2rad ( theta ); auto s = polarscatter ( th_radians , rho ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( pi / 6 , pi / 6 , 2 * pi ); std :: vector < double > rho1 = rand ( 12 , 0 , 1 ); polarscatter ( theta , rho1 , \"filled\" ); hold ( on ); std :: vector < double > rho2 = rand ( 12 , 0 , 1 ); polarscatter ( theta , rho2 , \"filled\" ); hold ( off ); auto l = legend ( \"Series A\" , \"Series B\" ); l -> location ( legend :: general_alignment :: topright ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( pi / 6 , pi / 6 , 2 * pi ); std :: vector < double > rho1 = rand ( 12 , 0 , 1 ); auto ps = polarscatter ( theta , rho1 , \"filled\" ); ps -> marker ( \"square\" ); ps -> marker_size ( 20 ); ps -> marker_color ({ 0.5 , 1 , 0 , 0 }); show (); return 0 ; }","title":"Polar Scatter Plot"},{"location":"plot-types/polar-plots/polar-scatter-plot/#polar-scatter-plot","text":"1 polarscatter ( theta , rho ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( pi / 4 , pi / 4 , 2 * pi ); std :: vector < double > rho = { 19 , 6 , 12 , 18 , 16 , 11 , 15 , 15 }; polarscatter ( theta , rho ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 2 * pi , 20 ); std :: vector < double > rho = rand ( 20 , 0 , 1 ); double size = 10 ; polarscatter ( theta , rho , size , \"filled\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( pi / 4 , pi / 4 , 2 * pi ); std :: vector < double > rho = { 19 , 6 , 12 , 18 , 16 , 11 , 15 , 15 }; std :: vector < double > sizes = { 6 * 2 , 15 * 2 , 20 * 2 , 3 * 2 , 15 * 2 , 3 * 2 , 6 * 2 , 40 * 2 , }; std :: vector < double > colors = { 1 , 2 , 2 , 2 , 1 , 1 , 2 , 1 , }; auto s = polarscatter ( theta , rho , sizes , colors , \"filled\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = linspace ( 0 , 360 , 50 ); std :: vector < double > rho = transform ( theta , []( double t ) { return 0.005 * t / 10. ; }); std :: vector < double > th_radians = deg2rad ( theta ); auto s = polarscatter ( th_radians , rho ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( pi / 6 , pi / 6 , 2 * pi ); std :: vector < double > rho1 = rand ( 12 , 0 , 1 ); polarscatter ( theta , rho1 , \"filled\" ); hold ( on ); std :: vector < double > rho2 = rand ( 12 , 0 , 1 ); polarscatter ( theta , rho2 , \"filled\" ); hold ( off ); auto l = legend ( \"Series A\" , \"Series B\" ); l -> location ( legend :: general_alignment :: topright ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( pi / 6 , pi / 6 , 2 * pi ); std :: vector < double > rho1 = rand ( 12 , 0 , 1 ); auto ps = polarscatter ( theta , rho1 , \"filled\" ); ps -> marker ( \"square\" ); ps -> marker_size ( 20 ); ps -> marker_color ({ 0.5 , 1 , 0 , 0 }); show (); return 0 ; }","title":"Polar Scatter Plot"},{"location":"plot-types/surfaces/fence/","text":"Fence 1 fence ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); fence ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); // the fence color will be the average Z in that row vector_1d c ; for ( const auto & row : Z ) { c . emplace_back ( mean ( row )); } fence ( X , Y , Z , c ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); fence ( X , Y , Z ) -> edge_color ( \"b\" ). face_alpha ( 0.5 ); show (); return 0 ; }","title":"Fence"},{"location":"plot-types/surfaces/fence/#fence","text":"1 fence ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); fence ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); // the fence color will be the average Z in that row vector_1d c ; for ( const auto & row : Z ) { c . emplace_back ( mean ( row )); } fence ( X , Y , Z , c ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); fence ( X , Y , Z ) -> edge_color ( \"b\" ). face_alpha ( 0.5 ); show (); return 0 ; }","title":"Fence"},{"location":"plot-types/surfaces/function-mesh/","text":"Function Mesh 1 fmesh ( fn ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fmesh ([]( double x , double y ) { return sin ( x ) + cos ( y ); }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r = []( double u , double v ) { return 2 + sin ( 7 * u + 5 * v ); }; auto funx = [ r ]( double u , double v ) { return r ( u , v ) * cos ( u ) * sin ( v ); }; auto funy = [ r ]( double u , double v ) { return r ( u , v ) * sin ( u ) * sin ( v ); }; auto funz = [ r ]( double u , double v ) { return r ( u , v ) * cos ( v ); }; fmesh ( funx , funy , funz , std :: array < double , 4 > { 0 , 2 * pi , 0 , pi }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fmesh ([]( double x , double y ) { return erf ( x ) + cos ( y ); }, std :: array < double , 4 > { -5 , 0 , -5 , 5 }); hold ( on ); fmesh ([]( double x , double y ) { return sin ( x ) + cos ( y ); }, std :: array < double , 2 > { 0 , 5 }, std :: array < double , 2 > { -5 , 5 }); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fmesh ([]( double x , double y ) { return sin ( x ) + cos ( y ); }) -> edge_color ( \"red\" ); show (); return 0 ; }","title":"Function Mesh"},{"location":"plot-types/surfaces/function-mesh/#function-mesh","text":"1 fmesh ( fn ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fmesh ([]( double x , double y ) { return sin ( x ) + cos ( y ); }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r = []( double u , double v ) { return 2 + sin ( 7 * u + 5 * v ); }; auto funx = [ r ]( double u , double v ) { return r ( u , v ) * cos ( u ) * sin ( v ); }; auto funy = [ r ]( double u , double v ) { return r ( u , v ) * sin ( u ) * sin ( v ); }; auto funz = [ r ]( double u , double v ) { return r ( u , v ) * cos ( v ); }; fmesh ( funx , funy , funz , std :: array < double , 4 > { 0 , 2 * pi , 0 , pi }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fmesh ([]( double x , double y ) { return erf ( x ) + cos ( y ); }, std :: array < double , 4 > { -5 , 0 , -5 , 5 }); hold ( on ); fmesh ([]( double x , double y ) { return sin ( x ) + cos ( y ); }, std :: array < double , 2 > { 0 , 5 }, std :: array < double , 2 > { -5 , 5 }); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fmesh ([]( double x , double y ) { return sin ( x ) + cos ( y ); }) -> edge_color ( \"red\" ); show (); return 0 ; }","title":"Function Mesh"},{"location":"plot-types/surfaces/function-surface/","text":"Function Surface 1 fsurf ( fn ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fsurf ([]( double x , double y ) { return sin ( x ) + cos ( y ); }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fsurf ([]( double x , double y ) { return erf ( x ) + cos ( y ); }, { -5 , 0 , -5 , 5 }); hold ( on ); fsurf ([]( double x , double y ) { return sin ( x ) + cos ( y ); }, { 0 , 5 }, { -5 , 5 }); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r = []( double u , double v ) { return 2 + sin ( 7 * u + 5 * v ); }; auto funx = [ r ]( double u , double v ) { return r ( u , v ) * cos ( u ) * sin ( v ); }; auto funy = [ r ]( double u , double v ) { return r ( u , v ) * sin ( u ) * sin ( v ); }; auto funz = [ r ]( double u , double v ) { return r ( u , v ) * cos ( v ); }; fsurf ( funx , funy , funz , { 0 , 2 * pi , 0 , pi }) -> lighting ( on ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto fn = []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }; fsurf ( fn , { -2 * pi , 2 * pi }); title ( \"ysin(x) - xcos(y) for x and y in [-2\u03c0,2\u03c0]\" ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); box ( on ); auto ax = gca (); ax -> xticks ( iota ( -2 * pi , pi / 2 , 2 * pi )); ax -> xticklabels ( { \"-2\u03c0\" , \"-3\u03c0/2\" , \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" , \"3\u03c0/2\" , \"2\u03c0\" }); ax -> yticks ( iota ( -2 * pi , pi / 2 , 2 * pi )); ax -> yticklabels ( { \"-2\u03c0\" , \"-3\u03c0/2\" , \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" , \"3\u03c0/2\" , \"2\u03c0\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto funx = []( double u , double v ) { return u * sin ( v ); }; auto funy = []( double u , double v ) { return - u * cos ( v ); }; auto funz = []( double u , double v ) { return v ; }; fsurf ( funx , funy , funz , { -5 , 5 , -5 , -2 }, \"--\" ) -> edge_color ( \"g\" ); hold ( on ); fsurf ( funx , funy , funz , { -5 , 5 , -2 , + 2 }) -> edge_color ( \"none\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto funx = []( double u , double v ) { return exp ( - std :: abs ( u ) / 10. ) * sin ( 5 * std :: abs ( v )); }; auto funy = []( double u , double v ) { return exp ( - std :: abs ( u ) / 10. ) * cos ( 5 * std :: abs ( v )); }; auto funz = []( double u , double v ) { return u ; }; fsurf ( funx , funy , funz , std :: array < double , 2 > { -30. , + 30. }) -> face_alpha ( .5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fsurf ([]( double x , double y ) { return peaks ( x , y ); }, { -3 , + 3 }) -> contour_base ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto funx = []( double s , double t ) { return sin ( s ); }; auto funy = []( double s , double t ) { return cos ( s ); }; auto funz = []( double s , double t ) { return t / 10 * sin ( 1. / s ); }; tiledlayout ( 2 , 1 ); nexttile (); fsurf ( funx , funy , funz , std :: array < double , 2 > { -5 , + 5 }, \"\" , 20 ); view ( -172 , 25 ); title ( \"Decreased Mesh Density\" ); nexttile (); fsurf ( funx , funy , funz , std :: array < double , 2 > { -5 , + 5 }, \"\" , 80 ); view ( -172 , 25 ); title ( \"Increased Mesh Density\" ); show (); return 0 ; }","title":"Function Surface"},{"location":"plot-types/surfaces/function-surface/#function-surface","text":"1 fsurf ( fn ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fsurf ([]( double x , double y ) { return sin ( x ) + cos ( y ); }); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fsurf ([]( double x , double y ) { return erf ( x ) + cos ( y ); }, { -5 , 0 , -5 , 5 }); hold ( on ); fsurf ([]( double x , double y ) { return sin ( x ) + cos ( y ); }, { 0 , 5 }, { -5 , 5 }); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto r = []( double u , double v ) { return 2 + sin ( 7 * u + 5 * v ); }; auto funx = [ r ]( double u , double v ) { return r ( u , v ) * cos ( u ) * sin ( v ); }; auto funy = [ r ]( double u , double v ) { return r ( u , v ) * sin ( u ) * sin ( v ); }; auto funz = [ r ]( double u , double v ) { return r ( u , v ) * cos ( v ); }; fsurf ( funx , funy , funz , { 0 , 2 * pi , 0 , pi }) -> lighting ( on ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto fn = []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }; fsurf ( fn , { -2 * pi , 2 * pi }); title ( \"ysin(x) - xcos(y) for x and y in [-2\u03c0,2\u03c0]\" ); xlabel ( \"x\" ); ylabel ( \"y\" ); zlabel ( \"z\" ); box ( on ); auto ax = gca (); ax -> xticks ( iota ( -2 * pi , pi / 2 , 2 * pi )); ax -> xticklabels ( { \"-2\u03c0\" , \"-3\u03c0/2\" , \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" , \"3\u03c0/2\" , \"2\u03c0\" }); ax -> yticks ( iota ( -2 * pi , pi / 2 , 2 * pi )); ax -> yticklabels ( { \"-2\u03c0\" , \"-3\u03c0/2\" , \"-\u03c0\" , \"-\u03c0/2\" , \"0\" , \"\u03c0/2\" , \"\u03c0\" , \"3\u03c0/2\" , \"2\u03c0\" }); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto funx = []( double u , double v ) { return u * sin ( v ); }; auto funy = []( double u , double v ) { return - u * cos ( v ); }; auto funz = []( double u , double v ) { return v ; }; fsurf ( funx , funy , funz , { -5 , 5 , -5 , -2 }, \"--\" ) -> edge_color ( \"g\" ); hold ( on ); fsurf ( funx , funy , funz , { -5 , 5 , -2 , + 2 }) -> edge_color ( \"none\" ); hold ( off ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto funx = []( double u , double v ) { return exp ( - std :: abs ( u ) / 10. ) * sin ( 5 * std :: abs ( v )); }; auto funy = []( double u , double v ) { return exp ( - std :: abs ( u ) / 10. ) * cos ( 5 * std :: abs ( v )); }; auto funz = []( double u , double v ) { return u ; }; fsurf ( funx , funy , funz , std :: array < double , 2 > { -30. , + 30. }) -> face_alpha ( .5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; fsurf ([]( double x , double y ) { return peaks ( x , y ); }, { -3 , + 3 }) -> contour_base ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto funx = []( double s , double t ) { return sin ( s ); }; auto funy = []( double s , double t ) { return cos ( s ); }; auto funz = []( double s , double t ) { return t / 10 * sin ( 1. / s ); }; tiledlayout ( 2 , 1 ); nexttile (); fsurf ( funx , funy , funz , std :: array < double , 2 > { -5 , + 5 }, \"\" , 20 ); view ( -172 , 25 ); title ( \"Decreased Mesh Density\" ); nexttile (); fsurf ( funx , funy , funz , std :: array < double , 2 > { -5 , + 5 }, \"\" , 80 ); view ( -172 , 25 ); title ( \"Increased Mesh Density\" ); show (); return 0 ; }","title":"Function Surface"},{"location":"plot-types/surfaces/mesh-with-contour/","text":"Mesh with Contour 1 meshc ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , + 3 )); auto Z = peaks ( X , Y ); meshc ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , + 3 )); auto Z = peaks ( X , Y ); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); meshc ( X , Y , Z , C ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , + 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); auto sc = meshc ( X , Y , Z ); sc -> edge_color ( \"r\" ); sc -> contour_line_spec (). color ( \"b\" ); show (); return 0 ; }","title":"Mesh with Contour"},{"location":"plot-types/surfaces/mesh-with-contour/#mesh-with-contour","text":"1 meshc ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , + 3 )); auto Z = peaks ( X , Y ); meshc ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , + 3 )); auto Z = peaks ( X , Y ); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); meshc ( X , Y , Z , C ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , + 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); auto sc = meshc ( X , Y , Z ); sc -> edge_color ( \"r\" ); sc -> contour_line_spec (). color ( \"b\" ); show (); return 0 ; }","title":"Mesh with Contour"},{"location":"plot-types/surfaces/mesh-with-curtain/","text":"Mesh with Curtain 1 meshz ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); meshz ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); auto [ FX , FY ] = gradient ( Z ); meshz ( X , Y , Z , FX ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); meshz ( X , Y , Z ) -> edge_color ( \"b\" ); show (); return 0 ; }","title":"Mesh with Curtain"},{"location":"plot-types/surfaces/mesh-with-curtain/#mesh-with-curtain","text":"1 meshz ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); meshz ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); auto [ FX , FY ] = gradient ( Z ); meshz ( X , Y , Z , FX ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); meshz ( X , Y , Z ) -> edge_color ( \"b\" ); show (); return 0 ; }","title":"Mesh with Curtain"},{"location":"plot-types/surfaces/mesh/","text":"Mesh 1 mesh ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -8 , .5 , + 8 )); auto Z = transform ( X , Y , []( double x , double y ) { double eps = std :: nextafter ( 0.0 , 1.0 ); double R = sqrt ( pow ( x , 2 ) + pow ( y , 2 )) + eps ; return sin ( R ) / R ; }); mesh ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -8 , .5 , + 8 )); auto Z = transform ( X , Y , []( double x , double y ) { double eps = std :: nextafter ( 0.0 , 1.0 ); double R = sqrt ( pow ( x , 2 ) + pow ( y , 2 )) + eps ; return sin ( R ) / R ; }); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); mesh ( X , Y , Z , C ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , + 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); mesh ( X , Y , Z ) -> palette_map_at_surface ( true ). face_alpha ( 0.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); mesh ( X , Y , Z ) -> hidden_3d ( false ); show (); return 0 ; }","title":"Mesh"},{"location":"plot-types/surfaces/mesh/#mesh","text":"1 mesh ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -8 , .5 , + 8 )); auto Z = transform ( X , Y , []( double x , double y ) { double eps = std :: nextafter ( 0.0 , 1.0 ); double R = sqrt ( pow ( x , 2 ) + pow ( y , 2 )) + eps ; return sin ( R ) / R ; }); mesh ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -8 , .5 , + 8 )); auto Z = transform ( X , Y , []( double x , double y ) { double eps = std :: nextafter ( 0.0 , 1.0 ); double R = sqrt ( pow ( x , 2 ) + pow ( y , 2 )) + eps ; return sin ( R ) / R ; }); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); mesh ( X , Y , Z , C ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , + 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); mesh ( X , Y , Z ) -> palette_map_at_surface ( true ). face_alpha ( 0.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y , Z ] = peaks (); mesh ( X , Y , Z ) -> hidden_3d ( false ); show (); return 0 ; }","title":"Mesh"},{"location":"plot-types/surfaces/ribbon/","text":"Ribbon 1 ribbon ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .5 , 3 ), iota ( -3 , .1 , 3 )); auto Z = peaks ( X , Y ); ribbon ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .5 , 3 ), iota ( -3 , .1 , 3 )); auto Z = peaks ( X , Y ); auto [ FX , FY ] = gradient ( Z ); ribbon ( X , Y , Z , FX , 1.0 ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); ribbon ( X , Y , Z ) -> edge_color ( \"green\" ). face_alpha ( 0.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto rastrigin = []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }; auto [ X , Y ] = meshgrid ( iota ( -5 , 1. , 5 ), iota ( -5 , .1 , 5 )); auto Z = transform ( X , Y , rastrigin ); ribbon ( X , Y , Z ) -> face_alpha ( 0.8 ); show (); return 0 ; }","title":"Ribbon"},{"location":"plot-types/surfaces/ribbon/#ribbon","text":"1 ribbon ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .5 , 3 ), iota ( -3 , .1 , 3 )); auto Z = peaks ( X , Y ); ribbon ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .5 , 3 ), iota ( -3 , .1 , 3 )); auto Z = peaks ( X , Y ); auto [ FX , FY ] = gradient ( Z ); ribbon ( X , Y , Z , FX , 1.0 ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); ribbon ( X , Y , Z ) -> edge_color ( \"green\" ). face_alpha ( 0.5 ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto rastrigin = []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }; auto [ X , Y ] = meshgrid ( iota ( -5 , 1. , 5 ), iota ( -5 , .1 , 5 )); auto Z = transform ( X , Y , rastrigin ); ribbon ( X , Y , Z ) -> face_alpha ( 0.8 ); show (); return 0 ; }","title":"Ribbon"},{"location":"plot-types/surfaces/surface-with-contour/","text":"Surface with Contour 1 surfc ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( linspace ( -5 , + 5 , 70 ), linspace ( -5 , + 5 , 70 )); auto Z = transform ( X , Y , []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }); surfc ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , .5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); auto s = surfc ( X , Y , Z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); surfc ( X , Y , Z , C ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); surfc ( X , Y , Z ) -> edge_color ({ 0 , 1 , 0 , 0 }); colormap ({{ 0 , 0 , 1 }}); show (); return 0 ; }","title":"Surface with Contour"},{"location":"plot-types/surfaces/surface-with-contour/#surface-with-contour","text":"1 surfc ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( linspace ( -5 , + 5 , 70 ), linspace ( -5 , + 5 , 70 )); auto Z = transform ( X , Y , []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }); surfc ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , .5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); auto s = surfc ( X , Y , Z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); surfc ( X , Y , Z , C ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); surfc ( X , Y , Z ) -> edge_color ({ 0 , 1 , 0 , 0 }); colormap ({{ 0 , 0 , 1 }}); show (); return 0 ; }","title":"Surface with Contour"},{"location":"plot-types/surfaces/surface/","text":"Surface 1 surf ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( linspace ( -5 , + 5 , 40 ), linspace ( -5 , + 5 , 40 )); auto Z = transform ( X , Y , []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }); surf ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , 0.5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); surf ( X , Y , Z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , 0.5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); surf ( X , Y , Z , C ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , 0.5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); surf ( X , Y , Z ) -> face_alpha ( 0.5 ). edge_color ( \"none\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , .5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); surf ( X , Y , Z ) -> lighting ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , .5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); surf ( X , Y , Z ) -> edge_color ( \"none\" ). lighting ( true ); show (); return 0 ; }","title":"Surface"},{"location":"plot-types/surfaces/surface/#surface","text":"1 surf ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( linspace ( -5 , + 5 , 40 ), linspace ( -5 , + 5 , 40 )); auto Z = transform ( X , Y , []( double x , double y ) { return 10 * 2 + pow ( x , 2 ) - 10 * cos ( 2 * pi * x ) + pow ( y , 2 ) - 10 * cos ( 2 * pi * y ); }); surf ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , 0.5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); surf ( X , Y , Z ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , 0.5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); surf ( X , Y , Z , C ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , 0.5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); auto C = transform ( X , Y , []( double x , double y ) { return x * y ; }); surf ( X , Y , Z ) -> face_alpha ( 0.5 ). edge_color ( \"none\" ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , .5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); surf ( X , Y , Z ) -> lighting ( true ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( 1 , .5 , 10 ), iota ( 1 , 20 )); auto Z = transform ( X , Y , []( double x , double y ) { return sin ( x ) + cos ( y ); }); surf ( X , Y , Z ) -> edge_color ( \"none\" ). lighting ( true ); show (); return 0 ; }","title":"Surface"},{"location":"plot-types/surfaces/waterfall/","text":"Waterfall 1 waterfall ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); waterfall ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); auto [ FX , FY ] = gradient ( Z ); waterfall ( X , Y , Z , FX ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); waterfall ( X , Y , Z ) -> edge_color ( \"b\" ); show (); return 0 ; }","title":"Waterfall"},{"location":"plot-types/surfaces/waterfall/#waterfall","text":"1 waterfall ( X , Y , Z ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); waterfall ( X , Y , Z ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -3 , .125 , 3 )); auto Z = peaks ( X , Y ); auto [ FX , FY ] = gradient ( Z ); waterfall ( X , Y , Z , FX ); colorbar (); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ X , Y ] = meshgrid ( iota ( -5 , .5 , 5 )); auto Z = transform ( X , Y , []( double x , double y ) { return y * sin ( x ) - x * cos ( y ); }); waterfall ( X , Y , Z ) -> edge_color ( \"b\" ); show (); return 0 ; }","title":"Waterfall"},{"location":"plot-types/vector-fields/feather/","text":"Feather 1 feather ( u , v ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( - pi / 2 , pi / 16 , pi / 2 ); std :: vector < double > rho ( theta . size (), 2. ); auto [ u , v ] = pol2cart ( theta , rho ); feather ( u , v ); show (); return 0 ; }","title":"Feather"},{"location":"plot-types/vector-fields/feather/#feather","text":"1 feather ( u , v ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; std :: vector < double > theta = iota ( - pi / 2 , pi / 16 , pi / 2 ); std :: vector < double > rho ( theta . size (), 2. ); auto [ u , v ] = pol2cart ( theta , rho ); feather ( u , v ); show (); return 0 ; }","title":"Feather"},{"location":"plot-types/vector-fields/quiver-3d/","text":"Quiver 3D 1 quiver3 ( Z , U , V , W ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include <cmath> #include <matplot/matplot.h> matplot :: vector_2d get_u (); matplot :: vector_2d get_v (); matplot :: vector_2d get_w (); int main () { using namespace matplot ; vector_1d x = iota ( -3 , 0.5 , 3 ); vector_1d y = iota ( -3 , 0.5 , 3 ); auto [ X , Y ] = meshgrid ( x , y ); vector_2d Z = transform ( X , Y , []( double x , double y ) { return pow ( y , 2 ) - pow ( x , 2 ); }); auto U = get_u (); auto V = get_v (); auto W = get_w (); quiver3 ( Z , U , V , W ); view ( -35 , 45 ); show (); return 0 ; } matplot :: vector_2d get_u () { matplot :: vector_2d x = { { -0.688247 , -0.620174 , -0.534522 , -0.428571 , -0.301511 , -0.156174 , 0 , 0.156174 , 0.301511 , 0.428571 , 0.534522 , 0.620174 , 0.688247 }, { -0.744208 , -0.680414 , -0.596285 , -0.486664 , -0.348155 , -0.182574 , 0 , 0.182574 , 0.348155 , 0.486664 , 0.596285 , 0.680414 , 0.744208 }, { -0.801784 , -0.745356 , -0.666667 , -0.557086 , -0.408248 , -0.218218 , 0 , 0.218218 , 0.408248 , 0.557086 , 0.666667 , 0.745356 , 0.801784 }, { -0.857143 , -0.811107 , -0.742781 , -0.639602 , -0.485071 , -0.267261 , 0 , 0.267261 , 0.485071 , 0.639602 , 0.742781 , 0.811107 , 0.857143 }, { -0.904534 , -0.870388 , -0.816497 , -0.727607 , -0.57735 , -0.333333 , 0 , 0.333333 , 0.57735 , 0.727607 , 0.816497 , 0.870388 , 0.904534 }, { -0.937043 , -0.912871 , -0.872872 , -0.801784 , -0.666667 , -0.408248 , 0 , 0.408248 , 0.666667 , 0.801784 , 0.872872 , 0.912871 , 0.937043 }, { -0.948683 , -0.928477 , -0.894427 , -0.83205 , -0.707107 , -0.447214 , -0 , 0.447214 , 0.707107 , 0.83205 , 0.894427 , 0.928477 , 0.948683 }, { -0.937043 , -0.912871 , -0.872872 , -0.801784 , -0.666667 , -0.408248 , -0 , 0.408248 , 0.666667 , 0.801784 , 0.872872 , 0.912871 , 0.937043 }, { -0.904534 , -0.870388 , -0.816497 , -0.727607 , -0.57735 , -0.333333 , -0 , 0.333333 , 0.57735 , 0.727607 , 0.816497 , 0.870388 , 0.904534 }, { -0.857143 , -0.811107 , -0.742781 , -0.639602 , -0.485071 , -0.267261 , -0 , 0.267261 , 0.485071 , 0.639602 , 0.742781 , 0.811107 , 0.857143 }, { -0.801784 , -0.745356 , -0.666667 , -0.557086 , -0.408248 , -0.218218 , -0 , 0.218218 , 0.408248 , 0.557086 , 0.666667 , 0.745356 , 0.801784 }, { -0.744208 , -0.680414 , -0.596285 , -0.486664 , -0.348155 , -0.182574 , -0 , 0.182574 , 0.348155 , 0.486664 , 0.596285 , 0.680414 , 0.744208 }, { -0.688247 , -0.620174 , -0.534522 , -0.428571 , -0.301511 , -0.156174 , -0 , 0.156174 , 0.301511 , 0.428571 , 0.534522 , 0.620174 , 0.688247 }}; return x ; } matplot :: vector_2d get_v () { matplot :: vector_2d x = { { 0.688247 , 0.744208 , 0.801784 , 0.857143 , 0.904534 , 0.937043 , 0.948683 , 0.937043 , 0.904534 , 0.857143 , 0.801784 , 0.744208 , 0.688247 }, { 0.620174 , 0.680414 , 0.745356 , 0.811107 , 0.870388 , 0.912871 , 0.928477 , 0.912871 , 0.870388 , 0.811107 , 0.745356 , 0.680414 , 0.620174 }, { 0.534522 , 0.596285 , 0.666667 , 0.742781 , 0.816497 , 0.872872 , 0.894427 , 0.872872 , 0.816497 , 0.742781 , 0.666667 , 0.596285 , 0.534522 }, { 0.428571 , 0.486664 , 0.557086 , 0.639602 , 0.727607 , 0.801784 , 0.83205 , 0.801784 , 0.727607 , 0.639602 , 0.557086 , 0.486664 , 0.428571 }, { 0.301511 , 0.348155 , 0.408248 , 0.485071 , 0.57735 , 0.666667 , 0.707107 , 0.666667 , 0.57735 , 0.485071 , 0.408248 , 0.348155 , 0.301511 }, { 0.156174 , 0.182574 , 0.218218 , 0.267261 , 0.333333 , 0.408248 , 0.447214 , 0.408248 , 0.333333 , 0.267261 , 0.218218 , 0.182574 , 0.156174 }, { -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 }, { -0.156174 , -0.182574 , -0.218218 , -0.267261 , -0.333333 , -0.408248 , -0.447214 , -0.408248 , -0.333333 , -0.267261 , -0.218218 , -0.182574 , -0.156174 }, { -0.301511 , -0.348155 , -0.408248 , -0.485071 , -0.57735 , -0.666667 , -0.707107 , -0.666667 , -0.57735 , -0.485071 , -0.408248 , -0.348155 , -0.301511 }, { -0.428571 , -0.486664 , -0.557086 , -0.639602 , -0.727607 , -0.801784 , -0.83205 , -0.801784 , -0.727607 , -0.639602 , -0.557086 , -0.486664 , -0.428571 }, { -0.534522 , -0.596285 , -0.666667 , -0.742781 , -0.816497 , -0.872872 , -0.894427 , -0.872872 , -0.816497 , -0.742781 , -0.666667 , -0.596285 , -0.534522 }, { -0.620174 , -0.680414 , -0.745356 , -0.811107 , -0.870388 , -0.912871 , -0.928477 , -0.912871 , -0.870388 , -0.811107 , -0.745356 , -0.680414 , -0.620174 }, { -0.688247 , -0.744208 , -0.801784 , -0.857143 , -0.904534 , -0.937043 , -0.948683 , -0.937043 , -0.904534 , -0.857143 , -0.801784 , -0.744208 , -0.688247 }}; return x ; } matplot :: vector_2d get_w () { matplot :: vector_2d x = { { 0.229416 , 0.248069 , 0.267261 , 0.285714 , 0.301511 , 0.312348 , 0.316228 , 0.312348 , 0.301511 , 0.285714 , 0.267261 , 0.248069 , 0.229416 }, { 0.248069 , 0.272166 , 0.298142 , 0.324443 , 0.348155 , 0.365148 , 0.371391 , 0.365148 , 0.348155 , 0.324443 , 0.298142 , 0.272166 , 0.248069 }, { 0.267261 , 0.298142 , 0.333333 , 0.371391 , 0.408248 , 0.436436 , 0.447214 , 0.436436 , 0.408248 , 0.371391 , 0.333333 , 0.298142 , 0.267261 }, { 0.285714 , 0.324443 , 0.371391 , 0.426401 , 0.485071 , 0.534522 , 0.5547 , 0.534522 , 0.485071 , 0.426401 , 0.371391 , 0.324443 , 0.285714 }, { 0.301511 , 0.348155 , 0.408248 , 0.485071 , 0.57735 , 0.666667 , 0.707107 , 0.666667 , 0.57735 , 0.485071 , 0.408248 , 0.348155 , 0.301511 }, { 0.312348 , 0.365148 , 0.436436 , 0.534522 , 0.666667 , 0.816497 , 0.894427 , 0.816497 , 0.666667 , 0.534522 , 0.436436 , 0.365148 , 0.312348 }, { 0.316228 , 0.371391 , 0.447214 , 0.5547 , 0.707107 , 0.894427 , 1 , 0.894427 , 0.707107 , 0.5547 , 0.447214 , 0.371391 , 0.316228 }, { 0.312348 , 0.365148 , 0.436436 , 0.534522 , 0.666667 , 0.816497 , 0.894427 , 0.816497 , 0.666667 , 0.534522 , 0.436436 , 0.365148 , 0.312348 }, { 0.301511 , 0.348155 , 0.408248 , 0.485071 , 0.57735 , 0.666667 , 0.707107 , 0.666667 , 0.57735 , 0.485071 , 0.408248 , 0.348155 , 0.301511 }, { 0.285714 , 0.324443 , 0.371391 , 0.426401 , 0.485071 , 0.534522 , 0.5547 , 0.534522 , 0.485071 , 0.426401 , 0.371391 , 0.324443 , 0.285714 }, { 0.267261 , 0.298142 , 0.333333 , 0.371391 , 0.408248 , 0.436436 , 0.447214 , 0.436436 , 0.408248 , 0.371391 , 0.333333 , 0.298142 , 0.267261 }, { 0.248069 , 0.272166 , 0.298142 , 0.324443 , 0.348155 , 0.365148 , 0.371391 , 0.365148 , 0.348155 , 0.324443 , 0.298142 , 0.272166 , 0.248069 }, { 0.229416 , 0.248069 , 0.267261 , 0.285714 , 0.301511 , 0.312348 , 0.316228 , 0.312348 , 0.301511 , 0.285714 , 0.267261 , 0.248069 , 0.229416 }}; return x ; }","title":"Quiver 3D"},{"location":"plot-types/vector-fields/quiver-3d/#quiver-3d","text":"1 quiver3 ( Z , U , V , W ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include <cmath> #include <matplot/matplot.h> matplot :: vector_2d get_u (); matplot :: vector_2d get_v (); matplot :: vector_2d get_w (); int main () { using namespace matplot ; vector_1d x = iota ( -3 , 0.5 , 3 ); vector_1d y = iota ( -3 , 0.5 , 3 ); auto [ X , Y ] = meshgrid ( x , y ); vector_2d Z = transform ( X , Y , []( double x , double y ) { return pow ( y , 2 ) - pow ( x , 2 ); }); auto U = get_u (); auto V = get_v (); auto W = get_w (); quiver3 ( Z , U , V , W ); view ( -35 , 45 ); show (); return 0 ; } matplot :: vector_2d get_u () { matplot :: vector_2d x = { { -0.688247 , -0.620174 , -0.534522 , -0.428571 , -0.301511 , -0.156174 , 0 , 0.156174 , 0.301511 , 0.428571 , 0.534522 , 0.620174 , 0.688247 }, { -0.744208 , -0.680414 , -0.596285 , -0.486664 , -0.348155 , -0.182574 , 0 , 0.182574 , 0.348155 , 0.486664 , 0.596285 , 0.680414 , 0.744208 }, { -0.801784 , -0.745356 , -0.666667 , -0.557086 , -0.408248 , -0.218218 , 0 , 0.218218 , 0.408248 , 0.557086 , 0.666667 , 0.745356 , 0.801784 }, { -0.857143 , -0.811107 , -0.742781 , -0.639602 , -0.485071 , -0.267261 , 0 , 0.267261 , 0.485071 , 0.639602 , 0.742781 , 0.811107 , 0.857143 }, { -0.904534 , -0.870388 , -0.816497 , -0.727607 , -0.57735 , -0.333333 , 0 , 0.333333 , 0.57735 , 0.727607 , 0.816497 , 0.870388 , 0.904534 }, { -0.937043 , -0.912871 , -0.872872 , -0.801784 , -0.666667 , -0.408248 , 0 , 0.408248 , 0.666667 , 0.801784 , 0.872872 , 0.912871 , 0.937043 }, { -0.948683 , -0.928477 , -0.894427 , -0.83205 , -0.707107 , -0.447214 , -0 , 0.447214 , 0.707107 , 0.83205 , 0.894427 , 0.928477 , 0.948683 }, { -0.937043 , -0.912871 , -0.872872 , -0.801784 , -0.666667 , -0.408248 , -0 , 0.408248 , 0.666667 , 0.801784 , 0.872872 , 0.912871 , 0.937043 }, { -0.904534 , -0.870388 , -0.816497 , -0.727607 , -0.57735 , -0.333333 , -0 , 0.333333 , 0.57735 , 0.727607 , 0.816497 , 0.870388 , 0.904534 }, { -0.857143 , -0.811107 , -0.742781 , -0.639602 , -0.485071 , -0.267261 , -0 , 0.267261 , 0.485071 , 0.639602 , 0.742781 , 0.811107 , 0.857143 }, { -0.801784 , -0.745356 , -0.666667 , -0.557086 , -0.408248 , -0.218218 , -0 , 0.218218 , 0.408248 , 0.557086 , 0.666667 , 0.745356 , 0.801784 }, { -0.744208 , -0.680414 , -0.596285 , -0.486664 , -0.348155 , -0.182574 , -0 , 0.182574 , 0.348155 , 0.486664 , 0.596285 , 0.680414 , 0.744208 }, { -0.688247 , -0.620174 , -0.534522 , -0.428571 , -0.301511 , -0.156174 , -0 , 0.156174 , 0.301511 , 0.428571 , 0.534522 , 0.620174 , 0.688247 }}; return x ; } matplot :: vector_2d get_v () { matplot :: vector_2d x = { { 0.688247 , 0.744208 , 0.801784 , 0.857143 , 0.904534 , 0.937043 , 0.948683 , 0.937043 , 0.904534 , 0.857143 , 0.801784 , 0.744208 , 0.688247 }, { 0.620174 , 0.680414 , 0.745356 , 0.811107 , 0.870388 , 0.912871 , 0.928477 , 0.912871 , 0.870388 , 0.811107 , 0.745356 , 0.680414 , 0.620174 }, { 0.534522 , 0.596285 , 0.666667 , 0.742781 , 0.816497 , 0.872872 , 0.894427 , 0.872872 , 0.816497 , 0.742781 , 0.666667 , 0.596285 , 0.534522 }, { 0.428571 , 0.486664 , 0.557086 , 0.639602 , 0.727607 , 0.801784 , 0.83205 , 0.801784 , 0.727607 , 0.639602 , 0.557086 , 0.486664 , 0.428571 }, { 0.301511 , 0.348155 , 0.408248 , 0.485071 , 0.57735 , 0.666667 , 0.707107 , 0.666667 , 0.57735 , 0.485071 , 0.408248 , 0.348155 , 0.301511 }, { 0.156174 , 0.182574 , 0.218218 , 0.267261 , 0.333333 , 0.408248 , 0.447214 , 0.408248 , 0.333333 , 0.267261 , 0.218218 , 0.182574 , 0.156174 }, { -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 , -0 }, { -0.156174 , -0.182574 , -0.218218 , -0.267261 , -0.333333 , -0.408248 , -0.447214 , -0.408248 , -0.333333 , -0.267261 , -0.218218 , -0.182574 , -0.156174 }, { -0.301511 , -0.348155 , -0.408248 , -0.485071 , -0.57735 , -0.666667 , -0.707107 , -0.666667 , -0.57735 , -0.485071 , -0.408248 , -0.348155 , -0.301511 }, { -0.428571 , -0.486664 , -0.557086 , -0.639602 , -0.727607 , -0.801784 , -0.83205 , -0.801784 , -0.727607 , -0.639602 , -0.557086 , -0.486664 , -0.428571 }, { -0.534522 , -0.596285 , -0.666667 , -0.742781 , -0.816497 , -0.872872 , -0.894427 , -0.872872 , -0.816497 , -0.742781 , -0.666667 , -0.596285 , -0.534522 }, { -0.620174 , -0.680414 , -0.745356 , -0.811107 , -0.870388 , -0.912871 , -0.928477 , -0.912871 , -0.870388 , -0.811107 , -0.745356 , -0.680414 , -0.620174 }, { -0.688247 , -0.744208 , -0.801784 , -0.857143 , -0.904534 , -0.937043 , -0.948683 , -0.937043 , -0.904534 , -0.857143 , -0.801784 , -0.744208 , -0.688247 }}; return x ; } matplot :: vector_2d get_w () { matplot :: vector_2d x = { { 0.229416 , 0.248069 , 0.267261 , 0.285714 , 0.301511 , 0.312348 , 0.316228 , 0.312348 , 0.301511 , 0.285714 , 0.267261 , 0.248069 , 0.229416 }, { 0.248069 , 0.272166 , 0.298142 , 0.324443 , 0.348155 , 0.365148 , 0.371391 , 0.365148 , 0.348155 , 0.324443 , 0.298142 , 0.272166 , 0.248069 }, { 0.267261 , 0.298142 , 0.333333 , 0.371391 , 0.408248 , 0.436436 , 0.447214 , 0.436436 , 0.408248 , 0.371391 , 0.333333 , 0.298142 , 0.267261 }, { 0.285714 , 0.324443 , 0.371391 , 0.426401 , 0.485071 , 0.534522 , 0.5547 , 0.534522 , 0.485071 , 0.426401 , 0.371391 , 0.324443 , 0.285714 }, { 0.301511 , 0.348155 , 0.408248 , 0.485071 , 0.57735 , 0.666667 , 0.707107 , 0.666667 , 0.57735 , 0.485071 , 0.408248 , 0.348155 , 0.301511 }, { 0.312348 , 0.365148 , 0.436436 , 0.534522 , 0.666667 , 0.816497 , 0.894427 , 0.816497 , 0.666667 , 0.534522 , 0.436436 , 0.365148 , 0.312348 }, { 0.316228 , 0.371391 , 0.447214 , 0.5547 , 0.707107 , 0.894427 , 1 , 0.894427 , 0.707107 , 0.5547 , 0.447214 , 0.371391 , 0.316228 }, { 0.312348 , 0.365148 , 0.436436 , 0.534522 , 0.666667 , 0.816497 , 0.894427 , 0.816497 , 0.666667 , 0.534522 , 0.436436 , 0.365148 , 0.312348 }, { 0.301511 , 0.348155 , 0.408248 , 0.485071 , 0.57735 , 0.666667 , 0.707107 , 0.666667 , 0.57735 , 0.485071 , 0.408248 , 0.348155 , 0.301511 }, { 0.285714 , 0.324443 , 0.371391 , 0.426401 , 0.485071 , 0.534522 , 0.5547 , 0.534522 , 0.485071 , 0.426401 , 0.371391 , 0.324443 , 0.285714 }, { 0.267261 , 0.298142 , 0.333333 , 0.371391 , 0.408248 , 0.436436 , 0.447214 , 0.436436 , 0.408248 , 0.371391 , 0.333333 , 0.298142 , 0.267261 }, { 0.248069 , 0.272166 , 0.298142 , 0.324443 , 0.348155 , 0.365148 , 0.371391 , 0.365148 , 0.348155 , 0.324443 , 0.298142 , 0.272166 , 0.248069 }, { 0.229416 , 0.248069 , 0.267261 , 0.285714 , 0.301511 , 0.312348 , 0.316228 , 0.312348 , 0.301511 , 0.285714 , 0.267261 , 0.248069 , 0.229416 }}; return x ; }","title":"Quiver 3D"},{"location":"plot-types/vector-fields/quiver/","text":"Quiver 1 quiver ( x , y , u , v ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( 0 , 0.2 , 2 ), iota ( 0 , 0.2 , 2 )); vector_2d u = transform ( x , y , []( double x , double y ) { return cos ( x ) * y ; }); vector_2d v = transform ( x , y , []( double x , double y ) { return sin ( x ) * y ; }); quiver ( x , y , u , v ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( 0 , 0.2 , 2 ), iota ( 0 , 0.2 , 2 )); vector_2d u = transform ( x , y , []( double x , double y ) { return cos ( x ) * y ; }); vector_2d v = transform ( x , y , []( double x , double y ) { return sin ( x ) * y ; }); quiver ( x , y , u , v , 2. ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( 0 , 0.2 , 2 ), iota ( 0 , 0.2 , 2 )); vector_2d u = transform ( x , y , []( double x , double y ) { return cos ( x ) * y ; }); vector_2d v = transform ( x , y , []( double x , double y ) { return sin ( x ) * y ; }); quiver ( x , y , u , v , 0. ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( -2 , 0.2 , 2 )); auto z = transform ( x , y , []( double x , double y ) { return x * exp ( - pow ( x , 2 ) - pow ( y , 2 )); }); auto [ dx , dy ] = gradient ( z , .2 , .2 ); contour ( x , y , z ); hold ( on ); quiver ( x , y , dx , dy ); hold ( off ); show (); return 0 ; } All these subcategories depend on the vectors object type. In a two-dimensional plot, for each value of and with the position of a vector, it also requires the value of and indicating its direction and magnitude. In a three-dimensional plot, the direction and magnitude are defined by , , and . A quiver plot (or velocity plot) shows a grid of vectors whose direction and magnitude are scaled to prevent the overlap between vectors in subsequent quads.","title":"Quiver"},{"location":"plot-types/vector-fields/quiver/#quiver","text":"1 quiver ( x , y , u , v ); Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( 0 , 0.2 , 2 ), iota ( 0 , 0.2 , 2 )); vector_2d u = transform ( x , y , []( double x , double y ) { return cos ( x ) * y ; }); vector_2d v = transform ( x , y , []( double x , double y ) { return sin ( x ) * y ; }); quiver ( x , y , u , v ); show (); return 0 ; } More examples Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( 0 , 0.2 , 2 ), iota ( 0 , 0.2 , 2 )); vector_2d u = transform ( x , y , []( double x , double y ) { return cos ( x ) * y ; }); vector_2d v = transform ( x , y , []( double x , double y ) { return sin ( x ) * y ; }); quiver ( x , y , u , v , 2. ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( 0 , 0.2 , 2 ), iota ( 0 , 0.2 , 2 )); vector_2d u = transform ( x , y , []( double x , double y ) { return cos ( x ) * y ; }); vector_2d v = transform ( x , y , []( double x , double y ) { return sin ( x ) * y ; }); quiver ( x , y , u , v , 0. ); show (); return 0 ; } Plot C++ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include <cmath> #include <matplot/matplot.h> int main () { using namespace matplot ; auto [ x , y ] = meshgrid ( iota ( -2 , 0.2 , 2 )); auto z = transform ( x , y , []( double x , double y ) { return x * exp ( - pow ( x , 2 ) - pow ( y , 2 )); }); auto [ dx , dy ] = gradient ( z , .2 , .2 ); contour ( x , y , z ); hold ( on ); quiver ( x , y , dx , dy ); hold ( off ); show (); return 0 ; } All these subcategories depend on the vectors object type. In a two-dimensional plot, for each value of and with the position of a vector, it also requires the value of and indicating its direction and magnitude. In a three-dimensional plot, the direction and magnitude are defined by , , and . A quiver plot (or velocity plot) shows a grid of vectors whose direction and magnitude are scaled to prevent the overlap between vectors in subsequent quads.","title":"Quiver"}]}